<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US">
  <id>https://github.com/oscarlucas22/</id>
  <title>LucasBlog</title>
  <author>
    <name>Óscar Lucas</name>
  </author>
  <updated>2023-03-07T17:02:54.362Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://github.com/oscarlucas22/atom.xml"/>
  <link rel="alternate" href="https://github.com/oscarlucas22/"/>
  <category term="categorías"/>
  <category term="practicas"/>
  <contributor>
    <name>Óscar Lucas</name>
  </contributor>
  <entry>
    <title type="html">IAW</title>
    <id>https://github.com/oscarlucas22/category/IAW/</id>
    <link href="https://github.com/oscarlucas22/category/IAW/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="iaw"> IAW</h1>
<ul>
<li>
<p><a href="/practicas/django.html">Instalación/migración de aplicaciones web Python</a></p>
</li>
<li>
<p><a href="/practicas/java.html">Despliegue de aplicaciones Java</a></p>
</li>
<li>
<p><a href="/noacabado/noacabado.html">Implantación de aplicaciones web PHP en docker</a></p>
</li>
<li>
<p><a href="/practicas/python-docker.html">Implantación de aplicaciones web Python en docker</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="categorías" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">ABD</title>
    <id>https://github.com/oscarlucas22/category/ABD/</id>
    <link href="https://github.com/oscarlucas22/category/ABD/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="abd"> ABD</h1>
<ul>
<li>
<p><a href="/practicas/BD.html">Servidores y Clientes de Base de Datos</a></p>
</li>
<li>
<p><a href="/practicas/orcl-psql.html">Interconexión Servidores</a></p>
</li>
<li>
<p><a href="/practicas/usuarios.html">Usuarios</a></p>
</li>
<li>
<p><a href="/practicas/almacenamiento.html">Almacenamiento</a></p>
</li>
<li>
<p><a href="/practicas/auditoria.html">Auditoría</a></p>
</li>
<li>
<p><a href="/practicas/movdatos.html">Movimiento de datos</a></p>
</li>
<li>
<p><a href="/practicas/copias-seg-y-rest.html">Copias de Seguridad y Restauración</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="categorías" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">ASO</title>
    <id>https://github.com/oscarlucas22/category/ASO/</id>
    <link href="https://github.com/oscarlucas22/category/ASO/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="aso"> ASO</h1>
<ul>
<li>
<p><a href="/practicas/makefile.html">Compilación de un programa en C utilizando un Makefile</a></p>
</li>
<li>
<p><a href="/practicas/migracionrocky.html">Migración de CentOS Stream 8 a Rocky Linux</a></p>
</li>
<li>
<p><a href="/practicas/logs.html">Recolección centralizada de logs de sistema, mediante journald.</a></p>
</li>
<li>
<p><a href="/practicas/ldap.html">Instalación y configuración inicial de OpenLDAP</a></p>
</li>
<li>
<p><a href="/practicas/ldap-csv.html">Poblar un directorio LDAP desde un fichero CSV</a></p>
</li>
<li>
<p><a href="/practicas/ldaps.html">LDAPs</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="categorías" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">SAD</title>
    <id>https://github.com/oscarlucas22/category/SAD/</id>
    <link href="https://github.com/oscarlucas22/category/SAD/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sad"> SAD</h1>
<ul>
<li>
<p><a href="https://www.dropbox.com/s/84gl6ea0ls0xksy/Plantilla%20Trabajo%20Grupal%201.pdf?dl=0" target="_blank" rel="noopener noreferrer">Herramientas de Seguridad<i>Content not supported</i></a></p>
</li>
<li>
<p><a href="https://www.dropbox.com/s/th00q6nun0ekmam/Plan%20de%20Seguridad%20y%20de%20Contingencia%28Mar%C3%ADa-Iv%C3%A1n-%C3%93scar%29.pdf?dl=0" target="_blank" rel="noopener noreferrer">Plan de Seguridad y de Contingencia<i>Content not supported</i></a></p>
</li>
<li>
<p><a href="/practicas/criptografia1.html">Criptografía I: Cifrado asímetrico</a></p>
</li>
<li>
<p><a href="/practicas/criptografia2.html">Criptografía II: Integridad, firmas y autenticación</a></p>
</li>
<li>
<p><a href="/practicas/criptografia3.html">Criptografía III. Certificados Digitales. HTTPS</a></p>
</li>
<li>
<p><a href="/practicas/vpn.html">VPN</a></p>
</li>
<li>
<p><a href="/practicas/cortafuegoI.html">Cortafuegos I: De nodo con iptables</a></p>
</li>
<li>
<p><a href="/practicas/cortafuegoII.html">Cortafuegos II: Perimetral con nftables</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="categorías" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">SRI</title>
    <id>https://github.com/oscarlucas22/category/SRI/</id>
    <link href="https://github.com/oscarlucas22/category/SRI/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sri"> SRI</h1>
<ul>
<li>
<p><a href="/practicas/openstack.html">Práctica: Escenario en OpenStack</a></p>
</li>
<li>
<p><a href="/practicas/correos.html">Instalación y configuración de un servidor de correos en el VPS</a></p>
</li>
<li>
<p><a href="/practicas/kubernetes.html">Práctica: Kubernetes</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="categorías" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Servidores y Clientes de Base de Datos</title>
    <id>https://github.com/oscarlucas22/practicas/BD/</id>
    <link href="https://github.com/oscarlucas22/practicas/BD/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="servidores-y-clientes-de-base-de-datos"> Servidores y Clientes de Base de Datos</h1>
<ul>
<li>
<p><a href="./mariadb.html">MariaDB</a></p>
</li>
<li>
<p><a href="./postgresql.html">PostgreSQL</a></p>
</li>
<li>
<p><a href="./oracle.html">Oracle</a></p>
</li>
<li>
<p><a href="./mongo.html">MongoDB</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Criptografía I: Cifrado asímetrico</title>
    <id>https://github.com/oscarlucas22/practicas/criptografia1/</id>
    <link href="https://github.com/oscarlucas22/practicas/criptografia1/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="criptografia-i-cifrado-asimetrico"> Criptografía I: Cifrado asímetrico</h1>
<h3 id="tarea-1-generacion-de-claves"> Tarea 1: Generación de claves</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Genera un par de claves (pública y privada). ¿En que directorio se guarda las claves de un usuario?</strong></p>
<p>Las claves las generamos con el siguiente comando:</p>
<div><pre><code>gpg --gen-key
</code></pre>
</div><p>Y se guardan en el directorio <code>/home/usuario/.gnupg/</code></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Lista las claves públicas que tienes en tu almacén de claves. Explica los distintos datos que nos muestra. ¿Cómo deberías haber generado las claves para indicar, por ejemplo, que tenga un 1 mes de validez?</strong></p>
<p>Listo las claves publicas</p>
<p><img src="./../images/SAD/cripto I/1-2.png" alt="image"></p>
<p>Para hacer que tenga un mes de validacion haremos lo siguiente:</p>
<p><img src="./../images/SAD/cripto I/1-2.1.png" alt="image"></p>
<p>Para poner un mes de validacion escribiremos cuando nos lo pida &quot;1M&quot; de 1 mes</p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Lista las claves privadas de tu almacén de claves.</strong></p>
<p>Listo claves privadas</p>
<p><img src="./../images/SAD/cripto I/1-3.png" alt="image"></p>
<h3 id="tarea-2-importar-exportar-clave-publica"> Tarea 2: Importar / exportar clave pública</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Exporta tu clave pública en formato ASCII y guardalo en un archivo nombre_apellido.asc y envíalo al compañero con el que vas a hacer esta práctica.</strong></p>
<p>Exporto la clave con el siguiente comando:</p>
<div><pre><code>gpg --export -a &quot;oscar lucas leo&quot; &gt; oscar_lucas.asc
</code></pre>
</div><p>Y le envio a Angel el fichero oscar_lucas.asc</p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Importa las claves públicas recibidas de vuestro compañero.</strong></p>
<p>Importo la clave que me ha mandado Angel</p>
<p><img src="./../images/SAD/cripto I/2-2.png" alt="image"></p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Comprueba que las claves se han incluido correctamente en vuestro keyring.</strong>
<img src="./../images/SAD/cripto I/2-3.png" alt="image"></p>
<h3 id="tarea-3-cifrado-asimetrico-con-claves-publicas"> Tarea 3: Cifrado asimétrico con claves públicas</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Cifraremos un archivo cualquiera y lo remitiremos por email a uno de nuestros compañeros que nos proporcionó su clave pública.</strong></p>
<p><img src="./../images/SAD/cripto I/3-1.png" alt="image"></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Nuestro compañero, a su vez, nos remitirá un archivo cifrado para que nosotros lo descifremos.</strong></p>
<p>Le envio el archivo cifrado_olucas que he cifrado antes</p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Tanto nosotros como nuestro compañero comprobaremos que hemos podido descifrar los mensajes recibidos respectivamente.</strong></p>
<p><img src="./../images/SAD/cripto I/3-3.png" alt="image"></p>
<p><font color="#00ff00"><strong>4.</strong></font> <strong>Por último, enviaremos el documento cifrado a alguien que no estaba en la lista de destinatarios y comprobaremos que este usuario no podrá descifrar este archivo.</strong></p>
<p>El archivo se lo he pasado a Paco y como podemos ver el no tiene acceso para poder descifrarlo</p>
<p><img src="./../images/SAD/cripto I/3-4.jpeg" alt="image"></p>
<p><font color="#00ff00"><strong>5.</strong></font> <strong>Para terminar, indica los comandos necesarios para borrar las claves públicas y privadas que posees.</strong></p>
<p>Comando para borrar clave publica:</p>
<div><pre><code>gpg --delete-key &quot;Nombre de Usuario&quot;
</code></pre>
</div><p>Comando para borrar clave privada:</p>
<div><pre><code>gpg --delete-secret-key &quot;Nombre de Usuario&quot;
</code></pre>
</div><h3 id="tarea-4-exportar-clave-a-un-servidor-publico-de-claves-pgp"> Tarea 4: Exportar clave a un servidor público de claves PGP</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Genera la clave de revocación de tu clave pública para utilizarla en caso de que haya problemas.</strong></p>
<p><img src="./../images/SAD/cripto I/4-1.png" alt="image"></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Exporta tu clave pública al servidor pgp.rediris.es</strong></p>
<p>Tanto Angel como yo hemos probado exportar la clave en &quot;pgp.rediris.es&quot; pero no iba y hemos decido hacerla en &quot;keyserver.ubuntu.com&quot;</p>
<p><img src="./../images/SAD/cripto I/4-2.png" alt="image"></p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Borra la clave pública de alguno de tus compañeros de clase e impórtala ahora del servidor público de rediris.</strong></p>
<p>Borro la clave de Angel</p>
<p><img src="./../images/SAD/cripto I/4-3.png" alt="image"></p>
<p>Y la vuelvo a importar ahora a traves del servidor publico.</p>
<p><img src="./../images/SAD/cripto I/4-3.1.png" alt="image"></p>
<h3 id="tarea-5-cifrado-asimetrico-con-openssl"> Tarea 5: Cifrado asimétrico con openssl</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Genera un par de claves (pública y privada).</strong></p>
<p><img src="./../images/SAD/cripto I/5-1.png" alt="image"></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Envía tu clave pública a un compañero.</strong></p>
<p>Guardo la clave en un archivo con el siguiente comando:</p>
<div><pre><code>sudo openssl rsa -in key.pem -pubout -out key.publica.pem
</code></pre>
</div><p><img src="./../images/SAD/cripto I/5-2.png" alt="image"></p>
<p>Y el fichero &quot;key.publica.pem&quot; se la envio a Angel</p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Utilizando la clave pública cifra un fichero de texto y envíalo a tu compañero.</strong></p>
<p>Cifro un archivo de texto con el siguiente comando:</p>
<div><pre><code>openssl rsautl -encrypt -in cifrado_olucas -out cifrado_olucas.enc -inkey ~/Descargas/publicaopenssl.pem -pubin
</code></pre>
</div><p><img src="./../images/SAD/cripto I/5-3.png" alt="image"></p>
<p>Y se la envio a Angel</p>
<p><font color="#00ff00"><strong>4.</strong></font> <strong>Tu compañero te ha mandado un fichero cifrado, muestra el proceso para el descifrado.</strong></p>
<p>Angel me ha mandado su archivo llamado &quot;CifradoOSSasp.enc&quot; y lo desencripto con el siguiente comando:</p>
<div><pre><code>sudo openssl rsautl -decrypt -in Descargas/CifradoOSSasp.enc -out cifrado.txt -inkey key.pem
</code></pre>
</div><p>Y despues ejecutare el comando &quot;cat&quot; para ver el interior del fichero.</p>
<p><img src="./../images/SAD/cripto I/5-4.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Criptografía II: Integridad, firmas y autenticación</title>
    <id>https://github.com/oscarlucas22/practicas/criptografia2/</id>
    <link href="https://github.com/oscarlucas22/practicas/criptografia2/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="criptografia-ii-integridad-firmas-y-autenticacion"> Criptografía II: Integridad, firmas y autenticación</h1>
<h3 id="tarea-1-firmas-electronicas"> Tarea 1: Firmas electrónicas</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Manda un documento y la firma electrónica del mismo a un compañero. Verifica la firma que tu has recibido.</strong></p>
<p>He creado un documento y lo he firmado con el comando:</p>
<div><pre><code>gpg --detach-sign &quot;nombre-del-fichero&quot;
</code></pre>
</div><p>Y verifico la firma con el siguiente comando:</p>
<div><pre><code>gpg --verify &quot;nombre-del-fichero-del-compañero&quot; &quot;nombre-del-documento-firmado-del-compañero&quot;
</code></pre>
</div><p><font color="#00ff00"><strong>2.</strong></font> <strong>¿Qué significa el mensaje que aparece en el momento de verificar la firma?</strong></p>
<p><img src="./../images/SAD/cripto II/2-1.png" alt="image"></p>
<p>El mensaje que aparece es que no puedo acceder a el ya que no he firmado yo el mismo documento</p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Vamos a crear un anillo de confianza entre los miembros de nuestra clase, para ello.</strong></p>
<ul>
<li>
<p>Tu clave pública debe estar en un servidor de claves</p>
</li>
<li>
<p>Escribe tu fingerprint en un papel y dárselo a tu compañero, para que puede descargarse tu clave pública.</p>
</li>
<li>
<p>Te debes bajar al menos tres claves públicas de compañeros. Firma estas claves.</p>
</li>
<li>
<p>Tu te debes asegurar que tu clave pública es firmada por al menos tres compañeros de la clase.</p>
</li>
<li>
<p>Una vez que firmes una clave se la tendrás que devolver a su dueño, para que otra persona se la firme.</p>
</li>
<li>
<p>Cuando tengas las tres firmas sube la clave al servidor de claves y rellena tus datos en la tabla Claves públicas PGP 2020-2021</p>
</li>
<li>
<p>Asegurate que te vuelves a bajar las claves públicas de tus compañeros que tengan las tres firmas.</p>
</li>
</ul>
<p><font color="#00ff00"><strong>4.</strong></font> <strong>Muestra las firmas que tiene tu clave pública.</strong></p>
<p><img src="./../images/SAD/cripto II/4-1.png" alt="image"></p>
<p><font color="#00ff00"><strong>5.</strong></font> <strong>Comprueba que ya puedes verificar sin “problemas” una firma recibida por una persona en la que confías.</strong></p>
<p><img src="./../images/SAD/cripto II/5-1.png" alt="image"></p>
<p><font color="#00ff00"><strong>6.</strong></font> <strong>Comprueba que puedes verificar con confianza una firma de una persona en las que no confías, pero sin embargo si confía otra persona en la que tu tienes confianza total.</strong></p>
<h3 id="tarea-2-correo-seguro-con-evolution-thunderbird"> Tarea 2: Correo seguro con evolution/thunderbird</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Configura el cliente de correo evolution con tu cuenta de correo habitual</strong></p>
<p>En mi caso he usado el cliente de correos thuderbird, para configurar este he tenido que introducir un nombre de usuario y mi correo electronico con mi correspondiente contraseña. Una vez que ya estan vinculados los dos a traves de un mensaje que me ha llegado a mi telefono movil para poder identificar de que era yo.</p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Añade a la cuenta las opciones de seguridad para poder enviar correos firmados con tu clave privada o cifrar los mensajes para otros destinatarios.</strong></p>
<p>Para confirurar esta parte, nos iremos a donde pone &quot;Edit&quot; y nos iremos a la parte donde pone &quot;End-To-End Encryption&quot; y ahi añadire mi clave privada dandole a la opcion de &quot;Add Key&quot;:</p>
<p><img src="./../images/SAD/cripto II/2-2.png" alt="image"></p>
<p>Luego para a la hora de enviar un mensaje le daremos a la opcion de &quot;Encrypt&quot; que nos aparece arriba para insertar la clave publica del destinatario para que el mensaje enviado este encriptado y solo lo prodra desencriptar el destinatario ya que el tiene su clave privada:</p>
<p><img src="./../images/SAD/cripto II/2.1-2.png" alt="image"></p>
<p>Pasos a seguir:</p>
<ul>
<li>Introducimos el correo del destinatario:</li>
</ul>
<p><img src="./../images/SAD/cripto II/2.2-2.png" alt="image"></p>
<ul>
<li>Importamos la clave publica del destinatario cuando le demos al boton de &quot;Resolve&quot; que aparece abajo:</li>
</ul>
<p><img src="./../images/SAD/cripto II/2.3-2.png" alt="image"></p>
<ul>
<li>Le damos a aceptar para verificar la clave que hemos importado:</li>
</ul>
<p><img src="./../images/SAD/cripto II/2.4-2.png" alt="image"></p>
<ul>
<li>Cerraremos la centana que nos aparece cuando terminamos dandole al boton &quot;Close&quot;:</li>
</ul>
<p><img src="./../images/SAD/cripto II/2.5-2.png" alt="image"></p>
<ul>
<li>Ya habremos finalizado solo hara falta enviar el mensaje dandole al boton &quot;Send&quot; y le daremos a enviar:</li>
</ul>
<p><img src="./../images/SAD/cripto II/2.6-2.png" alt="image"></p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Envía y recibe varios mensajes con tus compañeros y comprueba el funcionamiento adecuado de GPG.</strong></p>
<p>Le envio un correo a Angel desde thuderbird:</p>
<p>Como vemos en la siguiente imagen accedemos al correo a traves de thuderbird y veremos que podemos ver el interior del archivo:</p>
<p><img src="./../images/SAD/cripto II/3-2.png" alt="image"></p>
<p>Como vemos en la siguiente imagen accedemos a traves de Gmail y veremos los fichero que estan encriptados:</p>
<p><img src="./../images/SAD/cripto II/3.1-2.png" alt="image"></p>
<p>Recibo un envio a Angel:</p>
<p>Como vemos en la siguiente imagen accedemos a traves de thuderbird y veremos que podemos ver el interior del archivo:</p>
<p><img src="./../images/SAD/cripto II/3.2-2.png" alt="image"></p>
<p>Como vemos en la siguiente imagen accedemos a traves de Gmail y veremos los ficheros que estan encriptados:</p>
<p><img src="./../images/SAD/cripto II/3.3-2.png" alt="image"></p>
<h3 id="tarea-3-integridad-de-ficheros"> Tarea 3: Integridad de ficheros</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Para validar el contenido de la imagen CD, solo asegúrese de usar la herramienta apropiada para sumas de verificación. Para cada versión publicada existen archivos de suma de comprobación con algoritmos fuertes (SHA256 y SHA512); debería usar las herramientas sha256sum o sha512sum para trabajar con ellos.</strong></p>
<p>En primer lugar me he instalado las imagenes CD del link que habia en la pagina.</p>
<p><img src="./../images/SAD/cripto II/1-3.png" alt="image"></p>
<p>Primero obtendremos la clave publica de Debian, con la que verificaremos la firma realizada con su clave privada:</p>
<div><pre><code>gpg --keyserver keyring.debian.org --recv-keys 6294BE9B
</code></pre>
</div><p><img src="./../images/SAD/cripto II/1.1-3.png" alt="image"></p>
<p>Veremos que contienen los ficheros:</p>
<p><img src="./../images/SAD/cripto II/1.2-3.png" alt="image"></p>
<p>De las cuatro lineas que nos aparecen nos interesa la primera ya que esa es la que voy a comprobar.
Para verificar el hash tendremos que hacer uso de las utilidades <code>sha256sum</code> y <code>sha512sum</code> que reciben un fichero y calculan su hash:</p>
<p><img src="./../images/SAD/cripto II/1.3-3.png" alt="image"></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Verifica que el contenido del hash que has utilizado no ha sido manipulado, usando la firma digital que encontrarás en el repositorio. Puedes encontrar una guía para realizarlo en este artículo: How to verify an authenticity of downloaded Debian ISO images.</strong></p>
<p>En este caso utilizaremos en el comando la opcion '-c' que ira recorriendo de forma automatica el resultado en el fichero origen:</p>
<p><img src="./../images/SAD/cripto II/2-3.png" alt="image"></p>
<p>Esto que acababo de hacer no te da la garantia de que los ficheros no hayan sido manipulados, ya que el suplantador podria haber modificado tambien el fichero en el que se muestra el resumen de los hash.
De manera que tendremos que verificar la firma con el uso de la opcion '--verify':</p>
<p><img src="./../images/SAD/cripto II/2.1-3.png" alt="image"></p>
<h3 id="tarea-4-integridad-y-autenticidad-apt-secure"> Tarea 4: Integridad y autenticidad (apt secure)</h3>
<p><strong>Busca información sobre apt secure y responde las siguientes preguntas:</strong></p>
<ul>
<li>1.¿Qué software utiliza apt secure para realizar la criptografía asimétrica?</li>
</ul>
<p>La herramienta que utiliza apt-secure para firmar y comprobar sus firmas es GPG</p>
<ul>
<li>2.¿Para que sirve el comando apt-key? ¿Qué muestra el comando apt-key list?</li>
</ul>
<p>El comando apt-key sirve para permitir gestionar la lista de claves que utiliza 'apt' para autenticar paquetes.</p>
<p>El comando apt-key-list nos mostrara todas las claves consideradas de confianza para 'apt'</p>
<ul>
<li>3.En que fichero se guarda el anillo de claves que guarda la herramienta apt-key?</li>
</ul>
<p>El anillo de claves que gestiona apt-key se encuentra en '/etc/apt/trusted.gpg' de forma que las nuevas claves se iran añadiendo a dicho fichero.</p>
<ul>
<li>4.y 5.¿Qué contiene el archivo Release de un repositorio de paquetes?. ¿Y el archivo Release.gpg? Explica el proceso por el cual el sistema nos asegura que los ficheros que estamos descargando son legítimos.</li>
</ul>
<p>El archivo Release contiene una lista de los archivos Packages (incluyendo Packages.gz y Packages.xz) junto con sus hash MD5, SHA1, SHA256. Gracias a esto podremos comprobar que los ficheros Packages no han sido manipulados llevando a acabo una comprobacion del hash.</p>
<p>Por razones obvias, de nada servira este metodo si el posible impostor lograse modificar tambien el fichero Release, haciendonos creer que dado que los hash coincidan, no ha habido manipulacion de los mismos, de manera uqe para ello se llava a cabo un proceso de firmado del hash del fichero Release.</p>
<p>Cuando llevamos a cabo un apt update, se descargan los ficheros Packages.gz, Release y Release.gpg, ficheros que son necesarios para la hora de la descarga del paquete, puesto que lo primero que se hace es comprobar que el hash del paquete .deb coinciden con el indicado en el fichero Packages.gz, comprobando a su vez que coincide con el fichero Release, comprobando que dicho fichero se encuentra contenido en el fichero Release.gpg.</p>
<ul>
<li>6.añade de forma correcta el repositorio de virtualbox añadiendo la clave pública de virtualbox como se indica en la documentación.</li>
</ul>
<p>En primer lugar lo que haremos es tratar de instalar VirtualBox, para asi demostrar que no se encuentran en los repositorios oficiales de Debian:</p>
<p><img src="./../images/SAD/cripto II/6-4.png" alt="image"></p>
<p>Para poder instalarlo necesitamos añadir los repositorios de VirtualBox al fichero en el que se encuentran reflejados los repositorios disponibles (/etc/apt/sources.list):</p>
<div><pre><code>echo &quot;deb https://download.virtualbox.org/virtualbox/debian buster contrib&quot; &gt;&gt; /etc/apt/sources.list
</code></pre>
</div><p><img src="./../images/SAD/cripto II/6.1-4.png" alt="image"></p>
<p>Tras hacer esto necesitamos añadir la clave publica de VirtualBox a nuestro anillo de claves de apt-key, ya que de lo contrario no podria verificar la firma del fichero Release que descargara de dicho repositorio:</p>
<p><img src="./../images/SAD/cripto II/6.2-4.png" alt="image"></p>
<p><img src="./../images/SAD/cripto II/6.3-4.png" alt="image"></p>
<p>Y una vez finalizado esto ya podremos instalar VirtualBox.</p>
<h3 id="tarea-5-autentificacion-ejemplo-ssh"> Tarea 5: Autentificación: ejemplo SSH</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Explica los pasos que se producen entre el cliente y el servidor para que el protocolo cifre la información que se transmite? ¿Para qué se utiliza la criptografía simétrica? ¿Y la asimétrica?</strong></p>
<p>Cuando un cliente se intenta conectar al servidor por medio de tcp, el servidor presenta los protocolos de cicfrado y las respectivas versiones que soporta. Si el cliente tiene un par similar de protocolo y version, se alcanza un acuerdo y se inicia la conexion con el protocolo aceptado. El cliente ha de autentificar al servidor, comprobando el host key que ha recibido, preguntando al usuario si confia en el mismo si es la primera vez que se conecta.</p>
<p>Una vez que esto se establece, las dos partes usan lo que se conoce como Algoritmo de Intercambio de Claves Diffie-Hellman para crear una clave simetrica. Este algoritmo permite que tanto el cliente como el servidor lleguen a una clave de cifrado compartida que se utilizara en adelante para cifrar toda la sesión de comunicacion.</p>
<p>Una vez establecido el cifrado simétrico para asegurar las comunicaciones entre el servidor y el cliente, el cliente debe autenticarse para permitir el acceso.</p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Explica los dos métodos principales de autentificación: por contraseña y utilizando un par de claves públicas y privadas.</strong></p>
<p>Por contraseña: Se le pide la contraseña al usuario asociada al usuario al que esta tratando de conectarse. Estas credenciales pasan a travex del tunel cifrado simetricamente con seguridad.</p>
<p>Par de claves: El usuario tiene su clave publica almacenada en el servidor de manera que a la hora de realizar la conexion, el usuario se presenta y le indica al servidor que es el dueño de dica clave. El servidor desconfia, por lo que le plantea un desafio que consiste en encriptar un mensaje con dicha clave publica, enviandoselo encriptado al usuario que trata de acceder el cual debe descrifrarlo haciendo uso de la clave privada asociada a dicha clave publica.</p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>En el cliente para que sirve el contenido que se guarda en el fichero ~/.ssh/know_hosts?</strong></p>
<p>El contenido que se guarda en el fichero sirve si en el caso de que al saltar el primer mensaje de la conexion la respuesta sea afirmativa es decir, que confia en el otro extremo (servidor) se añadira el host key al fichero '~/.ssh/know_hosts', de manera que para la siguiente ocasion no se le preguntara al cliente si confia, sino que mirara en dicho fichero para comprobar su previa existencia.</p>
<p><font color="#00ff00"><strong>4.</strong></font> <strong>¿Qué significa este mensaje que aparece la primera vez que nos conectamos a un servidor?</strong></p>
<p>Cuando el cliente lleva a cabo la conexion tcp con el servidor, este debe ser autenticado por el cliente. Si es la primera vez que se llava a cabo dicha conexion, se mostrara el mensaje que se menciona.</p>
<p><font color="#00ff00"><strong>5.</strong></font> <strong>En ocasiones cuando estamos trabajando en el cloud, y reutilizamos una ip flotante nos aparece este mensaje:</strong></p>
<p>Para solucionar este problema tendriamos que borrar la linea correspondiente a dicho host en el fichero ~/.ssh/known_hosts. Normalmente, en el propio mensaje de advertencia te dice explicitamente el comando a ejecutar para borrar dicha linea.</p>
<p><font color="#00ff00"><strong>6.</strong></font> <strong>¿Qué guardamos y para qué sirve el fichero en el servidor ~/.ssh/authorized_keys?</strong></p>
<p>En el guardaremos nuestra clave publica para asi poder acceder al servidor por medio de nuestra clave privada</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Despliegue de aplicaciones python</title>
    <id>https://github.com/oscarlucas22/practicas/django/</id>
    <link href="https://github.com/oscarlucas22/practicas/django/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="despliegue-de-aplicaciones-python"> Despliegue de aplicaciones python</h1>
<p><a href="https://fp.josedomingo.org/iaw2223/4_python/practica.html" target="_blank" rel="noopener noreferrer">Página del ejercicio.<i>Content not supported</i></a></p>
<h2 id="tarea-1-entorno-de-desarrollo"> Tarea 1: Entorno de desarrollo</h2>
<p><strong>Vamos a desplegar la aplicación del tutorial de django. Como entorno de desarrollo tienes dos opciones:</strong></p>
<p><strong>Que tu entorno de desarrollo se la máquina bravo de tu entorno de desarrollo. Opción que dará más puntos.</strong> <em><strong>Opción elegida</strong></em></p>
<p><strong>Que tu entorno de desarrollo sea una máquina de openstack con el sistema operativo que quieras. Opción que dará menos puntos.</strong></p>
<p><strong>Vamos a configurar tu equipo como entorno de desarrollo para trabajar con la aplicación, para ello:</strong></p>
<ul>
<li><strong>Realiza un fork del repositorio de GitHub: <a href="https://github.com/josedom24/django_tutorial" target="_blank" rel="noopener noreferrer">https://github.com/josedom24/django_tutorial<i>Content not supported</i></a></strong></li>
</ul>
<p>Para la clonación tenemos a nuestra disposición 3 protocolos diferentes de los que podemos hacer uso. En mi caso voy a utilizar el protocolo HTTPS.</p>
<p><strong>Nota</strong>: Si no tenemos instalado el comando <code>git</code> lo instalamos:</p>
<div><pre><code>sudo dnf install git
</code></pre>
</div><p>Cuando hayamos obtenido la URI de descarga, se la pasaremos a <code>git clone</code>:</p>
<div><pre><code>git clone &lt;&lt;URL de descarga&gt;&gt;
</code></pre>
</div><p>Y una vez hecho esto el repositorio de nombre django_tutorial ha sido correctamente clonado en nuestra máquina local y podremos empezar a hacer uso del mismo.</p>
<ul>
<li><strong>Crea un entorno virtual de python3 e instala las dependencias necesarias para que funcione el proyecto.</strong></li>
</ul>
<p>Instalaremos los paquetes necesarios para que la aplicación funcione. Para la correspondiente creación de un entorno virtual, debemos instalar previamente el paquete necesario (python3-venv), ejecutando para ello el comando:</p>
<div><pre><code>sudo dnf install python3-venv
</code></pre>
</div><p>Podemos crear este entorno en una carpeta a parte. Ejecutaremos el entorno con el siguiente comando:</p>
<div><pre><code>python3 -m venv &lt;&lt;Nombre del entorno&gt;&gt;
</code></pre>
</div><p>Una vez creado, tendremos que iniciarlo haciendo uso del comando <code>source</code> con el binario activate que se encuentra contenido en el directorio bin/:</p>
<div><pre><code>source &lt;&lt;Nombre del entorno&gt;&gt;/bin/activate
</code></pre>
</div><p>Y hecho esto nuestro entorno habrá sido habilitado.</p>
<ul>
<li><strong>Comprueba que vamos a trabajar con una base de datos sqlite. ¿Qué fichero tienes que consultar? ¿Cómo se llama la base de datos que vamos a crear?</strong></li>
</ul>
<p>Estos paquetes lo entontraremos en el fichero <code>requirements.txt</code> que se encuentra entre los ficheros que hemos clonado del GitHub</p>
<p><img src="./../images/IAW/django/1-1_django.png" alt="image"></p>
<p>E instalaremos los paquetes que se encuentan en el, con el siguiente comando:</p>
<div><pre><code>pip install -r requirements.txt
</code></pre>
</div><p>Para demostrarlo, vamos a leer el contenido del fichero <code>settings.py</code> existente en el subdirectorio <code>django_tutorial/</code> previamente mencionado, para así visualizar la sección referente al uso de la base de datos, haciendo para ello uso del comando:</p>
<div><pre><code>cat django_tutorial/settings.py
</code></pre>
</div><p>Dentro del mismo, encontraremos una sección de nombre DATABASES, que por defecto tendrá la siguiente forma:</p>
<p><img src="./../images/IAW/django/1-2_django.png" alt="image"></p>
<p>Para poder acceder desde cualquier sitio encontraremos en este fichero la linea <code>ALLOWED_HOSTS =</code> y la editaremos dejandola de la siguiente manera:</p>
<div><pre><code>ALLOWED_HOSTS = ['*']
</code></pre>
</div><p><strong>Nota</strong>: El <code>*</code> es para que se conecte a cualquier dirección, pero tambien podremos poner una Ip en concreto.</p>
<p>Como se puede apreciar, la base de datos es de tipo sqlite3, un tipo de base de datos muy pequeña, tan pequeña que se encuentra contenida en un fichero, que todavía no se encuentra generado. Para generarlo, tendremos que aplicar las migraciones:</p>
<div><pre><code>python3 manage.py migrate
</code></pre>
</div><p><img src="./../images/IAW/django/1-3_django.png" alt="image"></p>
<p>Para verificar que el fichero que contiene la base de datos sqlite3 ha sido correctamente generado, listaremos el contenido del directorio:</p>
<p><img src="./../images/IAW/django/1-4_django.png" alt="image"></p>
<p>Efectivamente, un fichero de nombre <code>db.sqlite3</code> ha sido generado, que contendrá todas las tablas necesarias.</p>
<ul>
<li><strong>Crea la base de datos. A partir del modelo de datos se crean las tablas de la base de datos.</strong></li>
</ul>
<hr>
<div><pre><code>sudo apt-get install default-mysql-server
</code></pre>
</div><hr>
<div><pre><code>sudo mysql -u root -p
</code></pre>
</div><hr>
<div><pre><code>create database db_django;
create user 'user_django'@'localhost' identified by 'root';
grant all privileges on db_django.* to 'user_django'@'localhost';
</code></pre>
</div><ul>
<li><strong>Crea un usuario administrador.</strong></li>
</ul>
<p>La aplicación se encuentra ya instalada en su totalidad, de manera que vamos a proceder a crear un usuario administrador de dicho proyecto, que tendrá privilegios suficientes para acceder a la zona de administración, ejecutando para ello el comando:</p>
<div><pre><code>python3 manage.py createsuperuser
</code></pre>
</div><p><img src="./../images/IAW/django/1-5_django.png" alt="image"></p>
<ul>
<li><strong>Ejecuta el servidor web de desarrollo y entra en la zona de administración (/admin) para comprobar que los datos se han añadido correctamente.</strong></li>
</ul>
<p>Se nos ha solicitado un nombre de usuario para el mismo, un correo electrónico y una contraseña, así que una vez creado, vamos a proceder a arrancar el servidor web ligero que nos proporciona Django:</p>
<div><pre><code>python manage.py runserver 0.0.0.0:8000
</code></pre>
</div><p>Y una vez hecho esto ya prodremos acceder al servidor web, poniendo en el navegador <code>localhost:8000/admin</code> para acceder a la zona de administración.</p>
<p><img src="./../images/IAW/django/1-6_django.png" alt="image"></p>
<p>Una vez hayamos accedido a la zona de administración, se nos solicitarán los credenciales del usuario administrador que acabamos de generar, así que tras introducirlos, pulsaremos en <strong>Log in</strong>.</p>
<p><img src="./../images/IAW/django/1-7_django.png" alt="image"></p>
<p>Y como podemos comprobar el acceso a la zona de administración ha funcionado correctamente.</p>
<ul>
<li><strong>Crea dos preguntas, con posibles respuestas.</strong></li>
</ul>
<p>Para comprobar el funcionamiento de esta última aplicación, vamos a añadir dos nuevas preguntas, pulsando para ello en <strong>+ Add</strong> en el apartado <strong>Questions</strong> de la sección <strong>polls</strong></p>
<p>En mi caso, he creado la pregunta “¿Cuál es tu color favorito?” con 4 posibles respuestas, indicando a su vez la fecha y hora de inicio de la encuesta. Cuando hayamos finalizado, pulsaremos en <strong>Save and add another</strong> para así añadir una segunda encuesta de prueba la cual dice &quot;¿Qué marca de portátil prefieres?&quot; con 3 posibles respuestas. Por último, pulsaremos en <strong>SAVE</strong> para añadirla y volver a la zona de administración::</p>
<p><img src="./../images/IAW/django/1-8_django.png" alt="image"></p>
<p><img src="./../images/IAW/django/1-9_django.png" alt="image"></p>
<p><img src="./../images/IAW/django/1-10_django.png" alt="image"></p>
<ul>
<li><strong>Comprueba en el navegador que la aplicación está funcionando, accede a la url /polls.</strong></li>
</ul>
<p>Como se puede apreciar, las dos preguntas han sido correctamente generadas, así que accederemos tras ello a la ruta <strong>/polls</strong> para así hacer uso de dicha aplicación, en la que se mostrarán las encuestas existentes y nos permitirá votar entre las diferentes posibilidades:</p>
<p><img src="./../images/IAW/django/1-11_django.png" alt="image"></p>
<p>Efectivamente, ambas encuestas han sido mostradas, de manera que accederemos a la primera de ellas para verificar que todo funciona como debería:</p>
<p><img src="./../images/IAW/django/1-12_django.png" alt="image"></p>
<p>Y haremos uso de la votación:</p>
<p><img src="./../images/IAW/django/1-13_django.png" alt="image"></p>
<p>Efectivamente, el voto ha sido correctamente registrado y los resultados actuales, mostrados.</p>
<p>Vamos a comprobar qué ha ocurrido de una forma más interna, volviendo a la terminal y utilizando un cliente sqlite3 que tenía instado con anterioridad, para así hacer uso de la base de datos existente. Pero antes debemos de instalar <code>sqlite</code>:</p>
<div><pre><code>dnf -y install sqlite
</code></pre>
</div><p><img src="./../images/IAW/django/1-14_django.png" alt="image"></p>
<p>Y despues ejecutaremos el comando para ejecutar la base de datos:</p>
<div><pre><code>sqlite3 db.sqlite3
</code></pre>
</div><p><img src="./../images/IAW/django/1-15_django.png" alt="image"></p>
<p>Una vez dentro del cliente con la correspondiente base de datos abierta, vamos a ejecutar la instrucción necesaria para listar las tablas existentes en la misma:</p>
<p><img src="./../images/IAW/django/1-16_django.png" alt="image"></p>
<p>En la salida de la instrucción se han mostrado todas las tablas resultantes de haber aplicado las correspondientes migraciones, siendo <strong>polls_question</strong> aquella en la que se almacenarán las dos preguntas que hemos creado, así como <strong>polls_choice</strong> aquella en la que se almacenarán las posibles respuestas y los votos realizados para cada una de ellas. Vamos a proceder a comprobar el contenido de ambas, ejecutando para ello las instrucciones:</p>
<p><img src="./../images/IAW/django/1-17_django.png" alt="image"></p>
<ul>
<li>
<p><strong>Configura el servidor web apache2 con el módulo wsgi para servir la página web. Si utilizas como entorno de desarrollo la máquina bravo, se accederá con el nombre python.tunombre.gonzalonazareno.org. Si tu entorno de desarrollo es una máquina de openstack, elige el nombre con el que acceder y entrega la dirección IP de la máquina.</strong></p>
</li>
<li>
<p>Primero reuniremos los ficheros estaticos pero antes editamos este fichero con el siguiente contenido:</p>
</li>
</ul>
<hr>
<div><pre><code>nano /django_tutorial/settings.py
</code></pre>
</div><hr>
<div><pre><code>STATIC_ROOT = '/var/www/html/django_tutorial/static'
</code></pre>
</div><p>Y ahora si ejeutamos el comando para reunir los ficheros estaticos:</p>
<div><pre><code>python manage.py collectstatic
</code></pre>
</div><ul>
<li>Despues instalaremos el modulo wsgi para apache:</li>
</ul>
<hr>
<div><pre><code>dnf install mod_wsgi httpd
</code></pre>
</div><ul>
<li>Despues crearemos nuestro VirtualHost:</li>
</ul>
<hr>
<div><pre><code>&lt;VirtualHost *:80&gt;
    ServerName python.olucas.gonzalonazareno.org

    DocumentRoot /var/www/html/django_tutorial

    Alias /static/ /var/www/html/django_tutorial/static/

    WSGIDaemonProcess django_tutorial python-path=/var/www/html/django_tutorial:/var/www/html/django/lib/python3.9/site-packages
    WSGIProcessGroup django_tutorial
    WSGIScriptAlias / /var/www/html/django_tutorial/django_tutorial/wsgi.py

    &lt;Directory /var/www/html/django_tutorial/static&gt;
        Require all granted
    &lt;/Directory&gt;

    &lt;Directory /var/www/html/django_tutorial&gt;
        Require all granted
        Allow from all
    &lt;/Directory&gt;

    &lt;Directory /var/www/html/django_tutorial/django_tutorial&gt;
        &lt;Files wsgi.py&gt;
            Require all granted
        &lt;/Files&gt;
    &lt;/Directory&gt;

    ErrorLog /var/log/httpd/django_tutorial_error.log
    CustomLog /var/log/httpd/django_tutorial_access.log combined
&lt;/VirtualHost&gt;
</code></pre>
</div><ul>
<li>Despues de hacer esto habilitaremos el fichero</li>
</ul>
<hr>
<div><pre><code>ln -s /etc/httpd/site-enabled/ /etc/httpd/site-available/python.conf
</code></pre>
</div><ul>
<li>Editamos el fichero <code>/etc/hosts/</code> en nuestro local:</li>
</ul>
<hr>
<div><pre><code>172.22.201.40 python.olucass.com
</code></pre>
</div><p>Y por ultimo creamos una copia de seguridad de la base de datos con el siguiente comando:</p>
<div><pre><code>python manage.py dumpdata &gt; db.json
</code></pre>
</div><p>Y ya nos deberia de funcionar:</p>
<p><img src="./../images/IAW/django/1-18_django.png" alt="image"></p>
<p><img src="./../images/IAW/django/1-19_django.png" alt="image"></p>
<p>Y despues de hacer todo esto subiremos todo a nuestro repositorio de GitHub.</p>
<h2 id="tarea-2-entorno-de-produccion"> Tarea 2: Entorno de producción</h2>
<p><strong>Vamos a realizar el despliegue de nuestra aplicación en un entorno de producción, para ello vamos a utilizar nuestro VPS, sigue los siguientes pasos:</strong></p>
<ul>
<li><strong>Clona el repositorio en el VPS</strong></li>
</ul>
<hr>
<div><pre><code>git clone https://github.com/oscarlucas22/django_tutorial.git
</code></pre>
</div><ul>
<li><strong>Crea un entorno virtual e instala las dependencias de tu aplicación.</strong></li>
</ul>
<hr>
<div><pre><code>sudo apt-get install python-virtualenv virtualenv
python3 -m venv my_entorno
source my_entorno/bin/activate
pip install -r requirements.txt
</code></pre>
</div><ul>
<li><strong>Instala el módulo que permite que python trabaje con mysql:</strong></li>
</ul>
<hr>
<div><pre><code>apt install python3-dev default-libmysqlclient-dev build-essential
</code></pre>
</div><hr>
<div><pre><code>(my_entorno)$ pip install mysqlclient
</code></pre>
</div><ul>
<li><strong>Crea una base de datos y un usuario en mysql.</strong></li>
</ul>
<hr>
<div><pre><code>sudo apt-get install default-mysql-server
</code></pre>
</div><hr>
<div><pre><code>sudo mysql -u root -p
</code></pre>
</div><hr>
<div><pre><code>create database db_django;
create user 'user_django'@'localhost' identified by 'root';
grant all privileges on db_django.* to 'user_django'@'localhost';
</code></pre>
</div><ul>
<li><strong>Configura la aplicación para trabajar con mysql, para ello modifica la configuración de la base de datos en el archivo <code>settings.py</code>:</strong></li>
</ul>
<hr>
<div><pre><code>nano django_tutorial/settings.py
</code></pre>
</div><hr>
<div><pre><code>DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'db_django',
        'USER': 'user_django',
        'PASSWORD': 'root',
        'HOST': 'localhost',
        'PORT': '',
    }
}
</code></pre>
</div><ul>
<li><strong>Crea una copia de seguridad de la base de datos. Ten en cuenta que en el entorno de desarrollo vas a tener una base de datos sqlite, y en el entorno de producción una mariadb, por lo tanto es recomendable para hacer la copia de seguridad y recuperarla con los comandos: <code>python manage.py dumpdata</code> y <code>python manage.py loaddata</code>, para más información.</strong></li>
</ul>
<hr>
<div><pre><code>python3 manage.py migrate
python manage.py loaddata db.json
</code></pre>
</div><ul>
<li><strong>Configura el servidor de aplicaciones uwsgi, creando una unidad de systemd como hicimos en el taller2) y configura nginx como proxy inverso para servir la aplicación.</strong></li>
</ul>
<hr>
<div><pre><code>apt install libapache2-mod-wsgi-py3
</code></pre>
</div><hr>
<div><pre><code>sudo apt-get update
sudo apt-get upgrade
sudo apt-get install build-essential python
sudo apt-get install python-dev
sudo apt-get install python3-all-dev
sudo apt-get install uwsgi-plugin-python3
pip install uwsgi
</code></pre>
</div><p>Para servir nuestra aplicación python, vamos a crear un fichero nombre.ini el que guardara lo siguiente:</p>
<div><pre><code>[uwsgi]
http = :8080
chdir = /home/olucas/django_tutorial
wsgi-file = /home/olucas/django_tutorial/django_tutorial/wsgi.py
processes = 4
threads = 2
</code></pre>
</div><p>Una vez hecho esto, podríamos ejecutar la aplicación simplemente con el siguiente comando.</p>
<p><strong>Nota</strong>: Debemos de estar en la ruta donde se encuentra el fichero</p>
<div><pre><code>uwsgi ejemplo.ini
</code></pre>
</div><p>Para garantizar que nuestra aplicación esté funcionando continuamente y poder acceder a ella mediante un virtualhost en nginx, vamos a crear una unidad de systemd para manejar ese proceso de manera más simple.</p>
<div><pre><code>nano /etc/systemd/system/uwsgi-django_tutorial.service
</code></pre>
</div><hr>
<div><pre><code>[Unit]
Description=uwsgi-django_tutorial
After=network.target

[Install]
WantedBy=multi-user.target

[Service]
User=www-data
Group=www-data
Restart=always

ExecStart=/home/olucas/django_vps/bin/uwsgi /home/olucas/django_vps/fich.ini
ExecReload=/bin/kill -s HUP $MAINPID
ExecStop=/bin/kill -s TERM $MAINPID

WorkingDirectory=/home/olucas/django_tutorial
Environment=PYTHONPATH='/home/olucas/django_tutorial/django_tutorial:/home/olucas/django_vps/lib/python3.9/site-packages'

PrivateTmp=true
</code></pre>
</div><p>Una vez hecho esto habilitaremos el fichero y lo iniciaremos:</p>
<div><pre><code>systemctl enable uwsgi-django.service
</code></pre>
</div><hr>
<div><pre><code>systemctl start uwsgi-django.service
</code></pre>
</div><p><img src="./../images/IAW/django/uwsgi-django.png" alt="image"></p>
<p>Ahora ya podemos crear el virtualhost en nginx para que sirva la aplicación:</p>
<div><pre><code>sudo nano /etc/nginx/sites-available/app-python.conf
</code></pre>
</div><hr>
<div><pre><code>server {
        listen 80;
        listen [::]:80;

        root /home/olucas/django_tutorial;
        index index.html index.php index.htm index.nginx-debian.html;

        server_name python.olucass.com;

        location / {
                proxy_pass http://localhost:8000;
                include proxy_params;
        }

        location /static {
                alias /home/olucas/django_tutorial/static;
        }
}
</code></pre>
</div><p>Y lo habilitamos:</p>
<div><pre><code>ln -s /etc/nginx/site-enabled/ /etc/nginx/site-aviable/app-python.conf
</code></pre>
</div><ul>
<li>
<p><strong>Debes asegurarte que el contenido estático se está sirviendo: ¿Se muestra la imagen de fondo de la aplicación? ¿Se ve de forma adecuada la hoja de estilo de la zona de administración?.</strong></p>
</li>
<li>
<p><strong>Desactiva en la configuración el modo debug a False. Para que los errores de ejecución no den información sensible de la aplicación.</strong></p>
</li>
</ul>
<hr>
<div><pre><code>nano django_tutorial/settings.py
</code></pre>
</div><p><img src="./../images/IAW/django/1-20_django.png" alt="image"></p>
<ul>
<li><strong>La página web debe ser accesible usando https, en la URL: <code>https://python.tudominio.algo</code></strong></li>
</ul>
<p>Para hacer esto crearemos otro VirtualHost:</p>
<div><pre><code>server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;

    ssl on;
        ssl_certificate /etc/letsencrypt/live/olucass.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/olucass.com/privkey.pem;

        root /home/olucas/django_tutorial;
        index index.html index.php index.htm index.nginx-debian.html;

        server_name python.olucass.com;

        location / {
                proxy_pass http://localhost:8000;
                include proxy_params;
        }

        location /static {
                alias /home/olucas/django_tutorial/static;
        }

}
</code></pre>
</div><p>Y lo habilitamos:</p>
<div><pre><code>ln -s /etc/nginx/site-enabled/ /etc/nginx/site-aviable/app-python-https.conf
</code></pre>
</div><p>Y editamos nuestro VirtualHost de antes y le añadimos la siguiente linea:</p>
<div><pre><code>rewrite ^/$ https://python.olucass.com;
</code></pre>
</div><p>Y por ultimo reiniciamos nginx</p>
<div><pre><code>sudo systemctl restart nginx
</code></pre>
</div><p><em><strong>Nota</strong></em>: Si no tenemos nuestro certificado lo generaremos de la siguiente manera:</p>
<div><pre><code>sudo apt remove certbo
sudo apt install snap
snap install --classic certbot
ln -s /snap/bin/certbot /usr/bin/certbot
snap install core; sudo snap refresh core
</code></pre>
</div><hr>
<div><pre><code>cd /etc/nginx/site-available/
</code></pre>
</div><hr>
<div><pre><code>certbot certonly \
--manual \
--preferred-challenges=dns \
--email oscarlucasleo124@gmail.com \
--server https://acme-v02.api.letsencrypt.org/directory \
--agree-tos \
-d *.olucass.com
</code></pre>
</div><p>Nos hiremos en mi caso a Piensasolutions, nos hiremos a la zona del dominio, añadiremos una nueva entrada DNS y añadiremos lo que nos mostro en pantall cuando ejecutamos el comando de generación.</p>
<ul>
<li><strong>Muestra la página funcionando. En la zona de administración se debe ver de forma adecuada la hoja de estilo.</strong></li>
</ul>
<p><img src="./../images/IAW/django/1-21_django.png" alt="image"></p>
<h2 id="tarea-3-modificacion-de-nuestra-aplicacion"> Tarea 3: Modificación de nuestra aplicación</h2>
<p><strong>Vamos a realizar cambios en el entorno de desarrollo y posteriormente vamos a subirlas a producción. Vamos a realizar tres modificaciones, pero recuerda que primero lo haces en el entorno de desarrollo, y luego tendrás que llevar los cambios a producción:</strong></p>
<ul>
<li><strong>Modifica la página inicial donde se ven las encuestas para que aparezca tu nombre: Para ello modifica el archivo <code>django_tutorial/polls/templates/polls/index.html</code>.</strong></li>
</ul>
<p><img src="./../images/IAW/django/1-22_django.png" alt="image"></p>
<ul>
<li><strong>Modifica la imagen de fondo que se ve la aplicación.</strong></li>
</ul>
<p><img src="./../images/IAW/django/1-23_django.png" alt="image"></p>
<p><img src="./../images/IAW/django/1-24_django.png" alt="image"></p>
<ul>
<li>
<p><strong>Vamos a crear una nueva tabla en la base de datos, para ello sigue los siguientes pasos:</strong></p>
<ul>
<li><strong>Añade un nuevo modelo al fichero <code>polls/models.py</code>:</strong></li>
</ul>
</li>
</ul>
<hr>
<div><pre><code>class Categoria(models.Model):
    Abr = models.CharField(max_length=4)
    Nombre = models.CharField(max_length=50)
    
    def __str__(self):
        return self.Abr+&quot; - &quot;+self.Nombre
</code></pre>
</div><hr>
<p><img src="./../images/IAW/django/1-25_django.png" alt="image"></p>
<ul>
<li>
<ul>
<li><strong>Crea una nueva migración.</strong></li>
</ul>
</li>
</ul>
<hr>
<div><pre><code>python3 manage.py makemigrations
</code></pre>
</div><hr>
<ul>
<li>
<ul>
<li><strong>Y realiza la migración.</strong></li>
</ul>
</li>
</ul>
<hr>
<div><pre><code>python3 manage.py migrate
</code></pre>
</div><hr>
<ul>
<li>
<ul>
<li><strong>Añade el nuevo modelo al sitio de administración de django:</strong></li>
</ul>
</li>
</ul>
<p><strong>Para ello cambia la siguiente línea en el fichero <code>polls/admin.py</code>:</strong></p>
<div><pre><code>from .models import Choice, Question
</code></pre>
</div><p><strong>Por esta otra:</strong></p>
<div><pre><code>  from .models import Choice, Question, Categoria
</code></pre>
</div><p><strong>Y añade al final la siguiente línea:</strong></p>
<div><pre><code>admin.site.register(Categoria)
</code></pre>
</div><p><img src="./../images/IAW/django/1-26_django.png" alt="image"></p>
<p>Despues de esto ejecutaremos el siguiente comando:</p>
<div><pre><code>source django_vps/bin/activate
(django_vps)$ python manage.py collectstatic
</code></pre>
</div><p>Y despues hay que subir todo el contenido a GitHub, y nos iremos al VPS y alli haremos un <code>pull</code> al repositorio.</p>
<div><pre><code>git pull
</code></pre>
</div><p>Y volvemos a ejecutar los siguientes comando:</p>
<div><pre><code>source django_vps/bin/activate
(django_vps)$ python3 manage.py makemigrations
(django_vps)$ python3 manage.py migrate
(django_vps)$ python manage.py loaddata db.json
</code></pre>
</div><p>Y nuestra aplicación ya estaria funcionando con los cambios hechos.</p>
<ul>
<li>
<ul>
<li><strong>Despliega el cambio producido al crear la nueva tabla en el entorno de producción.</strong></li>
</ul>
</li>
</ul>
<p><img src="./../images/IAW/django/1-27_django.png" alt="image"></p>
<p><img src="./../images/IAW/django/1-28_django.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Criptografía III. Certificados Digitales. HTTPS</title>
    <id>https://github.com/oscarlucas22/practicas/criptografia3/</id>
    <link href="https://github.com/oscarlucas22/practicas/criptografia3/"/>
    <updated>2023-01-19T18:58:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="criptografia-iii-certificados-digitales-https"> Criptografía III. Certificados Digitales. HTTPS</h1>
<h3 id="tarea-1-instalacion-del-certificado"> Tarea 1: Instalación del certificado</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Una vez que hayas obtenido tu certificado, explica brevemente como se instala en tu navegador favorito.</strong></p>
<p>En mi caso lo hare en Firefox.
Nos iremos a los 3 puntos o las 3 rayas que nos aparecen en el firefox y ahi pincharemos en &quot;Ajustes&quot;</p>
<p><img src="./../images/SAD/cripto III/1-1.png" alt="image"></p>
<p>Luego nos iremos a la parte de &quot;Privacidad y Seguridad&quot; y nos iremos alfinal del todo donde se encuentra los certificados.</p>
<p><img src="./../images/SAD/cripto III/1.1-1.png" alt="image"></p>
<p>Picharemos en &quot;Ver certificados&quot;, nos iremos a &quot;Sus Certificados&quot;, y le daremos a &quot;Importar&quot; importaremos nuestro certificado, nos pedira nuestra contraseña y una vez hecho esto ya estaria instalado.</p>
<p><img src="./../images/SAD/cripto III/1.2-1.png" alt="image"></p>
<p><img src="./../images/SAD/cripto III/1.3-1.png" alt="image"></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Muestra una captura de pantalla donde se vea las preferencias del navegador donde se ve instalado tu certificado.</strong></p>
<p><img src="./../images/SAD/cripto III/2-1.png" alt="image"></p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>¿Cómo puedes hacer una copia de tu certificado?, ¿Como vas a realizar la copia de seguridad de tu certificado?. Razona la respuesta.</strong></p>
<p>Nos hiremos a la misma parte donde hemos importado nuestro certificado y le daremos donde pone &quot;Hacer una copia...&quot;. Nos pedira una conyraseña y una ruta donde guardarlo.</p>
<p><img src="./../images/SAD/cripto III/3-1.png" alt="image"></p>
<p><font color="#00ff00"><strong>4.</strong></font> <strong>Investiga como exportar la clave pública de tu certificado.</strong></p>
<p>Nos iremos a la parte donde hemos importado nuestro certificado, le daremos doble click a nuestro certificado y nos iremos donde pone &quot;PEM (cert)&quot; que es nustra clave publica.</p>
<p><img src="./../images/SAD/cripto III/4-1.png" alt="image"></p>
<h3 id="tarea-2-validacion-del-certificado"> Tarea 2: Validación del certificado</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Instala en tu ordenador el software autofirma y desde la página de VALIDe valida tu certificado. Muestra capturas de pantalla donde se comprueba la validación.</strong></p>
<p><img src="./../images/SAD/cripto III/1-2.png" alt="image"></p>
<h3 id="tarea-3-firma-electronica"> Tarea 3: Firma electrónica</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Utilizando la página VALIDe y el programa autofirma, firma un documento con tu certificado y envíalo por correo a un compañero.</strong></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Tu debes recibir otro documento firmado por un compañero y utilizando las herramientas anteriores debes visualizar la firma (Visualizar Firma) y (Verificar Firma). ¿Puedes verificar la firma aunque no tengas la clave pública de tu compañero?, ¿Es necesario estar conectado a internet para hacer la validación de la firma?. Razona tus respuestas.</strong></p>
<p><em><strong>VALIDe</strong></em></p>
<p><img src="./../images/SAD/cripto III/2-3.png" alt="image"></p>
<p><img src="./../images/SAD/cripto III/2.1-3.png" alt="image"></p>
<p><em><strong>AutoFirma</strong></em></p>
<p><img src="./../images/SAD/cripto III/2.2-3.png" alt="image"></p>
<p><em><strong>¿Puedes verificar la firma aunque no tengas la clave pública de tu compañero?</strong></em></p>
<p>Si se puede ya que cuando la introduces se exporta la clave publica automaticamente para saber quien es.</p>
<p><em><strong>Pueba de Sin internet</strong></em></p>
<p><img src="./../images/SAD/cripto III/2.3-3.png" alt="image"></p>
<p>Como podemos ver si se puede acceder sin internet</p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Entre dos compañeros, firmar los dos un documento, verificar la firma para comprobar que está firmado por los dos.</strong></p>
<p><img src="./../images/SAD/cripto III/3-3.png" alt="image"></p>
<h3 id="tarea-4-autentificacion"> Tarea 4: Autentificación</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Utilizando tu certificado accede a alguna página de la administración pública )cita médica, becas, puntos del carnet,…). Entrega capturas de pantalla donde se demuestre el acceso a ellas.</strong></p>
<p><img src="./../images/SAD/cripto III/1-4.png" alt="image"></p>
<p><img src="./../images/SAD/cripto III/1.1-4.png" alt="image"></p>
<h3 id="tarea-1-certificado-autofirmado"> Tarea 1: Certificado autofirmado</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Crear su autoridad certificadora (generar el certificado digital de la CA). Mostrar el fichero de configuración de la AC.</strong></p>
<p>Para este paso, generaré varias carpetas para ordenar los archivos de la Autoridad Certificadora y algunos archivos necesarios:</p>
<div><pre><code>mkdir CA/
cd CA/
mkdir certs csr crl newcerts private
chmod 700 private
touch index.txt
touch index.txt.attr
echo 1000 &gt; serial
</code></pre>
</div><p>Creo las variables de entorno necesarias:</p>
<div><pre><code>countryName_default=&quot;ES&quot;
stateOrProvinceName_default=&quot;Sevilla&quot;
localityName_default=&quot;Dos Hermanas&quot;
organizationName_default=&quot;GonzaloNazareno&quot;
organizationalUnitName_default=&quot;Informatica&quot;
emailAddress_default=&quot;oscarlucasleo124@gmail.com&quot;
DIR_CA=&quot;./&quot;
</code></pre>
</div><p>Creo el archivo openssl.conf ejecutando lo siguiente:</p>
<div><pre><code>cat &lt;&lt;EOF&gt;$DIR_CA/openssl.conf
[ ca ]
# man ca
default_ca = CA_default

[ CA_default ]
# Directory and file locations.
dir = ${DIR_CA}
certs = ${DIR_CA}certs
crl_dir = ${DIR_CA}crl
new_certs_dir = ${DIR_CA}newcerts
database = ${DIR_CA}index.txt
serial = ${DIR_CA}serial
RANDFILE = ${DIR_CA}private/.rand

# The root key and root certificate.
private_key = ${DIR_CA}private/private.key
certificate = ${DIR_CA}certs/cacert.crt

# For certificate revocation lists.
crlnumber = ${DIR_CA}crlnumber
crl = ${DIR_CA}crl/ca.crl.pem
crl_extensions = crl_ext
default_crl_days = 30

# SHA-1 is deprecated, so use SHA-2 instead.
default_md = sha256

name_opt = ca_default
cert_opt = ca_default
default_days = 375
preserve = no
policy = policy_strict

[ policy_strict ]
# The root CA should only sign intermediate certificates that match.
# See the POLICY FORMAT section of man ca.
countryName = match
stateOrProvinceName = match
organizationName = match
organizationalUnitName = optional
commonName = supplied
emailAddress = optional

[ policy_loose ]
# Allow the intermediate CA to sign a more diverse range of certificates.
# See the POLICY FORMAT section of the ca man page.
countryName = optional
stateOrProvinceName = optional
localityName = optional
organizationName = optional
organizationalUnitName = optional
commonName = supplied
emailAddress = optional

[ req ]
# Options for the req tool (man req).
default_bits = 2048
distinguished_name = req_distinguished_name
string_mask = utf8only
# SHA-1 is deprecated, so use SHA-2 instead.
default_md = sha256
# Extension to add when the -x509 option is used.
x509_extensions = v3_ca
# Extension for SANs
req_extensions = v3_req

[ v3_req ]
# Extensions to add to a certificate request
# Before invoke openssl use: export SAN=DNS:value1,DNS:value2
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
xxxsubjectAltNamexxx =

[ req_distinguished_name ]
# See &lt;https://en.wikipedia.org/wiki/Certificate_signing_request&gt;.
countryName = Country Name (2 letter code)
stateOrProvinceName = State or Province Name
localityName = Locality Name
0.organizationName = Organization Name
organizationalUnitName = Organizational Unit Name
commonName = Common Name
emailAddress = Email Address

# Optionally, specify some defaults.
countryName_default = $countryName_default
stateOrProvinceName_default = $stateOrProvinceName_default
localityName_default = $localityName_default
0.organizationName_default = $organizationName_default
organizationalUnitName_default = $organizationalUnitName_default
emailAddress_default = $emailAddress_default

[ v3_ca ]
# Extensions for a typical CA (man x509v3_config).
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, cRLSign, keyCertSign

[ v3_intermediate_ca ]
# Extensions for a typical intermediate CA (man x509v3_config).
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical, CA:true, pathlen:0
keyUsage = critical, digitalSignature, cRLSign, keyCertSign

[ usr_cert ]
# Extensions for client certificates (man x509v3_config).
basicConstraints = CA:FALSE
nsCertType = client, email
nsComment = &quot;OpenSSL Generated Client Certificate&quot;
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, emailProtection

[ server_cert ]
# Extensions for server certificates (man x509v3_config).
basicConstraints = CA:FALSE
nsCertType = server
nsComment = &quot;OpenSSL Generated Server Certificate&quot;
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth

[ crl_ext ]
# Extension for CRLs (man x509v3_config).
authorityKeyIdentifier=keyid:always

[ ocsp ]
# Extension for OCSP signing certificates (man ocsp).
basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, digitalSignature
extendedKeyUsage = critical, OCSPSigning
EOF
</code></pre>
</div><p>Ahora genero la clave privada:</p>
<div><pre><code>openssl genrsa -aes256 -out private/private.key 4096
</code></pre>
</div><p>Cambio los permisos de la clave privada:</p>
<div><pre><code>chmod 400 private/private.key
</code></pre>
</div><p>Edito el fichero openssl.conf con el siguiente comando:</p>
<div><pre><code>sed -i 's|xxxsubjectAltNamexxx =|subjectAltName = ${ENV::SAN}|g' openssl.conf
</code></pre>
</div><p>Y por último creo el certificado autofirmado para la CA ejecutando lo siguiente:</p>
<div><pre><code>URL=alfonso.iesgn.org
export SAN=DNS:$URL
</code></pre>
</div><hr>
<div><pre><code>openssl req -config openssl.conf -key private/private.key -new -x509 -days 3650 -sha256 -extensions v3_ca -out certs/cacert.crt
</code></pre>
</div><p><img src="./../images/SAD/cripto III/1-1-ssl.png" alt="image"></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Debe recibir el fichero CSR (Solicitud de Firmar un Certificado) de su compañero, debe firmarlo y enviar el certificado generado a su compañero.</strong></p>
<p>Alfonso me ha enviado su fichero CSR. Lo coloco en el directorio csr.</p>
<p><img src="./../images/SAD/cripto III/2-1-ssl.png" alt="image"></p>
<p>Ahora firmo el certificado:</p>
<div><pre><code>openssl ca -config openssl.conf -extensions v3_req -days 3650 -notext -md sha256 -in csr/alfonso.csr -out certs/alfonso.crt
</code></pre>
</div><p><img src="./../images/SAD/cripto III/2.1-1-ssl.png" alt="image"></p>
<p>Para permitir a Alfonso utilizar el certificado, debo enviarle los archivos cacert.crt e alfonso.crt.</p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>¿Qué otra información debes aportar a tu compañero para que éste configure de forma adecuada su servidor web con el certificado generado?</strong></p>
<p>Alfonso requerirá el archivo cacert.crt para verificar la firma del certificado que se le ha enviado, ya que de manera predeterminada, su certificado no se encuentra incluido en los navegadores web.</p>
<p>Después de esto, si se añade el certificado de la autoridad de certificación (CA) al navegador, se podrá acceder al sitio web de Alfonso y comprobar que su certificado es válido.</p>
<p><img src="./../images/SAD/cripto III/3-1-ssl.png" alt="image"></p>
<hr>
<p>Antes de empezar este tema, configuré un servidor web Apache2 en Proxmox con una página de prueba que utiliza el virtualhost olucas.iesgn.org.</p>
<div><pre><code>sudo apt update
sudo apt install apache2
sudo a2dissite 000-default.conf
sudo nano -cl /etc/apache2/sites-available/olucas.iesgn.org.conf
</code></pre>
</div><p>Contenido del fichero olucas.iesgn.org.conf:</p>
<div><pre><code>&lt;VirtualHost *:80&gt;
    ServerName olucas.iesgn.org
    DocumentRoot /var/www/html/olucas.iesgn.org

    ErrorLog ${APACHE_LOG_DIR}/error-olucas.log
    CustomLog ${APACHE_LOG_DIR}/access-olucas.log combined
&lt;/VirtualHost&gt;
</code></pre>
</div><p>Para la web de prueba, me he descargado una plantilla html y la he colocado en la ruta /var/www/html/olucas.iesgn.org:</p>
<p>Ahora activo el virtualhost:</p>
<div><pre><code>sudo a2ensite olucas.iesgn.org.conf
sudo systemctl reload apache2
</code></pre>
</div><p>En mi máquina cliente, agrego la IP de la máquina servidor en el fichero /etc/hosts:</p>
<div><pre><code>172.22.2.141 olucas.iesgn.org
</code></pre>
</div><p>Y compruebo que puedo acceder a la web:</p>
<p><img src="./../images/SAD/cripto III/0-https.png" alt="image"></p>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Crea una clave privada RSA de 4096 bits para identificar el servidor.</strong></p>
<div><pre><code>sudo openssl genrsa -aes256 -out /etc/ssl/private/olucas-privada.key 4096
sudo chmod 400 /etc/ssl/private/olucas-privada.key
</code></pre>
</div><p><img src="./../images/SAD/cripto III/1-2-https.png" alt="image"></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Utiliza la clave anterior para generar un CSR, considerando que deseas acceder al servidor con el FQDN (tunombre.iesgn.org).</strong></p>
<div><pre><code>sudo openssl req -new -sha256 -key /etc/ssl/private/olucas-privada.key -out olucas.csr
</code></pre>
</div><p><img src="./../images/SAD/cripto III/2-2-https.png" alt="image"></p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Envía la solicitud de firma a la entidad certificadora (su compañero).</strong></p>
<p>Le envio el fichero <strong>.csr</strong> a Alfonso</p>
<p><font color="#00ff00"><strong>4.</strong></font> <strong>Recibe como respuesta un certificado X.509 para el servidor firmado y el certificado de la autoridad certificadora.</strong></p>
<p>Alfonso me ha enviado los ficheros olucas.crt y cacert.crt, esto son mi certificado firmado por su CA y el certificado autofirmado de su CA</p>
<p><img src="./../images/SAD/cripto III/4-2-https.png" alt="image"></p>
<p><font color="#00ff00"><strong>5.</strong></font> <strong>Configura tu servidor web con https en el puerto 443, haciendo que las peticiones http se redireccionen a https (forzar https).</strong></p>
<p>El primer paso es crear el VirtualHost para el puerto 443:</p>
<div><pre><code>sudo nano -cl /etc/apache2/sites-available/ssl-olucas.iesgn.org.conf
</code></pre>
</div><p>Contenido del fichero ssl-olucas.iesgn.org.conf:</p>
<div><pre><code>&lt;IfModule mod_ssl.c&gt;
    &lt;VirtualHost *:443&gt;
        ServerName olucas.iesgn.org
        DocumentRoot /var/www/html/olucas.iesgn.org

        ErrorLog ${APACHE_LOG_DIR}/error-ssl-olucas.log
        CustomLog ${APACHE_LOG_DIR}/access-ssl-olucas.log combined

        SSLEngine on
        SSLCertificateFile /etc/ssl/certs/olucas.crt
        SSLCertificateKeyFile /etc/ssl/private/privada-olucas.key
        SSLCACertificateFile /etc/ssl/certs/cacert.crt

        &lt;Directory /var/www/html/olucas.iesgn.org&gt;
            Options Indexes FollowSymLinks
            AllowOverride None
            Require all granted
        &lt;/Directory&gt;
    &lt;/VirtualHost&gt;
&lt;/IfModule&gt;
</code></pre>
</div><p>Ahora coloco los archivos olucas.crt y cacert.crt en los directorios correspondientes. El fichero olucas-
privada.key ya estaba en su sitio.</p>
<div><pre><code>sudo mv olucas.crt /etc/ssl/certs/
sudo mv cacert.crt /etc/ssl/certs/
sudo chown root:root /etc/ssl/certs/olucas.crt
sudo chown root:root /etc/ssl/certs/cacert.crt
sudo chmod 644 /etc/ssl/certs/olucas.crt
sudo chmod 644 /etc/ssl/certs/cacert.crt
</code></pre>
</div><p>Ahora activo el módulo &quot;ssl&quot; de Apache, el VirtualHost nuevo y reinicio el servicio:</p>
<div><pre><code>sudo a2enmod ssl
sudo a2ensite ssl-olucas.iesgn.org.conf
sudo systemctl reload apache2
</code></pre>
</div><p>Durante el proceso, debemos de introducir la contraseña de la clave RSA.</p>
<p>Ahora para habilitar una redirección automática hacia https, modificaremos el fichero
olucas.iesgn.org.conf. Y añadiremos la línea correspondiente para la redirección y el fichero quedaria asi:</p>
<div><pre><code>&lt;VirtualHost *:80&gt;
    ServerName olucas.iesgn.org
    DocumentRoot /var/www/html/olucas.iesgn.org

    ErrorLog ${APACHE_LOG_DIR}/error-olucas.log
    CustomLog ${APACHE_LOG_DIR}/access-olucas.log combined

    redirect 301 / https://olucas.iesgn.org/
&lt;/VirtualHost&gt;
</code></pre>
</div><p>Y volvemos a reiniciar apache</p>
<div><pre><code>sudo systemcl restart apache2
</code></pre>
</div><p><font color="#00ff00"><strong>6.</strong></font> <strong>Instala ahora un servidor nginx, y realiza la misma configuración que anteriormente para que se sirva la página con HTTPS.</strong></p>
<p>Antes que nada, vamos a deshabilitar apache para que no entre en conflicto con el nginx.</p>
<div><pre><code>sudo systemctl disable --now apache2
</code></pre>
</div><p>Despues instalamos nginx:</p>
<div><pre><code>sudo apt install nginx
</code></pre>
</div><p>A continuación creamos el virtualhost para la página web.</p>
<div><pre><code>sudo nano /etc/nginx/sites-available/olucas.iesgn.org.conf
</code></pre>
</div><p>Y el fichero quedaria asi:</p>
<div><pre><code>server {
        listen 80;
        listen [::]:80;
        server_name olucas.iesgn.org;
        return 301 https://$server_name$request_uri;
}

server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;
        server_name olucas.iesgn.org;
        ssl_certificate /etc/ssl/certs/olucas.iesgn.crt;
        ssl_certificate_key /etc/ssl/private/privada-olucas.key;
        ssl_trusted_certificate /etc/ssl/certs/cacert.crt;
        root /var/www/html/olucas.iesgn.org;
        index index.html;
        location / {
                try_files $uri $uri/ =404;
        }
}
</code></pre>
</div><p>Guardamos el fichero y habilitamos el virtualhost. Para ello creamos un enlace simbólico
en /etc/nginx/sites-enabled.</p>
<div><pre><code>ln -s /etc/nginx/sites-available/olucas.iesgn.org.conf /etc/nginx/sites-enabled/
</code></pre>
</div><p>Reiniciamos nginx:</p>
<div><pre><code>sudo systemctl restart nginx
</code></pre>
</div><p>Al reiniciar nginx a diferencia de apache, nos reporta un fallo, ya que no puede cargar la frase de paso.</p>
<p>Para solucionarlo, podemos agregar la línea en el virtualhost:</p>
<div><pre><code>ssl_password_file /etc/keys/global.pass;
</code></pre>
</div><p>Y volvemos a reiniciar nginx:</p>
<div><pre><code>sudo systemctl restart nginx
</code></pre>
</div><p>Y ya nos deberia dejar acceder a nuestra pagina y podriamos acceder con https</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Despliegue de aplicaciones Java</title>
    <id>https://github.com/oscarlucas22/practicas/java/</id>
    <link href="https://github.com/oscarlucas22/practicas/java/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="despliegue-de-aplicaciones-java"> Despliegue de aplicaciones Java</h1>
<p>Información de la <a href="https://fp.josedomingo.org/iaw2223/5_java/practica.html" target="_blank" rel="noopener noreferrer">Practica<i>Content not supported</i></a></p>
<h3 id="tarea-1-desarrollo-y-despliegue-de-una-aplicacion-java-simple"> Tarea 1: Desarrollo y despliegue de una aplicación Java simple</h3>
<p><font color="#FFA500"><strong>Paso 1</strong></font> <strong>Clonamos el <a href="https://github.com/josedom24/rock-paper-scissors" target="_blank" rel="noopener noreferrer">repositorio<i>Content not supported</i></a></strong></p>
<p>Instalamos git si no lo tenemos:</p>
<div><pre><code>apt install git
</code></pre>
</div><p>Y clonamos el repositorio:</p>
<div><pre><code>git clone https://github.com/josedom24/rock-paper-scissors.git
</code></pre>
</div><p>Nota: Para seguir el siguiente paso debes de hacer este <a href="https://fp.josedomingo.org/iaw2223/5_java/t1.html" target="_blank" rel="noopener noreferrer">Taller<i>Content not supported</i></a></p>
<p><font color="#FFA500"><strong>Paso 2</strong></font></p>
<p>Entraremos dentro de la carpeta que se nos ha creado y ejecutaremos el siguiente comando:</p>
<div><pre><code>mvn package
</code></pre>
</div><p><font color="#FFA500"><strong>Paso 3</strong></font> <strong>Nos pasamos el fichero .war</strong></p>
<p>Nos pasaremos por <code>scp</code> a nuestra maquina local el archivo .war que estara dentro de la nueva carpeta que nos ha creado</p>
<p><font color="#FFA500"><strong>Paso 4</strong></font> <strong>Buscaremos la en la web</strong></p>
<div><pre><code>`Ip-de-la-maquina:8080/manager/html`
</code></pre>
</div><p><font color="#FFA500"><strong>Paso 5</strong></font> <strong>Desplegamos la aplicación</strong></p>
<p>Le introduciremos nuestro usuario y password y pincharemos en <em>examinar</em> introduciremos nuestro .war y le daremos a <em>desplegar</em> y nos saldra ya habilitada nuestra pagina.</p>
<p><img src="./../images/IAW/java/1-java.png" alt="image"></p>
<p><img src="./../images/IAW/java/2-java.png" alt="image"></p>
<h3 id="tarea-2-despliegue-de-un-cms-java"> Tarea 2: Despliegue de un CMS Java</h3>
<p><font color="#FFA500"><strong>Paso 1</strong></font> <strong>Descargar el fichero .war</strong></p>
<p><a href="https://cloud.josedomingo.org/index.php/s/cwMj6NAZ4fNMoRA" target="_blank" rel="noopener noreferrer">Fichero .war<i>Content not supported</i></a></p>
<p><font color="#FFA500"><strong>Paso 2</strong></font> <strong>Creamos un usuario en MySQL</strong></p>
<p>Instalamos MySQL si no lo tenemos:</p>
<div><pre><code>sudo apt install mariadb-server -y
</code></pre>
</div><p>Creamos un usuario:</p>
<div><pre><code>create user olucas_java;
</code></pre>
</div><hr>
<div><pre><code>grant all privileges on *.* to 'olucas_java'@'%' identified by 'root' with grant option;
</code></pre>
</div><hr>
<div><pre><code>flush privileges;
</code></pre>
</div><p><font color="#FFA500"><strong>Paso 3</strong></font> <strong>Accedemos a la aplicación para configurarla</strong></p>
<p>Pinchamos en la aplicación:</p>
<p>![image]../images/IAW/java/2-java.png</p>
<p>Ponemos a continuación de la URL <code>/setup</code> y nos aparecera lo siguiente:</p>
<p><img src="./../images/IAW/java/3-java.png" alt="image"></p>
<p><img src="./../images/IAW/java/4-java.png" alt="image"></p>
<p>En la siguiente ventana pondremos el usuarios y la contraseña que hemos creado en MySQL</p>
<p><img src="./../images/IAW/java/5-java.png" alt="image"></p>
<p><img src="./../images/IAW/java/6-java.png" alt="image"></p>
<p><img src="./../images/IAW/java/7-java.png" alt="image"></p>
<p><font color="#FFA500"><strong>Paso 4</strong></font> <strong>Modificación en la aplicación</strong></p>
<p>Despúes de que acabe la instalación haremos alguna modificación en la página entrando en la URL <code>Ip-maquina:8080/opencms/overview/</code></p>
<p>Primero nos tendremos que loguear en la página con el usuario <code>Admin</code> y la contraseña <code>admin</code></p>
<p>Editaremos por ejemplo el cuadro rojo, y cambiaremos <code>Documentación</code> por nuestro nombre mismo, para ello le daremos al lapiz para editar que aparece en la esquina superior derecha del cuadro rojo.</p>
<p><img src="./../images/IAW/java/8-java.png" alt="image"></p>
<p>Y le daremos a publicar que aparece en la esquina superior izquierda de la página:</p>
<p><img src="./../images/IAW/java/9-java.png" alt="image"></p>
<h3 id="tarea-3-acceso-a-las-aplicaciones"> Tarea 3: Acceso a las aplicaciones</h3>
<p>Habilitaremos un virtual host (en mi caso en nginx), si no tenemos instalado nginx lo instalaremos:</p>
<div><pre><code>apt install nginx
</code></pre>
</div><p>Creamos el VirtualHost:</p>
<div><pre><code>sudo nano /etc/nginx/site-available/java.conf
</code></pre>
</div><hr>
<div><pre><code>server {
    listen 80;
    listen [::]:80;

    index index.html index.htm index.nginx-debian.html;

    server_name java.olucas.org;

    location / {
        return 301 http://$host/opencms/;
    }

    location /game{
                proxy_pass http://localhost:8080/roshambo/;
                include proxy_params;
    }	

    location /opencms/{
        proxy_pass http://localhost:8080;
        include proxy_params;	
    }

}
</code></pre>
</div><p>Habilitaremos nuestro virtual host</p>
<div><pre><code>cd /etc/nginx/site-enabled
</code></pre>
</div><hr>
<div><pre><code>sudo ln -s ../site-available/java.conf
</code></pre>
</div><p>Y reiniciamos nginx</p>
<div><pre><code>sudo systemctl restart nginx
</code></pre>
</div><p>Pondremo en el <code>/etc/hosts</code> de nuestra maquina lo siguiente:</p>
<div><pre><code>Ip-maquina  java.tunombre.org
</code></pre>
</div><p>Cambiamos los permisos del directorio opencms situado en <code>/var/lib/tomcat9/webapps</code>:</p>
<div><pre><code>sudo chmod 750 opencms
</code></pre>
</div><p>Y ya tendiamos funcionando nuestra aplicación:</p>
<p>Aplicación Piedra, Papel o Tijeras:</p>
<p><img src="./../images/IAW/java/10-java.png" alt="image"></p>
<p>Aplicación Opencms:</p>
<p><img src="./../images/IAW/java/11-java.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Recolección centralizada de logs de sistema, mediante journald.</title>
    <id>https://github.com/oscarlucas22/practicas/logs/</id>
    <link href="https://github.com/oscarlucas22/practicas/logs/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="recoleccion-centralizada-de-logs-de-sistema-mediante-journald"> Recolección centralizada de logs de sistema, mediante journald.</h1>
<p>Lo primero que hare es instalar en cada maquina &quot;systemd-journal-remote&quot;, con el siguiente comando:</p>
<p><strong>Alfa, Charlie, Delta</strong></p>
<div><pre><code>sudo apt install systemd-journal-remote
</code></pre>
</div><p><strong>Bravo</strong></p>
<div><pre><code>sudo dnf install systemd-journal-remote
</code></pre>
</div><p><em><strong>El servidor que contenga los logs sera Alfa</strong></em></p>
<p>Como https no lo utilizare para la comunicacion, desactivare dicha la opcion en el fichero <code>/lib/systemd/system/systemd-journal-remote.service</code></p>
<p>Para ello editare el fichero y cambiare el <code>https</code> por <code>http</code>:</p>
<p><img src="./../images/ASO/1-logs.png" alt="image"></p>
<p><img src="./../images/ASO/2-logs.png" alt="image"></p>
<p><img src="./../images/ASO/3-logs.png" alt="image"></p>
<p>Le asignamos el propietario correspondiente:</p>
<div><pre><code>sudo chown systemd-journal-remote:systemd-journal-remote /var/log/journal/remote/
</code></pre>
</div><p><strong>Nota</strong>: Si el fichero &quot;/var/log/journal/remote&quot; no existe lo crearemos</p>
<p>Una vez tenga el servidor receptor configurado, lo siguiente sera configurar cada cliente para hacer que envie sus logs.</p>
<p><em><strong>Los servidores que enviaran los logs seran: Bravo, Charlie y Delta</strong></em></p>
<p>En cada cliente creare un usuarios llamado systemd-journal-upload, con el &quot;home&quot; en &quot;/run/systemd&quot;, con el login deshabilitado y en el grupo systemd-journal-upload:</p>
<p><strong>Bravo</strong></p>
<div><pre><code>sudo adduser --system --home-dir /run/systemd --no-create-home --user-group systemd-journal-upload
</code></pre>
</div><p><strong>Charlie y Delta</strong></p>
<div><pre><code>sudo adduser --system --home /run/systemd --no-create-home --disabled-login --group systemd-journal-upload
</code></pre>
</div><p>Tras crear los usuarios, modificaremos la configuraciondel fichero <code>/etc/systemd/journal-upload.conf</code> para que los clientes envien los logs a Alfa. Con el comando <code>sed</code> cambiare la linea <code># URL=</code> para que contenga la direccion y el puerto de Alfa:</p>
<p>++Bravo, Charlie y Delta**</p>
<div><pre><code>sudo sed -i 's/# URL=/URL=http:\/\/alfa.olucas.gonzalonazareno.org:19532/g' /etc/systemd/journal-upload.conf 
</code></pre>
</div><p><img src="./../images/ASO/4-logs.png" alt="image"></p>
<p><img src="./../images/ASO/5-logs.png" alt="image"></p>
<p><img src="./../images/ASO/6-logs.png" alt="image"></p>
<p>Una vez hecho esto reiniciaremos el servicio <code>systemd-journal-upload</code> en cada cliente:</p>
<p><strong>Bravo, Charlie, Delta</strong></p>
<div><pre><code>sudo systemctl restart systemd-journal-upload.service
</code></pre>
</div><h3 id="comprobacion"> Comprobación</h3>
<p>Si ahora comprobamos el directorio <code>/var/log/journal/remote</code> en Alfa, podremos ver como se han creado los archivos de logs de los clientes, con el nombre <code>remote-IpCliente.journal</code>:</p>
<p><strong>Nota</strong>: Si aparecen solo dos (normalmente es Charlie el que no aparece), hay que añadir en el fichero &quot;/etc/hosts&quot; '192.168.0.1 alfa.olucas.gonzalonazareno.org alfa'</p>
<p><img src="./../images/ASO/7-logs.png" alt="image"></p>
<p>Para comprobar que los logs se estan enviando correctamente, usare el comando &quot;journalctl&quot;  para ver los de cada cliente</p>
<div><pre><code>sudo journalctl --file /var/log/journal/remote-IpCliente.journal
</code></pre>
</div><p><strong>Bravo</strong>
<img src="./../images/ASO/8-logs.png" alt="image"></p>
<p><strong>Charlie</strong>
<img src="./../images/ASO/9-logs.png" alt="image"></p>
<p><strong>Delta</strong>
<img src="./../images/ASO/10-logs.png" alt="image"></p>
<p>Se puede observar que los logs estan llegando correctamente a Alfa por lo que el sistema de recoleccion de logs esta funcionando perfectamente.</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Compilación de un programa en C utilizando un Makefile</title>
    <id>https://github.com/oscarlucas22/practicas/makefile/</id>
    <link href="https://github.com/oscarlucas22/practicas/makefile/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="compilacion-de-un-programa-en-c-utilizando-un-makefile"> Compilación de un programa en C utilizando un Makefile</h1>
<p>Aqui dejo la url de la web de <a href="https://packages.debian.org/bullseye/imagination" target="_blank" rel="noopener noreferrer">Debian<i>Content not supported</i></a> donde se encuentra la compilación del paquete imagination.</p>
<p><font color="#FFFF00"><strong>Paso 1</strong></font> Descarga del código fuente</p>
<p>Primero instalaremos dpkg-dev</p>
<div><pre><code>sudo apt install dpkg-dev
</code></pre>
</div><p>Despues instalaremos imagination con el comando <code>apt source</code></p>
<div><pre><code>apt source imagination
</code></pre>
</div><p><img src="./../images/ASO/1-ASO.png" alt="image"></p>
<p><img src="./../images/ASO/2-ASO.png" alt="image"></p>
<p><font color="#FFFF00"><strong>Paso 2</strong></font> Instalación dependencias</p>
<p>Para instalar las dependencias utilizaremos el comando <code>apt build-dep</code></p>
<div><pre><code>sudo apt build-dep imagination
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 3</strong></font> Compilación del paquete</p>
<p>Para poder compilar el paquete nos moveremos a la carpeta descomprimida</p>
<div><pre><code>cd imagination-3.6/

./configure
</code></pre>
</div><p><img src="./../images/ASO/3-ASO.png" alt="image"></p>
<p><img src="./../images/ASO/4-ASO.png" alt="image"></p>
<p>Y despues de esto ejecutaremos el comando <code>make</code></p>
<div><pre><code>make
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 4</strong></font> Instalación del paquete</p>
<p>Una vez ya este compilado ejecutaremos:</p>
<div><pre><code>sudo make install
</code></pre>
</div><p>Y con esto ya tendriamos instalado el paquete</p>
<p><font color="#FFFF00"><strong>Paso 5</strong></font> Desinstalación del paquete</p>
<p>Para poder desinstalar el paquete debemos ejecutar:</p>
<div><pre><code>cd imagination-3.6/

sudo make uninstall
</code></pre>
</div><p>Y con esto ya estaría desinstalado</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">MongoDB en Debian 11 Bullseye</title>
    <id>https://github.com/oscarlucas22/practicas/mongo/</id>
    <link href="https://github.com/oscarlucas22/practicas/mongo/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mongodb-en-debian-11-bullseye"> MongoDB en Debian 11 Bullseye</h1>
<p><img src="./../images/ABD/mongodb.png" alt="image"></p>
<h2 id="instalacion-de-mongodb-en-debian-11-bullseye"> Instalación de MongoDB en Debian 11 Bullseye</h2>
<p><font color="#800080"><strong>Paso 1</strong></font> Instalar paquetes requeridos</p>
<div><pre><code>sudo apt install dirmngr gnupg apt-transport-https software-properties-common ca-certificates curl -y
</code></pre>
</div><p><font color="#800080"><strong>Paso 2</strong></font> Importar repositorio de MongoDB</p>
<div><pre><code>sudo wget -O- https://www.mongodb.org/static/pgp/server-5.0.asc | gpg --dearmor | sudo tee /usr/share/keyrings/mongodb.gpg
</code></pre>
</div><p><font color="#800080"><strong>Paso 3</strong></font> Agregamos el repositorio</p>
<div><pre><code>echo 'deb [signed-by=/usr/share/keyrings/mongodb.gpg] http://repo.mongodb.org/apt/debian buster/mongodb-org/5.0 main' | sudo tee /etc/apt/sources.list.d/mongodb-org-5.0.list
</code></pre>
</div><p><font color="#800080"><strong>Paso 4</strong></font> Actualizamos</p>
<div><pre><code>sudo apt-get update
</code></pre>
</div><p><font color="#800080"><strong>Paso 5</strong></font> Instalar MongoDB 5.0</p>
<div><pre><code>sudo apt install mongodb-org -y
</code></pre>
</div><p><font color="#800080"><strong>Paso 6</strong></font> Activamos el servicio de mongodb</p>
<div><pre><code>sudo systemctl enable mongod --now
</code></pre>
</div><p><font color="#800080"><strong>Paso 7</strong></font> Verificamos la versión</p>
<div><pre><code>mongo --eval 'db.runCommand({ connectionStatus: 1 })'
</code></pre>
</div><p><img src="./../images/ABD/1-mongo.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 8</strong></font> Configurar la seguridad de MongoDB</p>
<div><pre><code>sudo nano /etc/mongod.conf
</code></pre>
</div><hr>
<div><pre><code>security:
    authorization: enabled
</code></pre>
</div><p><img src="./../images/ABD/2-mongo.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 9</strong></font> Reiniciamos servicio</p>
<div><pre><code>sudo systemctl restart mongod
</code></pre>
</div><h2 id="creacion-de-usuario-administrador"> Creación de usuario administrador</h2>
<p><font color="#800080"><strong>Paso 1</strong></font> Crear usuario administrador en MongoDB</p>
<div><pre><code>mongosh
</code></pre>
</div><p><font color="#800080"><strong>Paso 2</strong></font> Nos conectamos como administrador</p>
<div><pre><code>use admin
</code></pre>
</div><p><font color="#800080"><strong>Paso 3</strong></font> Creamos usuario</p>
<div><pre><code>db.createUser(
    {
        user: &quot;lucas&quot;, 
        pwd: &quot;admin&quot;, 
        roles: [{ role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; }, &quot;readWriteAnyDatabase&quot;]
    }
)
</code></pre>
</div><p><img src="./../images/ABD/3-mongo.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 4</strong></font> Nos conectamos</p>
<div><pre><code>mongosh -u lucas
</code></pre>
</div><hr>
<h2 id="ayuda-sobre-manejo-en-mongodb"> Ayuda sobre manejo en MongoDB</h2>
<h3 id="creacion-de-base-de-datos"> Creación de base de datos</h3>
<div><pre><code>use &lt;nombre-database&gt;
</code></pre>
</div><h3 id="usuario"> Usuario</h3>
<p><strong>Creacion de usuario</strong></p>
<div><pre><code>db.createUser(
    {
        user: &quot;usuario&quot;, 
        pwd: &quot;passwd&quot;, 
        roles: []
    }
)
</code></pre>
</div><p><strong>Borrar usuario</strong></p>
<p>db.dropUser(&quot;usuario&quot;)</p>
<h3 id="colecciones"> Colecciones</h3>
<p><strong>Crear coleccion</strong></p>
<div><pre><code>db.createCollection(&quot;collection&quot;)
</code></pre>
</div><p><strong>Insertar valores</strong></p>
<div><pre><code>db.collection.insertMany([
{ dato1: &quot;dato&quot;, dato1: &quot;dato&quot; },
{ dato2: &quot;dato&quot;, dato2: &quot;dato&quot; }
])
</code></pre>
</div><h3 id="uso-de-privilegios-roles"> Uso de privilegios (Roles)</h3>
<p><strong>Crear rol</strong></p>
<p>Ejemplo de privilegio de solo lectura</p>
<div><pre><code>db.createRole({role: &quot;nombre-role&quot;, privileges:[{resource: {db:&quot;nombre-db&quot;,collection:&quot;nombre-collection&quot;},actions:[&quot;find&quot;]}],roles:[]})
</code></pre>
</div><p>Se la asignamos a un usuario</p>
<div><pre><code>db.grantRolesToUser(&quot;usuario&quot;,[{role:&quot;nombre-role&quot;,db:&quot;nombre-db&quot;}])
</code></pre>
</div><hr>
<p><strong>Listar base de datos</strong></p>
<div><pre><code>show dbs
</code></pre>
</div><p><strong>Verificar la base de datos actual</strong></p>
<div><pre><code>db
</code></pre>
</div><p><strong>Eliminar base de datos</strong></p>
<p>Hacerlo dentro de la base de datos</p>
<div><pre><code>db.dropDatabase()
</code></pre>
</div><p><strong>Importar json en MongoDB</strong></p>
<p>Hacerlo fuera de mongo</p>
<div><pre><code>mongoimport --db NAME_BD --collection NAME_YOUR_COLLECTION --file 'ruta del json'
</code></pre>
</div><p><strong>Eliminar json de la base de datos</strong></p>
<p>Hacerlo dentro de la base de datos donde este el json</p>
<div><pre><code>db.NAME_COLLECTION.drop()
</code></pre>
</div><p><strong>Mostrar la colección</strong></p>
<div><pre><code>db.nombre-collection.find()
</code></pre>
</div><h2 id="acceso-remoto"> Acceso remoto</h2>
<p><font color="#800080"><strong>Paso 1</strong></font> Editaremos el fichero <code>mongod.conf</code></p>
<div><pre><code>sudo /etc/mongod.conf
</code></pre>
</div><p>Ahí editaremos donde pone <code>bindIp</code> escribiremos la ip del servidor, asi como se muestra en la imagen:</p>
<p><img src="./../images/ABD/4-mongo.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 2</strong></font> Reiniciamos el servicio para que los cambios se guarden</p>
<div><pre><code>sudo service mongod restart
</code></pre>
</div><p><font color="#800080"><strong>Paso 3</strong></font> Nos iremos a la maquina cliente y nos conectaremos</p>
<div><pre><code>mongosh -u nombre-user -p password ip-server
</code></pre>
</div><p><img src="./../images/ABD/5-mongo.png" alt="image"></p>
<p>¡Gracias!</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Migrar Centos 8 a Rocky Linux 8</title>
    <id>https://github.com/oscarlucas22/practicas/migracionrocky/</id>
    <link href="https://github.com/oscarlucas22/practicas/migracionrocky/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="migrar-centos-8-a-rocky-linux-8"> Migrar Centos 8 a Rocky Linux 8</h1>
<p><img src="./../images/ASO/rocky.png" alt="image"></p>
<p>Para conseguir este fin se nos ofrece un script llamado <strong>migrate2rocky.sh</strong>. Este script se encargará de cambiar los repositorios del sistemas por los de Rocky Linux. Los paquetes se instalarán y actualizarán, para finalmente cambiar todo el sistema operativo.</p>
<p><font color="#FFFF00"><strong>Paso 1</strong></font> Actualizamos el sistema.</p>
<div><pre><code>sudo dnf -y upgrade
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 2</strong></font> Reiniciamos.</p>
<div><pre><code>sudo reboot 
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 3</strong></font> Actualizar el sistema.</p>
<div><pre><code>dnf update
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 4</strong></font> Descargar repositorio.</p>
<p>Una vez hecho esto nos iremos al repositorio donde se encuentra dicho script, en este caso en Github.
Podemos descargar los paquetes del repositorio con programas como wget.</p>
<div><pre><code>wget https://github.com/rocky-linux/rocky-tools/archive/refs/heads/main.zip
</code></pre>
</div><p>O bien, si solo deseamos descargar el script:</p>
<div><pre><code>wget https://raw.githubusercontent.com/rocky-linux/rocky-tools/main/migrate2rocky/migrate2rocky.sh
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 5</strong></font> Le asignamos permisos de ejecución.</p>
<div><pre><code>chmod +x migrate2rocky.sh
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 6</strong></font> Lo ejecutamos.</p>
<p>Con el parámetro <strong>-r</strong> indicamos que siga adelante e instale todo.</p>
<div><pre><code>./migrate2rocky.sh -r
</code></pre>
</div><p>El proceso puede tardar un rato, según la capacidad del equipo y la conexión a Internet.</p>
<p>Después:</p>
<div><pre><code>sudo dnf distro-sync -y
</code></pre>
</div><hr>
<div><pre><code>sudo reboot
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 7</strong></font> Comprobación.</p>
<div><pre><code>cat /etc/os-release
</code></pre>
</div><p>Podemos consultar ficheros como <strong>/etc/os-release</strong> o bien <strong>/etc/redhat-release</strong>, o lanzar el comando <strong>hostnamectl</strong></p>
<div><pre><code>cat /etc/redhat-release
</code></pre>
</div>]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Oracle en Debian 11 Bullseye</title>
    <id>https://github.com/oscarlucas22/practicas/oracle/</id>
    <link href="https://github.com/oscarlucas22/practicas/oracle/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="oracle-en-debian-11-bullseye"> Oracle en Debian 11 Bullseye</h1>
<p><img src="./../images/ABD/oracle.png" alt="image"></p>
<h2 id="instalacion-de-oracle-en-debian-11-bullseye"> Instalación de Oracle en Debian 11 Bullseye</h2>
<p><font color="#800080"><strong>Paso 1</strong></font></p>
<p>Antes de instalar el paquete, tenemos que configurar algunas cosas. Empezaremos creando el script:</p>
<div><pre><code>sudo nano /sbin/chkconfig
</code></pre>
</div><p>Y copiamos estas líneas en el archivo:</p>
<div><pre><code>#!/bin/bash
# Oracle XE installer chkconfig hack for Ubuntu
file=/etc/init.d/oracle-xe
if [[ ! `tail -n1 $file | grep INIT` ]]; then
echo &gt;&gt; $file
echo '### BEGIN INIT INFO' &gt;&gt; $file
echo '# Provides: OracleXE' &gt;&gt; $file
echo '# Required-Start: $remote_fs $syslog' &gt;&gt; $file
echo '# Required-Stop: $remote_fs $syslog' &gt;&gt; $file
echo '# Default-Start: 2 3 4 5' &gt;&gt; $file
echo '# Default-Stop: 0 1 6' &gt;&gt; $file
echo '# Short-Description: Oracle 19c Express Edition' &gt;&gt; $file
echo '### END INIT INFO' &gt;&gt; $file
fi
update-rc.d oracle-xe defaults 80 01
</code></pre>
</div><p><font color="#800080"><strong>Paso 2</strong></font></p>
<p>Damos los permisos necesarios al archivo:</p>
<div><pre><code>sudo chmod 755 /sbin/chkconfig
</code></pre>
</div><p><font color="#800080"><strong>Paso 3</strong></font></p>
<p>Oracle 19c XE requiere de una configuración especial en kernel para funcionar. Por eso necesitamos añadir algunos parámetros al mismo.</p>
<div><pre><code>sudo nano /etc/sysctl.d/60-oracle.conf
</code></pre>
</div><p>Copiamos lo siguiente y guardamos.</p>
<div><pre><code>fs.file-max=6815744
net.ipv4.ip_local_port_range=9000 65000
kernel.sem=250 32000 100 128
kernel.shmmax=536870912
</code></pre>
</div><p><font color="#800080"><strong>Paso 4</strong></font></p>
<p>Para cargar los parámetros del kernel sin reiniciar:</p>
<div><pre><code>sudo service procps start
</code></pre>
</div><p><font color="#800080"><strong>Paso 5</strong></font> <strong>Comienzo de la instalación</strong></p>
<p>Y ahora sí, instalamos el paquete <a href="https://www.dropbox.com/s/p1vhrnjw73fdc70/oracle-database-ee-19c_1.0-2_amd64.deb?dl=0" target="_blank" rel="noopener noreferrer">.deb<i>Content not supported</i></a>:</p>
<div><pre><code>sudo dpkg -i oracle-database-ee-19c_1.0-2_amd64.deb
</code></pre>
</div><p>Después de unos 10 minutos el proceso terminará. Ejecutamos el siguiente comando para configurar la contraseña de administrador de la base de datos y demás cosas:</p>
<div><pre><code>sudo /etc/init.d/oracledb_ORCLCDB-19c configure
</code></pre>
</div><p>Veremos que da error. Eso se debe a que en al script de configuración le hace falta un parámetro. Para añadirlo entramos en el script con:</p>
<div><pre><code>sudo nano /etc/init.d/oracledb_ORCLCDB-19c
</code></pre>
</div><p>Y buscamos(Ctrl + W) en la línea donde pone &quot;Configuring&quot;</p>
<p><img src="./../images/ABD/1-oracle.png" alt="image"></p>
<p>Borramos la línea que se ve marcada en la imagen y copiamos en su lugar la siguiente:</p>
<div><pre><code>$SU -s /bin/bash  $ORACLE_OWNER -c &quot;$DBCA -silent -createDatabase -gdbName $ORACLE_SID -templateName $TEMPLATE_NAME -characterSet $CHARSET -createAsContainerDatabase $CREATE_AS_CDB -numberOfPDBs $NUMBER_OF_PDBS -pdbName $PDB_NAME -createListener $LISTENER_NAME:$LISTENER_PORT -datafileDestination $ORACLE_DATA_LOCATION -sid $ORACLE_SID -autoGeneratePasswords -emConfiguration DBEXPRESS -emExpressPort $EM_EXPRESS_PORT -J-Doracle.assistants.dbca.validate.ConfigurationParams=false&quot;
</code></pre>
</div><p>Ahora lo intentamos de nuevo:</p>
<div><pre><code>sudo /etc/init.d/oracledb_ORCLCDB-19c configure
</code></pre>
</div><p><code>Nota: Si nos salta un error de netstat tendremos que instalarlo sudo apt install net-tools</code></p>
<p><code>Nota: Si nos sigue saliendo un error instalaremos lo siguiente sudo apt install libaio1 unixodbc</code></p>
<p>Si te sale este error:</p>
<p><img src="./../images/ABD/2-oracle.png" alt="image"></p>
<p>Sigue estos pasos:</p>
<div><pre><code>sudo nano /etc/hosts
</code></pre>
</div><p>Dentro del fichero escribe tu ip seguido del nombre de tu máquina dos veces, como se muestra en la siguiente imagen:</p>
<p><img src="./../images/ABD/3-oracle.png" alt="image"></p>
<p>Y después de esto ejecutaremos de nuevo el comando y ya debería de ir sino reinicia la máquina (<em>sudo reboot</em>) y vuélvelo a probar</p>
<p><font color="#800080"><strong>Paso 6</strong></font></p>
<p>Añadimos las variables de entorno a bash:</p>
<div><pre><code>nano ~/.bashrc
</code></pre>
</div><p>Copiamos las siguientes líneas al final del fichero:</p>
<div><pre><code>export ORACLE_HOME=/opt/oracle/product/19c/dbhome_1
export ORACLE_SID=ORCLCDB
export ORACLE_BASE=/opt/oracle
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:$LD_LIBRARY_PATH
export PATH=$ORACLE_HOME/bin:$PATH
</code></pre>
</div><p><font color="#800080"><strong>Paso 7</strong></font></p>
<p>Para finalizar reiniciamos el servicio de Oracle 19c:</p>
<div><pre><code>sudo service oracledb_ORCLCDB-19c restart
</code></pre>
</div><p>Para iniciar Oracle ejecutaremos una serie de pasos:</p>
<p><strong>Primero pondremos una contraseña</strong></p>
<div><pre><code>passwd oracle
</code></pre>
</div><p><strong>Segundo entrasemos en oracle</strong></p>
<div><pre><code>su oracle
</code></pre>
</div><p>Seguramente te salga un <code>$</code>, si es así eso es que no tienes shell. Para solucionarlo ejecutaremos</p>
<div><pre><code>sudo usermod -s /bin/bash oracle
</code></pre>
</div><p>Y probaremos de nuevo:</p>
<div><pre><code>su oracle
</code></pre>
</div><p>Una vez dentro ya tendras shell y dentro ejecutaremos:</p>
<div><pre><code>sqlplus / as sysdba
</code></pre>
</div><p>Si esto no te va reinicia la maquina <code>sudo reboot</code> y prueba de nuevo</p>
<p>Bien, una vez echo esto si al iniciar te sale algo asi:</p>
<p><img src="./../images/ABD/4-oracle.png" alt="image"></p>
<p>Ejecuta lo siguiente</p>
<div><pre><code>SQL&gt; shutdown abort
</code></pre>
</div><hr>
<div><pre><code>SQL&gt; startup
</code></pre>
</div><p>Y ya estaría sal y entra de nuevo y te deberia salir algo así:</p>
<p><img src="./../images/ABD/5-oracle.png" alt="image"></p>
<p>Acto seguido cambiaremos la contraseña del user SYS y SYSTEM</p>
<div><pre><code>SQL&gt; alter user sys identified by TU_PASSWD;
</code></pre>
</div><hr>
<div><pre><code>SQL&gt; alter user system identified by TU_PASSWD;
</code></pre>
</div><h2 id="creacion-de-usuario"> Creación de usuario</h2>
<p><font color="#800080"><strong>Paso 1</strong></font></p>
<p>Ejecutamos el siguiente comando para activar _ORACLE_SCRIPT para que se puedan ejecutar sin errores los siguientes comandos:</p>
<div><pre><code>SQL&gt; alter session set &quot;_ORACLE_SCRIPT&quot;=true;
</code></pre>
</div><p>Y luego nos dejara crear el usuario</p>
<div><pre><code>SQL&gt; create user lucas identified by admin;
</code></pre>
</div><p>Si le queremos dar prvilegios ejecutaremos el siguiente comando(en este caso le daremos todos los privilegios):</p>
<div><pre><code>SQL&gt; grant all privileges to lucas;
</code></pre>
</div><p>Una vez hecho esto pasos ya estaria el usuario creato y nos podremos conectar con el siguiente comando:</p>
<div><pre><code>sqlplus lucas/admin
</code></pre>
</div><p><img src="./../images/ABD/6-oracle.png" alt="image"></p>
<p>Para crear la base de datos y las tablas con sus respectivos inserts aqui os muestro como se hace:</p>
<p><a href="https://github.com/oscarlucas22/Proyecto-DDL-y-DML_BD/tree/main/Oracle" target="_blank" rel="noopener noreferrer">Como crear base de datos y tablas en Oracle<i>Content not supported</i></a></p>
<h2 id="cliente-remoto-oracle"> Cliente remoto Oracle</h2>
<p><font color="#800080"><strong>Paso 1</strong></font> Activaremos listener y habilitaremos el pueto 1521/tcp</p>
<p>Antes de comenzar tenemos que activar el listener:</p>
<div><pre><code>lsnrclt start
</code></pre>
</div><p>Despues de eso habilitaremos el puerto 1521 del firewall, pero antes si no tenemos instalado firewalld lo instalaremos:</p>
<div><pre><code>sudo apt install firewalld
</code></pre>
</div><p>Y ahora si habilitaremos el puerto 1521:</p>
<div><pre><code>sudo firewall-cmd --permanent --add-port=1521/tcp
</code></pre>
</div><hr>
<div><pre><code>sudo firewall-cmd --reload
</code></pre>
</div><p><font color="#800080"><strong>Paso 2</strong></font> Instalaremos los clientes</p>
<p>Una vez hecho esto instalaremos los clientes de Oracle</p>
<ul>
<li><a href="https://download.oracle.com/otn_software/linux/instantclient/218000/oracle-instantclient-basic-21.8.0.0.0-1.el8.x86_64.rpm" target="_blank" rel="noopener noreferrer">basic<i>Content not supported</i></a></li>
<li><a href="https://download.oracle.com/otn_software/linux/instantclient/218000/oracle-instantclient-devel-21.8.0.0.0-1.el8.x86_64.rpm" target="_blank" rel="noopener noreferrer">devel<i>Content not supported</i></a></li>
<li><a href="https://download.oracle.com/otn_software/linux/instantclient/218000/oracle-instantclient-sqlplus-21.8.0.0.0-1.el8.x86_64.rpm" target="_blank" rel="noopener noreferrer">sqlplus<i>Content not supported</i></a></li>
</ul>
<p>Una vez descargados los instalaremos en mi caso como lo voy a instalar en un Debian utilizaremos el comando <code>alien</code></p>
<div><pre><code>sudo alien -i --scripts oracle-instantclient-*
</code></pre>
</div><p><font color="#800080"><strong>Paso 3</strong></font> Acceso desde el cliente</p>
<p>Una vez instalados los clientes ya podremos acceder</p>
<div><pre><code>sqlplus lucas/admin@ip-server/ORCLCDB
</code></pre>
</div><p><img src="./../images/ABD/7-oracle.png" alt="image"></p>
<p>¡Gracias!</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">MariaDB en Debian 11 Bullseye</title>
    <id>https://github.com/oscarlucas22/practicas/mariadb/</id>
    <link href="https://github.com/oscarlucas22/practicas/mariadb/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mariadb-en-debian-11-bullseye"> MariaDB en Debian 11 Bullseye</h1>
<p><img src="./../images/ABD/mariadb.png" alt="image"></p>
<p>Para conseguir una instalación correcta debemos cumplir los siguientes requisitos:</p>
<p><input type="checkbox" name="vehicle" value="Bike"> Tener una máquina Debian 11 actualizada</p>
<p><input type="checkbox" name="vehicle" value="Bike"> Tener un usuario con privilegios de sudo</p>
<p><input type="checkbox" name="vehicle" value="Bike"> Tener acceso a internet</p>
<p>Antes de comenzar con la instalación actualizaremos nuestra máquina</p>
<div><pre><code>sudo apt update &amp;&amp; sudo apt upgrade
</code></pre>
</div><p>Una vez completada la actualización del sistema, ejecuta el siguiente comando para instalr los paquetes necesarios</p>
<div><pre><code>sudo apt-get install software-properties-common dirmngr gnupg2 -y
</code></pre>
</div><hr>
<div><pre><code>sudo apt-get install apt-transport-https wget curl -y
</code></pre>
</div><h2 id="instalar-mariadb-en-debian-11"> Instalar MariaDB en Debian 11</h2>
<p>Para comenzar con la instalación ejecuta el siguiente comando:</p>
<div><pre><code>sudo apt install mariadb-server -y
</code></pre>
</div><p>Para iniciar, detener y reiniciar el servidor de bases de datos MariaDB, utiliza los siguientes comandos:</p>
<p>Iniciar</p>
<div><pre><code>sudo systemctl start mariadb
</code></pre>
</div><p>Detener</p>
<div><pre><code>sudo systemctl stop mariadb
</code></pre>
</div><p>Reiniciar</p>
<div><pre><code>sudo systemctl restart mariadb
</code></pre>
</div><p>Para que MariaDB se inicie automáticamente al arrancar el sistema, ejecuta el siguiente comando:</p>
<div><pre><code>sudo systemctl enable mariadb
</code></pre>
</div><p>MariaDB debería estar en marcha en este momento. Puedes comprobar si se esta ejecutando, ejecutando el siguiente comando:</p>
<div><pre><code>sudo systemctl status mariadb
</code></pre>
</div><p>Ejemplo de salida:</p>
<p><img src="./../images/ABD/1-mariadb.png" alt="image"></p>
<p><code>Ctrl + C</code> para salir del fichero</p>
<p>Y con esto ya tendriamos instalado MariaDB y para ejecutarlo, ejecutaremos el siguiente comando:</p>
<div><pre><code>sudo mysql
</code></pre>
</div><h2 id="creacion-de-usuario"> Creación de usuario</h2>
<p>Los siguientes pasos que vas a ver se ejecutan dentro de MariaDB (cambia el usuario y la contraseña por los tuyos)</p>
<div><pre><code>create user lucas;
</code></pre>
</div><hr>
<div><pre><code>grant all privileges on *.* to 'lucas'@'%' identified by 'root' with grant option;
</code></pre>
</div><hr>
<div><pre><code>FLUSH PRIVILEGES;
</code></pre>
</div><p><img src="./../images/ABD/2-mariadb.png" alt="image"></p>
<p>Y una vez ya creado el usuario salimos de MariaDB ejecutando <code>exit;</code>
Y para conectarnos a nuestro usuario ejecutaremos el siguiente comando:</p>
<div><pre><code>mysql -u lucas -p
</code></pre>
</div><p><img src="./../images/ABD/5-mariadb.png" alt="image"></p>
<h3 id="creacion-de-base-de-datos"> Creación de base de datos</h3>
<p>Para ejecutar una base de datos ejecutaremos el siguiente comando:</p>
<div><pre><code>mysql&gt; CREATE DATABASE nombre-db;
</code></pre>
</div><p><img src="./../images/ABD/6-mariadb.png" alt="image"></p>
<p>Para meternos en una base de datos ejecutaremos el siguiente comando:</p>
<div><pre><code>mysql&gt; use nombre-db;
</code></pre>
</div><p>Para crear una tabla ejecutaremos el siguiente comando:</p>
<div><pre><code>mysql&gt; CREATE TABLE NOMBRE (
    -&gt;     DATO,
    -&gt;     DATO,
    -&gt;     DATO
    -&gt; );
</code></pre>
</div><p>Para ejecutar los insert dentro de la table ejecutaremos el siguiente comando:</p>
<div><pre><code>mysql&gt; INSERT INTO NOMBRE VALUES ('DATO','DATO','DATO');
</code></pre>
</div><p>Ejemplo práctico:</p>
<p><img src="./../images/ABD/7-mariadb.png" alt="image"></p>
<h2 id="acceso-remoto"> Acceso remoto</h2>
<p><font color="#800080"><strong>Paso 1</strong></font> Modificamos el fichero <code>50-server.conf</code></p>
<div><pre><code>sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf
</code></pre>
</div><p>Y editamos la linea donde pone <code>bind-address</code> y lo dejaremos como se muestra en la imagen:</p>
<p><img src="./../images/ABD/3-mariadb.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 2</strong></font> Reiniciamos el servicio mariadb</p>
<div><pre><code>sudo service mariadb restart
</code></pre>
</div><p><font color="#800080"><strong>Paso 3</strong></font> Nos iremos al cliente e instalaremos mariadb-client</p>
<div><pre><code>sudo apt install mariadb-client
</code></pre>
</div><p><font color="#800080"><strong>Paso 4</strong></font> Nos conectamos</p>
<div><pre><code>mariadb -u lucas -h ip-servidor -p 
</code></pre>
</div><p><img src="./../images/ABD/4-mariadb.png" alt="image"></p>
<p>¡Gracias!</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Práctica: Escenario en OpenStack</title>
    <id>https://github.com/oscarlucas22/practicas/openstack/</id>
    <link href="https://github.com/oscarlucas22/practicas/openstack/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="practica-escenario-en-openstack"> Práctica: Escenario en OpenStack</h1>
<p>De aquí saque las cosas de esta <a href="https://fp.josedomingo.org/sri2223/4_iaas/practica.html" target="_blank" rel="noopener noreferrer">práctica<i>Content not supported</i></a>.</p>
<h1 id="instalacion-de-las-instancias-de-openstack"> Instalación de las instancias de OpenStack.</h1>
<hr>
<p><font color="#0000FF"><strong>1.</strong></font> <strong>Crea una red interna que se llame Red DMZ de tu_usuario, con las siguientes características:</strong></p>
<ul>
<li>
<p><strong>Direccionamiento: 172.16.0.0/16</strong></p>
</li>
<li>
<p><strong>Con DHCP y DNS (192.168.202.2).</strong></p>
</li>
<li>
<p><strong>La puerta de enlace de los dispositivos conectados a esta red será el 172.16.0.1.</strong></p>
</li>
</ul>
<hr>
<div><pre><code>openstack network create Red-DMZ-de-olucas
</code></pre>
</div><hr>
<div><pre><code>openstack subnet create --network Red-DMZ-de-olucas --subnet-range 172.16.0.0/16 subnet-DMZ --dhcp --dns-nameserver 192.168.202.2 --gateway 172.16.0.1
</code></pre>
</div><p><font color="#0000FF"><strong>2.</strong></font> <strong>Las dos instancias que vamos a crear se van a configurar con cloud-init de la siguiente manera:</strong></p>
<ul>
<li>
<p><strong>Deben actualizar los paquetes de la distribución de la instancia.</strong></p>
</li>
<li>
<p><strong>El dominio utilizado será del tipo tunombre.gonzalonazareno.org. Por lo tanto en la configuración con cloud-init habrá que indicar el hostname y el FQDN.</strong></p>
</li>
<li>
<p><strong>Se crearán dos usuarios:</strong></p>
<ul>
<li>
<p><strong>Un usuario sin privilegios. Se puede llamar como quieras (pero el nombre será el mismo en todas las máquinas) y accederás a las máquinas usando tu clave ssh privada.</strong></p>
</li>
<li>
<p><strong>Un usuario profesor, que puede utilizar sudo sin contraseña. Copia de las claves públicas de todos los profesores en las instancias para que puedan acceder con el usuario profesor.</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Cambia la contraseña al usuario root.</strong></p>
</li>
</ul>
<hr>
<p>Por aquí dejo mi cloud-init:</p>
<div><pre><code>#cloud-config
#Actualización de paquetes
package_update: true
package_upgrade: true
#Configuración de hostname
preserve_hostname: false
fqdn: alfa.olucas.gonzalonazareno.org
hostname: alfa
# Crear usuarios con clave pública ssh
users:
- name: profesor
sudo: ALL=(ALL) NOPASSWD:ALL
shell: /bin/bash
passwd: profesor
ssh_authorized_keys:
    - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCmjoVIoZCx4QFXvljqozXGqxxlSvO7V2aizqyPgMfGqnyl0J9YXo6zrcWYwyWMnMdRdwYZgHqfiiFCUn2QDm6ZuzC4Lcx0K3ZwO2lgL4XaATykVLneHR1ib6RNroFcClN69cxWsdwQW6dpjpiBDXf8m6/qxVP3EHwUTsP8XaOV7WkcCAqfYAMvpWLISqYme6e+6ZGJUIPkDTxavu5JTagDLwY+py1WB53eoDWsG99gmvyit2O1Eo+jRWN+mgRHIxJTrFtLS6o4iWeshPZ6LvCZ/Pum12Oj4B4bjGSHzrKjHZgTwhVJ/LDq3v71/PP4zaI3gVB9ZalemSxqomgbTlnT jose@debian
    - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCfk9mRtOHM3T1KpmGi0KiN2uAM6CDXM3WFcm1wkzKXx7RaLtf9pX+KCuVqHdy/N/9d9wtH7iSmLFX/4gQKQVG00jHiGf3ABufWeIpjmHtT1WaI0+vV47fofEIjDDfSZPlI3p5/c7tefHsIAK6GbQn31yepAcFYy9ZfqAh8H/Y5eLpf3egPZn9Czsvx+lm0I8Q+e/HSayRaiAPUukF57N2nnw7yhPZCHSZJqFbXyK3fVQ/UQVBeNS2ayp0my8X9sIBZnNkcYHFLIWBqJYdnu1ZFhnbu3yy94jmJdmELy3+54hqiwFEfjZAjUYSl8eGPixOfdTgc8ObbHbkHyIrQ91Kz rafa@eco
- name: oscar
shell: /bin/bash
passwd: usuario
ssh_authorized_keys:
    - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDTcmixc+3Zq1eSaRgb7Kvv5Efy0MZwx7wR6NWdHqi6+oLTPzNxr7IztKo9JvSMWsGzK5xR8mg8V/lPqdYO0GY5vrodpq6UdHojve0g2YaIeex7pcL2G8AEsFbysvUvwCXW4URdu1ZQAOylRPakPi0bIRsbVkRi3TjeeTcUUo/pxwI9VV6SHm94XpwZd/JUvLa8fH5USNTseN/isa4kIgHTxsIrUan2uuIr1BEYgLyrohZrvgVpmv5B/TDupxVo6lSdGQbJFwMp+/Krqrid4kvuBrDKPY5EnYyu5/XNFqRqfhoF4jk4W3Nzb8K/bF+DTelh8kZgouQQJP5RY9v1MRTqS8dq0751rVibD6KouFKBm9gxZ9BnTRFaN8hjZi60z3cyTjEl5bmD7KP5wT0i9E2dvn1xN83j7FM/ryLJ8I2GHIimNgvctQQdWddva0kVNjocteq32OtLOgh52qUzv9gw13WKVbedpoNV1cve/oFK7tH1WwG6nFf64V9Rnh1Inrs= oscar@debian
chpasswd:
list: |
    root:root
expire: False
</code></pre>
</div><p><font color="#0000FF"><strong>3.</strong></font> <strong>Creación de la máquina1 (alfa):</strong></p>
<ul>
<li><strong>Crea una instancia sobre un volumen de 30Gb, usando una imagen de Debian 11 Bullseye. Elige el sabor vol.medium. Y configuralá con cloud-init como se ha indicado anteriormente.</strong></li>
</ul>
<p>Creamos el volumen con la imagén correspondiente:</p>
<div><pre><code>openstack volume create --bootable --size 30 --image &quot;Debian 11 Bullseye&quot; alfa_debian
</code></pre>
</div><p>Creamos la máquina Alfa:</p>
<div><pre><code>openstack server create --flavor vol.medium --volume alfa_debian --security-group default --key-name oscar_clave --network &quot;red de oscar.lucas&quot; --user-data &quot;cloud-init-alfa.yaml&quot; \alfa
</code></pre>
</div><ul>
<li><strong>Está instancia estará conectada a tu red interna. Asigna a la instancia una IP flotante.</strong></li>
</ul>
<p>Le asignamos una Ip flotante:</p>
<div><pre><code>openstack floating ip create ext-net
</code></pre>
</div><hr>
<div><pre><code>openstack server add floating ip alfa 172.22...
</code></pre>
</div><p><font color="#0000FF"><strong>4.</strong></font> <strong>Configuración de la máquina1 (alfa):</strong></p>
<ul>
<li><strong>Conecta la instancia a tu Red DMZ, asígnale la dirección 172.16.0.1 para que sea la puerta de enlace las máquinas conectadas a esta red.</strong></li>
</ul>
<p>Creamos el puerto:</p>
<div><pre><code>openstack port create --network Red-DMZ-de-olucas --fixed-ip ip-address=172.16.0.1 port_alfa
</code></pre>
</div><p>Y asociamos el puerto a la máquina:</p>
<div><pre><code>openstack server add port alfa port_alfa
</code></pre>
</div><ul>
<li><strong>Deshabilita la seguridad de los puertos en las dos interfaces de red para que funcione de manera adecuada el NAT.</strong></li>
</ul>
<p>Quitamos grupo de seguridad:</p>
<div><pre><code>openstack port list --server alfa
</code></pre>
</div><hr>
<div><pre><code>openstack server remove security group alfa default
</code></pre>
</div><hr>
<div><pre><code>openstack port set --disable-port-security port_alfa
</code></pre>
</div><hr>
<div><pre><code>openstack port set --disable-port-security `identificador id`
</code></pre>
</div><ul>
<li><strong>Configura de forma permanente la regla SNAT para que las máquinas de la Red DMZ tengan acceso a internet.</strong></li>
</ul>
<p>Reglas SNAT en la maquina alfa</p>
<p>Entramos en la maquina alfa y entramos al siguiente fichero:</p>
<div><pre><code>nano /etc/sysctl.conf
</code></pre>
</div><p>Y descomentamos la siguiente linea:</p>
<div><pre><code>net.ipv4.ip_forward=1
</code></pre>
</div><p>Y guardamos los cambios:</p>
<div><pre><code>sysctl -p
</code></pre>
</div><p>Instalamos iptables si no lo tenemos:</p>
<div><pre><code>apt install iptables
</code></pre>
</div><p>Ponemos las reglas de iptables:</p>
<div><pre><code>nano /etc/network/interfaces.d/50-cloud-init
</code></pre>
</div><hr>
<div><pre><code>up iptables -t nat -A POSTROUTING -s 172.16.0.0/16 -o ens3 -j MASQUERADE
down iptables -t nat -D POSTROUTING -s 172.16.0.0/16 -o ens3 -j MASQUERADE
</code></pre>
</div><p>Guardamos y reseteamos el servicio:</p>
<div><pre><code>systemctl restart networking
</code></pre>
</div><p><font color="#0000FF"><strong>5.</strong></font> <strong>Creación de la máquina2 (bravo):</strong></p>
<ul>
<li><strong>Está instancia se conectará a la red DMZ. Usando un puerto asigna a esta máquina la dirección 172.16.0.200.</strong></li>
</ul>
<p>Creamos el puerto:</p>
<div><pre><code>openstack port create --network Red-DMZ-de-olucas --fixed-ip ip-address=172.16.0.200 port_bravo
</code></pre>
</div><ul>
<li><strong>Crea una instancia sobre un volumen de 30Gb, usando una imagen de Rocky Linux 9. Elige el sabor vol.normal. Y configuralá con cloud-init como se ha indicado anteriormente.</strong></li>
</ul>
<p>Creamos el volumen:</p>
<div><pre><code>openstack volume create --bootable --size 30 --image &quot;Rocky Linux 9&quot; bravo_rocky
</code></pre>
</div><p>Creamos la máquina Bravo:</p>
<div><pre><code>openstack server create --flavor vol.normal --volume bravo_rocky --security-group default --key-name oscar_clave --port &quot;port_bravo&quot; --user-data &quot;cloud-init-bravo.yaml&quot; \bravo
</code></pre>
</div><ul>
<li><strong>Deshabilita la seguridad de los puertos en la interfaz de red para que funcione de manera adecuada el NAT.</strong></li>
</ul>
<p>Quitamos el grupo de seguridad:</p>
<div><pre><code>openstack port list --server bravo
</code></pre>
</div><hr>
<div><pre><code>openstack server remove security group bravo default
</code></pre>
</div><hr>
<div><pre><code>openstack port set --disable-port-security port_bravo
</code></pre>
</div><ul>
<li><strong>Comprueba que tiene acceso a internet. Si no tiene acceso a internet, no se han actualizado los paquetes con cloud-init, hazlo posteriormente..</strong></li>
</ul>
<h3 id="instalacion-de-los-contenedores"> Instalación de los contenedores</h3>
<hr>
<p><strong>En maquina1 vamos a crear dos contenedores en un red interna, para ello:</strong></p>
<p><font color="#0000FF"><strong>1.</strong></font> <strong>Crea en máquina1 (alfa) un linux bridge llamado br-intra y asigna una dirección IP estática 192.168.0.1. Esta será la IP de máquina1 (alfa) conectada a este switch virtual y será la puerta de enlace de los contenedores</strong></p>
<p>Instalamos los paquetes necesarios:</p>
<div><pre><code>apt install qemu-system libvirt-clients libvirt-daemon-system
</code></pre>
</div><p>Creamos br-intra:</p>
<div><pre><code>nano /etc/network/interfaces.d/50-cloud-init
</code></pre>
</div><hr>
<div><pre><code>auto br-intra
    iface br-intra inet static
    pre-up brctl addbr br-intra
    address 192.168.0.1
    netmask 255.255.255.0
</code></pre>
</div><p><font color="#0000FF"><strong>2.</strong></font> <strong>Instala LXC y crea dos contenedores con la distribución Ubuntu 20.04. Estos contenedores serán la máquina3 (charlie) y la máquina4 (delta).</strong></p>
<p>Instalamos lxc:</p>
<div><pre><code>apt install lxc
</code></pre>
</div><p>Creamos el contenedor:</p>
<div><pre><code>lxc-create -n charlie -t ubuntu -- -r focal
</code></pre>
</div><hr>
<div><pre><code>lxc-create -n delta -t ubuntu -- -r focal
</code></pre>
</div><p><font color="#0000FF"><strong>3.</strong></font> <strong>Configura de forma permanente la regla SNAT para que los contenedores tengan acceso a internet.</strong></p>
<p>Reglas SNAT de Charlie y Delta:</p>
<div><pre><code>nano /etc/network/interfaces.d/50-cloud-init
</code></pre>
</div><hr>
<div><pre><code>up iptables -t nat -A POSTROUTING -s 192.168.0.0/16 -o ens3 -j MASQUERADE
down iptables -t nat -D POSTROUTING -s 192.168.0.0/16 -o ens3 -j MASQUERADE
</code></pre>
</div><p><font color="#0000FF"><strong>4.</strong></font> <strong>Conecta los contenedores al bridge br-intra y configúralo de forma estática con las siguientes direcciones: máquina3 (charlie) la 192.168.0.2 y máquina4 (delta) la 192.168.0.3.</strong></p>
<p><font color="#0000FF"><strong>5.</strong></font> <strong>Para que la red de OpenStack funcione de forma adecuada las imágenes que usamos tienen configurado la mtu (Unidad máxima de transferencia) a 1450 bytes. Tenemos que adecuar los contenedores a este tamaño de trama. Para ello introduce en la configuración de los contenedores la línea: lxc.net.0.mtu = 1450.</strong></p>
<p><font color="#0000FF"><strong>6.</strong></font> <strong>Configura los contenedores para que se auto inicien al reiniciar la instancia.</strong></p>
<p><font color="#0000FF"><strong>7.</strong></font> <strong>Los contenedores tendrán características parecidas a las instancias anteriormente:</strong></p>
<ul>
<li>
<p><strong>Debes actualizar los paquetes de la distribución instalada.</strong></p>
</li>
<li>
<p><strong>El dominio utilizado será del tipo tunombre.gonzalonazareno.org. Por lo tanto configura de manera adecuda el hostname y el FQDN.</strong></p>
</li>
<li>
<p><strong>Para acceder a los contenedores vamos a usar ssh.</strong></p>
</li>
<li>
<p><strong>Crea dos usuarios:</strong></p>
<ul>
<li>
<p><strong>Un usuario sin privilegios. Se puede llamar como quieras (el nombre de usuario que usaste en las instancias) y accederás a los contenedores usando tu clave ssh privada.</strong></p>
</li>
<li>
<p><strong>Un usuario profesor, que puede utilizar sudo sin contraseña. Copia de las claves públicas de todos los profesores en los contenedores para que puedan acceder con el usuario profesor.</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Cambia la contraseña al usuario root</strong></p>
</li>
</ul>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Interconexión Servidores</title>
    <id>https://github.com/oscarlucas22/practicas/orcl-psql/</id>
    <link href="https://github.com/oscarlucas22/practicas/orcl-psql/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="interconexion-servidores"> Interconexión Servidores</h1>
<h2><i>Content not supported</i> Oracle - Oracle <i>Content not supported</i></h2>
<p>Aquí vamos a interconectar dos servidores Oracle. Yo tendré dos máquinas las cuales son oracle1(192.168.122.179) y oracle2(192.168.122.144).</p>
<p><font color="#800080"><strong>Paso 1</strong></font> Configuración del fichero tnsnames.ora.</p>
<p>Primero configuraremos el fichero tnsnames.ora y lo dejaremos de la siguiente manera:</p>
<div><pre><code>nano /opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora
</code></pre>
</div><p><strong>oracle1</strong></p>
<p><img src="./../images/orcl-psql/1-orcl-orcl.png" alt="image"></p>
<p><strong>oracle2</strong></p>
<p><img src="./../images/orcl-psql/2-orcl-orcl.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 2</strong></font> Configuración del fichero listener.ora</p>
<p>A continuación editaremos el fichero listener.ora de la siguiente manera:</p>
<div><pre><code>nano /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora
</code></pre>
</div><p><strong>oracle1</strong></p>
<p><img src="./../images/orcl-psql/3-orcl-orcl.png" alt="image"></p>
<p><strong>oracle2</strong></p>
<p><img src="./../images/orcl-psql/4-orcl-orcl.png" alt="image"></p>
<p>Y una vez modificados estos ficheros reiniciamos el servicio.</p>
<div><pre><code>lsnrctl stop
</code></pre>
</div><hr>
<div><pre><code>lsnrctl start
</code></pre>
</div><p><strong>oracle1</strong></p>
<p><img src="./../images/orcl-psql/5-orcl-orcl.png" alt="image"></p>
<p><strong>oracle2</strong></p>
<p><img src="./../images/orcl-psql/6-orcl-orcl.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 3</strong></font> Creación del usuario</p>
<p><strong>oracle1</strong></p>
<p>Para la maquina oracle1 crearemos un usuario llamado <code>maquina1</code>.</p>
<div><pre><code>sqlplus / as sysdba
</code></pre>
</div><hr>
<div><pre><code>alter session set &quot;_ORACLE_SCRIPT&quot;=true;
</code></pre>
</div><hr>
<div><pre><code>create user maquina1 identified by root;
</code></pre>
</div><hr>
<div><pre><code>grant all privileges to maquina1;
</code></pre>
</div><p><img src="./../images/orcl-psql/7-orcl-orcl.png" alt="image"></p>
<p><strong>oracle2</strong></p>
<p>Para la máquina oracle2 crearemos un usuario llamado <code>maquina2</code>.</p>
<div><pre><code>sqlplus / as sysdba
</code></pre>
</div><hr>
<div><pre><code>alter session set &quot;_ORACLE_SCRIPT&quot;=true;
</code></pre>
</div><hr>
<div><pre><code>create user maquina2 identified by root;
</code></pre>
</div><hr>
<div><pre><code>grant all privileges to maquina2;
</code></pre>
</div><p><img src="./../images/orcl-psql/8-orcl-orcl.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 4</strong></font> Creacion de las tablas.</p>
<p><strong>oracle1</strong></p>
<div><pre><code>sqlplus maquina1/root
</code></pre>
</div><hr>
<div><pre><code>create table peliculas (
    NombrePelicula varchar2(20),
    Genero varchar2(20),
    Director varchar2(20),
    AnoEstreno varchar2(4),
    constraint PK primary key (NombrePelicula)
);
</code></pre>
</div><hr>
<div><pre><code>INSERT INTO peliculas VALUES ('Dune','Ciencia-ficcion','Edwards','1984');
INSERT INTO peliculas VALUES ('Los Idiotas','Drama','Von Trier','1999');
INSERT INTO peliculas VALUES ('Kramer vs Kramer','Drama','Smith','1978');
INSERT INTO peliculas VALUES ('Mision Imposible','Ciencia-ficcion','Johnson','1998');
INSERT INTO peliculas VALUES ('Mi nombre es Joe','Drama','Loach','1995');
INSERT INTO peliculas VALUES ('Rompiendo las olas','Drama','Von Trier','1997');
INSERT INTO peliculas VALUES ('Los Otros','Suspense','Amenabar','2001');
</code></pre>
</div><p><img src="./../images/orcl-psql/9-orcl-orcl.png" alt="image"></p>
<p><strong>oracle2</strong></p>
<div><pre><code>sqlplus maquina2/root
</code></pre>
</div><hr>
<div><pre><code>create table socios (
    DNI varchar2(10),
    Nombre varchar2(20),
    Direccion varchar2(20),
    constraint PK primary key (DNI)
);
</code></pre>
</div><hr>
<div><pre><code>INSERT INTO SOCIOS VALUES ('111-A','David','Sevilla Este');
INSERT INTO SOCIOS VALUES ('222-B','Mariano','Los Remedios');
INSERT INTO SOCIOS VALUES ('333-C','Raul','Triana');
INSERT INTO SOCIOS VALUES ('444-D','Rocio','La Oliva');
INSERT INTO SOCIOS VALUES ('555-E','Marilo','Triana');
INSERT INTO SOCIOS VALUES ('666-F','Benjamin','Montequinto');
INSERT INTO SOCIOS VALUES ('777-G','Carlos','Los Remedios');
INSERT INTO SOCIOS VALUES ('888-H','Manolo','Montequinto');
</code></pre>
</div><p><img src="./../images/orcl-psql/10-orcl-orcl.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 5</strong></font> Interconexión.</p>
<p>Este paso lo haremos dentro del usuario que hemos creado en cada máquina.</p>
<p><strong>oracle1</strong></p>
<div><pre><code>create database link linkdb1 connect to maquina2 identified by root using 'ORCL2';
</code></pre>
</div><p><img src="./../images/orcl-psql/11-orcl-orcl.png" alt="image"></p>
<p>Ejemplo de funcionamiento (veremos que le podemos hacer una consulta a la tabla <code>socios</code> que se encuentra en la máquina <code>oracle2</code> en el usuario <code>maquina2</code>).</p>
<p><img src="./../images/orcl-psql/12-orcl-orcl.png" alt="image"></p>
<p><strong>oracle2</strong></p>
<div><pre><code>create database link linkdb2 connect to maquina1 identified by root using 'ORCL1';
</code></pre>
</div><p><img src="./../images/orcl-psql/13-orcl-orcl.png" alt="image"></p>
<p>Ejemplo de funcionamiento (veremos que le podemos hacer una consulta a la tabla <code>peliculas</code> que se encuentra en la máquina <code>oracle1</code> en el usuario <code>maquina1</code>).</p>
<p><img src="./../images/orcl-psql/14-orcl-orcl.png" alt="image"></p>
<h2><i>Content not supported</i> PostgreSQL - PostgreSQL <i>Content not supported</i></h2>
<p>Aquí vamos a interconectar dos servidores Postgres. Yo tendré dos máquinas las cuales son postgres1(192.168.122.27) y postgres2(192.168.122.53).</p>
<p><font color="#800080"><strong>Paso 1</strong></font> Permitir acceso remoto</p>
<p>Para permitir el acceso remoto nos iremos al fichero postgresql.conf.</p>
<div><pre><code>sudo nano /etc/postgresql/13/main/postgresql.conf
</code></pre>
</div><p>Donde editaremos las línea de <code>listen_addresses</code>. Y la dejaremos así:</p>
<div><pre><code>listen_addresses = '*'          # what IP address(es) to listen on;
</code></pre>
</div><p>Después nos iremos al fichero <code>pg_hba.conf</code>.</p>
<div><pre><code>sudo nano /etc/postgresql/13/main/pg_hba.conf
</code></pre>
</div><p>Y escribiremos al final de este fichero las siguientes líneas:</p>
<div><pre><code>host    all     all     0.0.0.0/0       md5
host    all     all     ::/0    md5
</code></pre>
</div><p>Una vez hecho esto reiniciamos el servicio postgresql.</p>
<div><pre><code>sudo systemctl restart postgresql
</code></pre>
</div><p><strong>Este paso lo haremos en las dos máquinas</strong></p>
<p><font color="#800080"><strong>Paso 2</strong></font> Crearemos las bases de datos y sus respectivas tablas.</p>
<p><strong>postgres1</strong></p>
<p>Primero entraremos al usuario postgres.</p>
<div><pre><code>sudo su
</code></pre>
</div><hr>
<div><pre><code>su postgres
</code></pre>
</div><hr>
<div><pre><code>psql
</code></pre>
</div><p>Una vez dentro crearemos el usuario y la base de datos:</p>
<div><pre><code>postgres=# create user maquina1 with password 'root';
</code></pre>
</div><hr>
<div><pre><code>postgres=# create database db1;
</code></pre>
</div><hr>
<div><pre><code>postgres=# grant all privileges on database db1 to maquina1;
</code></pre>
</div><hr>
<div><pre><code>postgres=# \q
</code></pre>
</div><p>Una vez ya creados el usuario y la base de datos entraremos en ella para crear las tablas:</p>
<div><pre><code>psql -h localhost -U maquina1 -W -d db1
</code></pre>
</div><hr>
<div><pre><code>db1=&gt; create table peliculas (
    NombrePelicula varchar (20),
    Genero varchar (20),
    Director varchar (20),
    AnoEstreno varchar (4),
    constraint PK_1 primary key (NombrePelicula)
);
</code></pre>
</div><hr>
<div><pre><code>db1=&gt; INSERT INTO peliculas VALUES ('Dune','Ciencia-ficcion','Edwards','1984');
INSERT INTO peliculas VALUES ('Los Idiotas','Drama','Von Trier','1999');
INSERT INTO peliculas VALUES ('Kramer vs Kramer','Drama','Smith','1978');
INSERT INTO peliculas VALUES ('Mision Imposible','Ciencia-ficcion','Johnson','1998');
INSERT INTO peliculas VALUES ('Mi nombre es Joe','Drama','Loach','1995');
INSERT INTO peliculas VALUES ('Rompiendo las olas','Drama','Von Trier','1997');
INSERT INTO peliculas VALUES ('Los Otros','Suspense','Amenabar','2001');
</code></pre>
</div><p><img src="./../images/orcl-psql/1-psql-psql.png" alt="image"></p>
<p><strong>postgres2</strong></p>
<p>Ahora haremos lo mismo con la otra máquina.</p>
<div><pre><code>sudo su
</code></pre>
</div><hr>
<div><pre><code>su postgres
</code></pre>
</div><hr>
<div><pre><code>psql
</code></pre>
</div><p>Una vez dentro crearemos el usuario y la base de datos:</p>
<div><pre><code>postgres=# create user maquina2 with password 'root';
</code></pre>
</div><hr>
<div><pre><code>postgres=# create database db2;
</code></pre>
</div><hr>
<div><pre><code>postgres=# grant all privileges on database db2 to maquina2;
</code></pre>
</div><hr>
<div><pre><code>postgres=# \q
</code></pre>
</div><p>Una vez ya creados el usuario y la base de datos entraremos en ella para crear las tablas:</p>
<div><pre><code>psql -h localhost -U maquina2 -W -d db2
</code></pre>
</div><hr>
<div><pre><code>db1=&gt; create table socios (
    DNI varchar (10),
    Nombre varchar (20),
    Direccion varchar (20),
    constraint PK_2 primary key (DNI)
);
</code></pre>
</div><hr>
<div><pre><code>db1=&gt; INSERT INTO socios VALUES ('111-A','David','Sevilla Este');
INSERT INTO socios VALUES ('222-B','Mariano','Los Remedios');
INSERT INTO socios VALUES ('333-C','Raul','Triana');
INSERT INTO socios VALUES ('444-D','Rocio','La Oliva');
INSERT INTO socios VALUES ('555-E','Marilo','Triana');
INSERT INTO socios VALUES ('666-F','Benjamin','Montequinto');
INSERT INTO socios VALUES ('777-G','Carlos','Los Remedios');
INSERT INTO socios VALUES ('888-H','Manolo','Montequinto');
</code></pre>
</div><p><img src="./../images/orcl-psql/2-psql-psql.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 3</strong></font> Interconexiones.</p>
<p><strong>postgres1</strong></p>
<p>Primero entraremos en la base de datos para crear la extensión del link. Esto lo haremos en el usuario postgres.</p>
<div><pre><code>psql -d db1
</code></pre>
</div><hr>
<div><pre><code>db1=# create extension dblink;
</code></pre>
</div><hr>
<div><pre><code>db1=# \q
</code></pre>
</div><p><img src="./../images/orcl-psql/3-psql-psql.png" alt="image"></p>
<div><pre><code>psql -h localhost -U maquina1 -W -d db1
</code></pre>
</div><hr>
<div><pre><code>db1=&gt; select * from dblink('dbname=db2 host=192.168.122.53 user=maquina2 password=root', 'select * from socios') as socios (dni varchar, nombre varchar, direccion varchar);
</code></pre>
</div><p><img src="./../images/orcl-psql/4-psql-psql.png" alt="image"></p>
<p><strong>postgres2</strong></p>
<p>Repetiremos los pasos pero ahora en la otra máquina.</p>
<div><pre><code>psql -d db2
</code></pre>
</div><hr>
<div><pre><code>db1=# create extension dblink;
</code></pre>
</div><hr>
<div><pre><code>db1=# \q
</code></pre>
</div><p><img src="./../images/orcl-psql/5-psql-psql.png" alt="image"></p>
<div><pre><code>psql -h localhost -U maquina2 -W -d db2
</code></pre>
</div><hr>
<div><pre><code>db2=&gt; select * from dblink('dbname=db1 host=192.168.122.27 user=maquina1 password=root', 'select * from peliculas') as peliculas (nombrepelicula varchar, genero varchar, director varchar, anoestreno varchar);
</code></pre>
</div><p><img src="./../images/orcl-psql/6-psql-psql.png" alt="image"></p>
<p>Como podemos comprobar ya podemos realizar interconexiones entre ambas máquinas.</p>
<h2><i>Content not supported</i> Oracle - PostgreSQl <i>Content not supported</i></h2>
<p>Aquí vamos a interconectar una máquina Oracle y una máquina PostgreSQL, las cuales son las que creamos para las otras interconexiones. Yo tendré dos máquinas las cuales son oracle2(192.168.122.144) y postgres1(192.168.122.27).</p>
<p><font color="#800080"><strong>Paso 1</strong></font> Instalación de la paquetería necesaria.</p>
<div><pre><code>sudo apt install odbc-postgresql
</code></pre>
</div><p><font color="#800080"><strong>Paso 2</strong></font> Configuramos el driver ODBC.</p>
<p>Una vez instalada la paqueteria accederemos al archivo <code>/etc/odbcinst.ini</code>, en el que está la configuración para los controladores unixODBC y lo dejaremos como se muestra en la imagen:</p>
<p><img src="./../images/orcl-psql/1-orcl-psql.png" alt="image"></p>
<p>Crearemos un DSN llamado <code>odbc.ini</code> que determinará la conexión al gestor que especifiquemos.</p>
<p><img src="./../images/orcl-psql/2-orcl-psql.png" alt="image"></p>
<p>Ya tendremos configurado el driver de ODBC, probaremos el resultado.</p>
<p><img src="./../images/orcl-psql/3-orcl-psql.png" alt="image"></p>
<p><strong>NOTA</strong>: <code>Como podemos observar en la captura anterior he creado una nueva tabla que es la que comprobaremos en el funcionamiento.</code></p>
<p>Como podemos comprobar la configuración del driver ha sido exitosa, ahora procederemos a configurar Oracle para que pueda usar dicho driver.</p>
<p><font color="#800080"><strong>Paso 3</strong></font> Configuración de Oracle para la interconexión.</p>
<p>Si todo ha ido bien hasta este punto, vamos a crear el fichero initPSQLU.ora. Este fichero nos permitirá crear el enlace con postgresql.</p>
<div><pre><code>sudo nano /opt/oracle/product/19c/dbhome_1/hs/admin/initPSQLU.ora
</code></pre>
</div><p>Y escribiremos lo siguiente:</p>
<div><pre><code>HS_FDS_CONNECT_INFO = PSQLU
HS_FDS_TRACE_LEVEL = Debug
HS_FDS_SHAREABLE_NAME = /usr/lib/x86_64-linux-gnu/odbc/psqlodbcw.so
HS_LANGUAGE = AMERICAN_AMERICA.WE8ISO8859P1
set ODBCINI=/etc/odbc.ini
</code></pre>
</div><p>Después configuraremos el fichero listener:</p>
<div><pre><code>sudo nano /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora
</code></pre>
</div><p><img src="./../images/orcl-psql/4-orcl-psql.png" alt="image"></p>
<p>Y también configuraremos el fichero tnsnames:</p>
<div><pre><code>sudo nano /opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora
</code></pre>
</div><p><img src="./../images/orcl-psql/5-orcl-psql.png" alt="image"></p>
<p>Después de haber configurado estos dos ficheros reiniciamos el servicio.</p>
<div><pre><code>lsnrctl stop
</code></pre>
</div><hr>
<div><pre><code>lsnrctl start
</code></pre>
</div><p><img src="./../images/orcl-psql/6-orcl-psql.png" alt="image"></p>
<p>Y una vez hecho esto accedemos a nuestro usuario oracle y crearemos un enlace para comprobar la configuración.</p>
<p>Creamos el link:</p>
<p><img src="./../images/orcl-psql/7-orcl-psql.png" alt="image"></p>
<p>Y comprobamos el funcionamiento:</p>
<p><img src="./../images/orcl-psql/8-orcl-psql.png" alt="image"></p>
<h2><i>Content not supported</i> PostgreSQL - Oracle <i>Content not supported</i></h2>
<p>Aquí vamos a interconectar una máquina PostgreSQL y una máquina Oracle, las cuales son las que creamos para las otras interconexiones. Yo tendré dos máquinas las cuales son postgres1(192.168.122.27) y oracle2(192.168.122.144).</p>
<p><font color="#800080"><strong>Paso 1</strong></font> Instalamos la paquetería requerida.</p>
<div><pre><code>sudo apt install libaio1 postgresql-server-dev-all build-essential git
</code></pre>
</div><p><font color="#800080"><strong>Paso 2</strong></font> Descargamos los paquetes clientes de Oracle.</p>
<p>Accedemos al usuario de postgres y descargamos los paquetes del sitio oficial de Oracle:</p>
<div><pre><code>su - postgres
</code></pre>
</div><hr>
<div><pre><code>wget https://download.oracle.com/otn_software/linux/instantclient/211000/instantclient-basic-linux.x64-21.1.0.0.0.zip
</code></pre>
</div><hr>
<div><pre><code>wget https://download.oracle.com/otn_software/linux/instantclient/211000/instantclient-sdk-linux.x64-21.1.0.0.0.zip
</code></pre>
</div><hr>
<div><pre><code>wget https://download.oracle.com/otn_software/linux/instantclient/211000/instantclient-sqlplus-linux.x64-21.1.0.0.0.zip
</code></pre>
</div><p>Descomprimimos los archivos con unzip:</p>
<div><pre><code>unzip instantclient-basic-linux.x64-21.1.0.0.0.zip
</code></pre>
</div><hr>
<div><pre><code>unzip instantclient-sqlplus-linux.x64-21.1.0.0.0.zip
</code></pre>
</div><hr>
<div><pre><code>unzip instantclient-sdk-linux.x64-21.1.0.0.0.zip
</code></pre>
</div><p>Después de descomprimir los 3 archivos se nos creará una carpeta llamada <code>instantclient_21_1</code>.</p>
<p><font color="#800080"><strong>Paso 3</strong></font> Estableceremos las nuevas variables de entorno.</p>
<div><pre><code>export ORACLE_HOME=/var/lib/postgresql/instantclient_21_1
</code></pre>
</div><hr>
<div><pre><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME
</code></pre>
</div><hr>
<div><pre><code>export PATH=$PATH:$ORACLE_HOME
</code></pre>
</div><p>Para comprobar si hemos puesto correctamente las variables utilizaremos el comando wich que nos deberá devolver la ruta.</p>
<div><pre><code>cd /var/lib/
</code></pre>
</div><hr>
<div><pre><code>which sqlplus
</code></pre>
</div><p><img src="./../images/orcl-psql/1-psql-orcl.png" alt="image"></p>
<p>Y una vez hecho esto ya nos podremos conectar remotamente:</p>
<p><img src="./../images/orcl-psql/2-psql-orcl.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 4</strong></font> Compilación de oracle_fdw.</p>
<p>Descargamos el repositorio de GitHub con el código fuente.</p>
<div><pre><code>wget https://github.com/laurenz/oracle_fdw/archive/refs/tags/ORACLE_FDW_2_3_0.zip
</code></pre>
</div><hr>
<div><pre><code>unzip ORACLE_FDW_2_3_0.zip
</code></pre>
</div><p>Para evitar futuros problemas, le cambiamos el nombre al directorio extraído por oracle_fdw:</p>
<div><pre><code>mv oracle_fdw-ORACLE_FDW_2_3_0/ oracle_fdw
</code></pre>
</div><p>Entramos en el directorio oracle_fdw, compilamos el código y realizamos la instalación:</p>
<div><pre><code>cd oracle_fdw
</code></pre>
</div><hr>
<div><pre><code>make
</code></pre>
</div><hr>
<div><pre><code>make install
</code></pre>
</div><p>Al entrar en la base de datos e intentar crear la extensión, nos informarán de que el sistema no encuentra las librerías de oracle:</p>
<p><img src="./../images/orcl-psql/3-psql-orcl.png" alt="image"></p>
<p>Para solucionar esto crearemos el fichero <code>/etc/ld.so.conf.d/oracle.conf</code> y dentro añadiremos las rutas de los directorios que contengan los ficheros .so:</p>
<div><pre><code>sudo nano /etc/ld.so.conf.d/oracle.conf
</code></pre>
</div><hr>
<div><pre><code>/var/lib/postgresql/instantclient_21_1
/usr/share/postgresql/11/extension
</code></pre>
</div><p>Ejecutamos el comando ldconfig, con el que se crearán los vínculos y caché necesarios a las librerías que se encuentren en los directorios que hemos especificado en el fichero creado, y reiniciamos el servicio de PostgreSQL:</p>
<div><pre><code>sudo ldconfig
</code></pre>
</div><hr>
<div><pre><code>sudo systemctl restart postgresql
</code></pre>
</div><p>Y después de hacer esto ya podremos crear la extensión:</p>
<p><img src="./../images/orcl-psql/4-psql-orcl.png" alt="image"></p>
<p>Después creamos un nuevo esquema al que importamos las tablas de la base de datos Oracle:</p>
<p><img src="./../images/orcl-psql/5-psql-orcl.png" alt="image"></p>
<p>Como el esquema que hemos creado está vacío, definiremos un servidor remoto que use la extensión que hemos generado antes, indicando la dirección IP y la base de datos que tenemos en Oracle:</p>
<p><img src="./../images/orcl-psql/6-psql-orcl.png" alt="image"></p>
<p>Luego de esto, necesitamos mapear nuestro usuario local a uno existente en Oracle con los privilegios necesarios para acceder a las tablas:</p>
<p><img src="./../images/orcl-psql/7-psql-orcl.png" alt="image"></p>
<p>Otorgamos a nuestro usuario de PostgreSQL los privilegios para utilizar el esquema de Oracle y el servidor remoto:</p>
<p><img src="./../images/orcl-psql/8-psql-orcl.png" alt="image"></p>
<p>Y una vez hecho todo esto importamos las tablas existentes en el esquema remoto al local:</p>
<p><img src="./../images/orcl-psql/9-psql-orcl.png" alt="image"></p>
<p>Y hacemos la prueba del funcionamiento:</p>
<p><img src="./../images/orcl-psql/10-psql-orcl.png" alt="image"></p>
<p>¡Gracias!</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">PostgreSQL en Debian 11 Bullseye</title>
    <id>https://github.com/oscarlucas22/practicas/postgresql/</id>
    <link href="https://github.com/oscarlucas22/practicas/postgresql/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="postgresql-en-debian-11-bullseye"> PostgreSQL en Debian 11 Bullseye</h1>
<p><img src="./../images/ABD/postgresql.png" alt="image"></p>
<h2 id="instalacion-de-postgresql-en-debian-11-bullseye"> Instalación de PostgreSQL en Debian 11 Bullseye</h2>
<p><font color="#800080"><strong>Paso 1</strong></font> Actualizar el sistema</p>
<div><pre><code>sudo apt update &amp;&amp; sudo apt upgrade -y
</code></pre>
</div><p><font color="#800080"><strong>Paso 2</strong></font> Instalamos postgresql</p>
<div><pre><code>sudo apt install -y postgresql*
</code></pre>
</div><p>Esto tardará un poco</p>
<p><font color="#800080"><strong>Paso 3</strong></font> Comprobamos el estado del servicio</p>
<div><pre><code>systemctl status postgresql
</code></pre>
</div><p><img src="./../images/ABD/1-postgre.png" alt="image"></p>
<p>En el caso que no estuviera iniciado lo iniciaremos</p>
<div><pre><code>systemctl start postgresql
</code></pre>
</div><p><font color="#800080"><strong>Paso 4</strong></font> Instalamos el cliente</p>
<div><pre><code>sudo apt install -y postgresql-client
</code></pre>
</div><h3 id="comandos-de-navegacion-y-consulta-de-informacion"> Comandos de navegación y consulta de información</h3>
<ul>
<li>
<p><code>\c</code> Saltar entre bases de datos</p>
</li>
<li>
<p><code>\l</code> Listar base de datos disponibles</p>
</li>
<li>
<p><code>\dt</code> Listar las tablas de la base de datos</p>
</li>
<li>
<p><code>\d &lt;nombre_tabla&gt;</code> Describir una tabla</p>
</li>
<li>
<p><code>\dn</code> Listar los esquemas de la base de datos actual</p>
</li>
<li>
<p><code>\df</code> Listar las funciones disponibles de la base de datos actual</p>
</li>
<li>
<p><code>\dv</code> Listar las vistas de la base de datos actual</p>
</li>
<li>
<p><code>\du</code> Listar los usuarios y sus roles de la base de datos actual</p>
</li>
</ul>
<h3 id="comandos-de-inspeccion-y-ejecucion"> Comandos de inspección y ejecución</h3>
<ul>
<li>
<p><code>\g</code> Volver a ejecutar el comando ejecutando justo antes</p>
</li>
<li>
<p><code>\s</code> Ver el historial de comandos ejecutados</p>
</li>
<li>
<p><code>\s &lt;nombre_archivo&gt;</code> Si se quiere guardar la lista de comandos ejecutados en un archivo de texto plano</p>
</li>
<li>
<p><code>\i &lt;nombre_archivo&gt;</code> Ejecutar los comandos desde un archivo</p>
</li>
<li>
<p><code>\e</code> Permite abrir un editor de texto plano, escribir comandos y ejecutar en lote. \e abre el editor de texto, escribir allí todos los comandos, luego guardar los cambios y cerrar, al cerrar se ejecutarán todos los comandos guardados.</p>
</li>
<li>
<p><code>\ef</code> Equivalente al comando anterior pero permite editar también funciones en PostgreSQL</p>
</li>
</ul>
<h3 id="comandos-para-debug-y-optimizacion"> Comandos para debug y optimización</h3>
<ul>
<li><code>\timing</code> Activar <code>/</code> Desactivar el contador de tiempo por consulta</li>
</ul>
<h3 id="comandos-para-cerrar-la-consola"> Comandos para cerrar la consola</h3>
<ul>
<li><code>\q</code> Cerrar la consola</li>
</ul>
<h2 id="creacion-de-usuario"> Creación de usuario</h2>
<p>Para crear el usuario ingresamos primero a postgres:</p>
<div><pre><code>sudo -u postgres psql
</code></pre>
</div><p><strong>Crearemos el usuario:</strong></p>
<div><pre><code>CREATE USER lucas PASSWORD 'TU_PASSWORD';
</code></pre>
</div><p><strong>Asignar permisos de superusuario a un usuario</strong></p>
<div><pre><code>ALTER ROLE lucas WITH SUPERUSER;
</code></pre>
</div><p><strong>Cambiar la contraseña de un usuario</strong></p>
<div><pre><code>ALTER ROLE lucas WITH PASSWORD 'NUEVO_PASSWORD';
</code></pre>
</div><p><strong>Crear una base de datos con un usuario específico como propietario</strong></p>
<div><pre><code>CREATE DATABASE lucas_db WITH OWNER lucas;
</code></pre>
</div><p><strong>Asignar todos los permisos a un usuario a una base de datos existente</strong></p>
<div><pre><code>GRANT ALL PRIVILEGES ON DATABASE lucas_db TO lucas;
</code></pre>
</div><p>Ejemplo práctico:</p>
<p><img src="./../images/ABD/23-postgre.png" alt="image"></p>
<h2 id="borrar-usuario"> Borrar usuario</h2>
<div><pre><code>su - postgres
</code></pre>
</div><p>En el caso que queramos borrar solo el usuario antes debemos revocarle los permisos sobre la base de datos</p>
<div><pre><code>revoke all on database nombre-db from nombre-user;
</code></pre>
</div><hr>
<div><pre><code>drop user nombre-user;
</code></pre>
</div><h2 id="acceso-remoto"> Acceso remoto</h2>
<p><font color="#800080"><strong>Paso 1</strong></font> Acceso remoto</p>
<div><pre><code>sudo nano /etc/postgresql/13/main/postgresql.conf
</code></pre>
</div><p>Busca la siguiente línea:</p>
<p><code>#listen_addresses = 'localhost' # what IP address(es) to listen on;</code></p>
<p>Y sustituye 'localhost' por '*':</p>
<p><img src="./../images/ABD/2-postgre.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 2</strong></font> Activamos contraseñas de red</p>
<p>El siguiente paso es configurar el fichero &quot;pg_hba.conf&quot; para permitir el acceso remoto desde cualquier dirección. Para ello ejecuta lo siguiente:</p>
<div><pre><code>sudo nano /etc/postgresql/13/main/pg_hba.conf
</code></pre>
</div><p>Añade al final del fichero las siguientes líneas:</p>
<div><pre><code>host    all      all              0.0.0.0/0                    md5
host    all      all              ::/0                         md5
</code></pre>
</div><p><font color="#800080"><strong>Paso 3</strong></font> Reiniciamos el servicio</p>
<div><pre><code>sudo systemctl restart postgresql.service
</code></pre>
</div><p><font color="#800080"><strong>Paso 4</strong></font> Añadimos regla de firewall</p>
<div><pre><code>sudo ufw allow postgresql
</code></pre>
</div><hr>
<p><font color="#800080"><strong>Paso 5</strong></font> Nos conectamos</p>
<div><pre><code>psql -h ip-server -U nombre-user -p nombre-db
</code></pre>
</div><p>Ejemplo:</p>
<p><img src="./../images/ABD/3-postgre.png" alt="image"></p>
<h2 id="instalacion-herramienta-de-administracion-web"> Instalación herramienta de administración web</h2>
<p>En mi caso vamos a instalar la herramienta <code>pgadmin4</code></p>
<p><font color="#800080"><strong>Paso 1</strong></font> Instala el paquete gnupg2 mediante el comando apt que aparece a continuación</p>
<div><pre><code>apt install gnupg gnupg2
</code></pre>
</div><p><font color="#800080"><strong>Paso 2</strong></font> A continuación, ejecuta el siguiente comando para añadir el repositorio de pgAdmin para el sistema Debian.</p>
<div><pre><code>echo &quot;deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main&quot;\ | sudo tee /etc/apt/sources.list.d/pgadmin4.list
</code></pre>
</div><p><font color="#800080"><strong>Paso 3</strong></font> Añade la clave gpg del repositorio pgAdmin utilizando el siguiente comando</p>
<div><pre><code>curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add
</code></pre>
</div><p><font color="#800080"><strong>Paso 4</strong></font> Refresca y actualiza todos los repositorios utilizando el siguiente comando</p>
<div><pre><code>sudo apt update
</code></pre>
</div><p>Ahora estás listo para instalar pgAdmin en el sistema Debian.</p>
<h3 id="instalacion-y-configuracion-de-pgadmin4-en-debian-11"> Instalación y configuración de pgAdmin4 en Debian 11</h3>
<p><font color="#800080"><strong>Paso 1</strong></font> Para instalar pgAdmin en modo servidor, instala el paquete ‘pgadmin4-web’ utilizando el comando apt que aparece a continuación.</p>
<div><pre><code>apt install pgadmin4-web
</code></pre>
</div><p>Escribe <code>y</code> y pulsa <code>Enter</code> para continuar la instalación.</p>
<p><font color="#800080"><strong>Paso 2</strong></font> Si la instalación se ha completado, ejecuta el siguiente comando para configurar la cuenta de usuario de pgAdmin4 y la configuración del host virtual de apache.</p>
<div><pre><code>/usr/pgadmin4/bin/setup-web.sh
</code></pre>
</div><p>Escribe el correo electrónico y la contraseña del usuario para crear un nuevo usuario pgAdmin, y luego pulsa <code>Enter</code>.</p>
<p><img src="./../images/ABD/4-postgre.png" alt="image"></p>
<p>Después, se te pedirá que configures el servidor web Apache, escribe <code>y</code>, y pulsa <code>Enter</code>.</p>
<p>Ahora la instalación de pgAdmin es accesible en la ruta URL <code>/pgadmin4</code>.</p>
<p>El script de instalación <code>setup-web.sh</code> creará y activará automáticamente la configuración de apache en el directorio <code>/etc/apache2/conf-enabled</code>. Puedes comprobarlo con el siguiente comando.</p>
<p>A continuación se muestra la configuración que verás.</p>
<p><img src="./../images/ABD/5-postgre.png" alt="image"></p>
<h3 id="verificar-la-instalacion-de-pgadmin"> Verificar la instalación de pgAdmin</h3>
<p><font color="#800080"><strong>Paso 1</strong></font> Abre tu navegador web y escribe la dirección IP del servidor o el nombre del dominio seguido de la ruta ‘/pgadmin4’ como se indica a continuación.</p>
<div><pre><code>tu-ip/pgadmin4
</code></pre>
</div><p><font color="#800080"><strong>Paso 2</strong></font> Si la instalación se ha realizado correctamente, verás la página de inicio de sesión de pgadmin4 como se indica a continuación.</p>
<p><img src="./../images/ABD/6-postgre.png" alt="image"></p>
<p>Escribe tu usuario de acceso y tu correo electrónico, y luego haz clic en el botón <code>Login</code>.</p>
<p>Ahora verás el panel de control de pgadmin4 como se indica a continuación.</p>
<p><img src="./../images/ABD/7-postgre.png" alt="image"></p>
<h3 id="conectar-con-el-servidor-postgresql-con-pgadmin4"> Conectar con el servidor PostgreSQL con pgAdmin4</h3>
<p>Después de entrar en el tablero de pgAdmin, añadirás una nueva conexión a tu servidor PostgreSQL.</p>
<p><font color="#800080"><strong>Paso 1</strong></font> En el tablero de pgAdmin, haz clic en el icono <code>Añadir nuevo servidor</code></p>
<p><font color="#800080"><strong>Paso 2</strong></font> Aparecerá una pequeña ventana emergente.</p>
<p>En la pestaña <code>General</code>, escribe un nuevo <code>Nombre</code> de tu conexión.</p>
<p><img src="./../images/ABD/8-postgre.png" alt="image"></p>
<p>Para esta guía, daremos a la nueva conexión el nombre de <code>local</code>.</p>
<p><font color="#800080"><strong>Paso 3</strong></font> Pasa a la pestaña <code>Conexión</code> y escribe tus datos de host PostgreSQL, base de datos, usuario y contraseña.</p>
<p>Para este ejemplo, utilizaremos el servidor PostgreSQL local con el usuario <code>lucas</code> para gestionar una base de datos predeterminada <code>postgres</code>.</p>
<p><img src="./../images/ABD/9-postgre.png" alt="image"></p>
<p>Después, haz clic en el botón <code>Guardar</code> para guardar una nueva conexión.</p>
<p><font color="#800080"><strong>Paso 4</strong></font> Si la conexión se realiza con éxito, verás una página similar a la siguiente. En caso contrario, verás un error</p>
<p><img src="./../images/ABD/10-postgre.png" alt="image"></p>
<p>Como puedes ver en la parte inferior de la captura de pantalla, el usuario <code>lucas</code> está conectado a la base de datos <code>postgres</code> con la aplicación <code>pgAdmin4</code>, y el estado de la conexión es <code>activò</code>.</p>
<h3 id="creacion-de-un-nuevo-usuario-en-pgadmin4"> Creación de un nuevo usuario en pgAdmin4</h3>
<p>En esta etapa, vas a crear un nuevo usuario de PostgreSQL utilizando la herramienta pgAdmin4.</p>
<p><font color="#800080"><strong>Paso 1</strong></font> Haz clic con el botón derecho del ratón sobre el nombre de la conexión en el menú <code>local =&gt; Crear =&gt; Rol de inicio de sesión/grupo..</code>.</p>
<p><img src="./../images/ABD/11-postgre.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 2</strong></font> En la pestaña <code>General</code>, escribe el nuevo usuario que quieres crear. Para este ejemplo, crearás un nuevo usuario <code>prueba</code>.</p>
<p><img src="./../images/ABD/12-postgre.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 3</strong></font> Pasa a la pestaña <code>Definición</code> y escribe la contraseña de tu usuario.</p>
<p><img src="./../images/ABD/13-postgre.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 4</strong></font> Ve a la pestaña <strong>«Privilegios»</strong> y activa los privilegios que necesites.</p>
<p><img src="./../images/ABD/14-postgre.png" alt="image"></p>
<p>Ahora haz clic en el botón <code>Guardar</code>.</p>
<p><font color="#800080"><strong>Paso 5</strong></font> Para verificar tu nuevo usuario, haz clic en el menú <code>Roles de inicio de sesión/grupo</code> de la izquierda, y luego haz clic en el <code>prueba</code> que acabas de crear.</p>
<p><img src="./../images/ABD/15-postgre.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 6</strong></font> Haz clic en la pestaña<code>Propiedades</code> de la página y obtendrás detalles del usuario como en la captura de pantalla superior.</p>
<h3 id="creacion-de-una-nueva-base-de-datos-en-pgadmin4"> Creación de una nueva base de datos en pgAdmin4</h3>
<p>En esta etapa, crearás una nueva base de datos desde el panel de control de pgAdmin.</p>
<p><font color="#800080"><strong>Paso 1</strong></font> Haz clic con el botón derecho del ratón en el menú del nombre de la conexión <code>local =&gt; Crear =&gt; Base de datos..</code>.</p>
<p><img src="./../images/ABD/16-postgre.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 2</strong></font> En la pestaña <code>General</code>, escribe el nombre de tu nueva base de datos y elige el usuario propietario de la misma. Para este ejemplo, crearás una nueva base de datos <code>pruebadb</code> y harás al usuario <code>prueba</code> como propietario.</p>
<p><img src="./../images/ABD/17-postgre.png" alt="image"></p>
<p>Ahora haz clic en el botón <code>Guardar</code>.</p>
<p><font color="#800080"><strong>Paso 3</strong></font> Para verificar tu nueva base de datos, haz clic en el menú <code>Bases de datos</code> de la izquierda, y luego haz clic en la base de datos <code>pruebadb</code> que acabas de crear.</p>
<p><img src="./../images/ABD/18-postgre.png" alt="image"></p>
<p>Haz clic en la pestaña <code>Propiedades</code> de la página y obtendrás los detalles de la base de datos <code>pruebadb</code> como en la captura de pantalla superior.</p>
<h3 id="verificar-la-conexion-del-usuario"> Verificar la conexión del usuario</h3>
<p>Después de crear un nuevo usuario y una base de datos utilizando el pgAdmin4, crearás una nueva conexión PostgreSQL en el pgAdmin4 utilizando el usuario <code>prueba</code> y la base de datos <code>pruebadb</code>.</p>
<p><font color="#800080"><strong>Paso 1</strong></font> Vuelve al panel de control de pgAdmin4 y haz clic en el icono <code>Añadir nuevo servidor</code>.</p>
<p><img src="./../images/ABD/19-postgre.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 2</strong></font> En la pestaña <code>General</code>, escribe el nombre de la nueva conexión como <code>prueba-connection</code>, como se indica a continuación.</p>
<p><img src="./../images/ABD/20-postgre.png" alt="image"></p>
<p><font color="#800080"><strong>Paso 3</strong></font> Pasa a la pestaña <code>Conexión</code> y escribe los detalles de la nueva conexión. El host es <code>127.0.0.1</code> con el usuario <code>prueba</code>, y gestionará la base de datos <code>pruebadb</code>, y no olvides escribir la contraseña del usuario <code>prueba</code>.</p>
<p><img src="./../images/ABD/21-postgre.png" alt="image"></p>
<p>Ahora haz clic en el botón <code>Guardar</code>.</p>
<p><font color="#800080"><strong>Paso 4</strong></font> Si tus credenciales de la base de datos son correctas, verás una página similar a la siguiente.</p>
<p><img src="./../images/ABD/22-postgre.png" alt="image"></p>
<p>Como puedes ver en la parte inferior de la captura de pantalla, el usuario <code>prueba</code> está conectado a la base de datos <code>pruebadb</code> con la aplicación <code>pgAdmin4</code>, y el estado de la conexión es <code>activo</code>.</p>
<p>¡Gracias!</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">USUARIOS</title>
    <id>https://github.com/oscarlucas22/practicas/usuarios/</id>
    <link href="https://github.com/oscarlucas22/practicas/usuarios/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="usuarios"> USUARIOS</h1>
<h3 id="mysql"> MySQL</h3>
<p>Antes de comenzar a realizar los ejercicios crearemos una base de datos y un usuario de prueba para la realización de los ejercicios:</p>
<div><pre><code>create database usuarios;
</code></pre>
</div><hr>
<div><pre><code>create table Tabla(
	id mediumint not null auto_increment,
	asignatura varchar(30) not null,
	profesor varchar(30),
	primary key (id) 
	);
</code></pre>
</div><hr>
<div><pre><code>insert into Tabla (asignatura, profesor) values
	(&quot;ASO&quot;, &quot;Rafa&quot;),
	(&quot;ABD&quot;, &quot;Raul&quot;),
	(&quot;EMP&quot;, &quot;Rosa&quot;),
	(&quot;HLC&quot;, &quot;Jose&quot;),
	(&quot;IAW&quot;, &quot;Jose&quot;),
	(&quot;SAD&quot;, &quot;Raul&quot;),
	(&quot;SRI&quot;, &quot;Jose&quot;);
</code></pre>
</div><hr>
<div><pre><code>create user 'permisosuser'@'localhost' identified by 'root';
</code></pre>
</div><p><img src="./../images/SAD/usuarios/0-mysql-usuarios.png" alt="image"></p>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Averigua que privilegios de sistema hay en MySQL y como se asignan a un usuario.</strong></p>
<p>En MySQL existen cinco niveles distintos de privilegios:</p>
<ul>
<li>
<p><strong>Globales</strong>: Son los que se aplican al conjunto de todas las bases de datos en un servidor.</p>
</li>
<li>
<p><strong>De base de datos</strong>: Son los que se refieren a bases de datos indoviduales, y a todos los objetos que contiene cada base de datos.</p>
</li>
<li>
<p><strong>De tabla</strong>: Son los que se aplican a las tablas individuales, y por lo tanto a todas las columnas de esa tabla.</p>
</li>
<li>
<p><strong>De columna</strong>: Son los que se aplican a una columna en una tabla concreta.</p>
</li>
<li>
<p><strong>De rutina</strong>: Son los que se aplican a los procedimientos almacenados.</p>
</li>
</ul>
<p>Privilegios:</p>
<p><img src="./../images/SAD/usuarios/1-mysql-usuarios.png" alt="image"></p>
<ul>
<li>
<p>Para asignar privilegios a un usuario:</p>
<p>GRANT &quot;privilegio&quot; ON <em>.</em> TO &quot;nombre_usuario&quot;@&quot;localhost&quot; identified by &quot;password&quot;.</p>
</li>
</ul>
<p><img src="./../images/SAD/usuarios/1.1-mysql-usuarios.png" alt="image"></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>Averigua cual es la forma de asignar y revocar privilegios sobre una tabla concreta en MySQL.</strong></p>
<p><em><strong>asignar permisos en una tabla concreta</strong></em></p>
<div><pre><code>grant select on testdeusuarios.mitabla to 'permisosuser'@'localhost';
</code></pre>
</div><hr>
<div><pre><code>SHOW GRANTS FOR 'permisosuser'@'localhost';
</code></pre>
</div><p><img src="./../images/SAD/usuarios/2-mysql-usuarios.png" alt="image"></p>
<p><em><strong>revocar permisos en una tabla concreta</strong></em></p>
<div><pre><code>revoke all privileges on testdeusuarios.mitabla from 'permisosuser'@'localhost';
</code></pre>
</div><hr>
<div><pre><code>SHOW GRANTS FOR 'permisosuser'@'localhost';
</code></pre>
</div><p><img src="./../images/SAD/usuarios/2.1-mysql-usuarios.png" alt="image"></p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>Averigua si existe el concepto de rol en MySQL y señala las diferencias con los roles de ORACLE.</strong></p>
<p>Si, en MySQL existen los roles.</p>
<p>Aquí un ejemplo:</p>
<p><img src="./../images/SAD/usuarios/3-mysql-usuarios.png" alt="image"></p>
<p><em><strong>diferencias con los roles de ORACLE.</strong></em></p>
<p>Los roles son muy similares pero ya que MySQL los ha implementado hace muy poco están algo menos desarrollados que en Oracle.</p>
<p>Un ejemplo seria que en Oracle existen roles que se utilizan para el uso de aplicaciones, también existen roles locales, externos o globales, y además se puede aumentar la seguridad del uso de roles añadiendoles contraseñas que permiten concretar aún más las funciones del rol que queramos crear.</p>
<p><font color="#00ff00"><strong>4.</strong></font> <strong>Averigua si existe el concepto de perfil como conjunto de límites sobre el uso de recursos o sobre la contraseña en MySQL y señala las diferencias con los perfiles de ORACLE.</strong></p>
<p><em><strong>MySQL:</strong></em></p>
<p>Una forma de controlar el uso de recursos en servidores MySQL es mediante la asignación de un valor distinto a cero a la variable maxuserconnections del sistema. Sin embargo, este método es aplicado globalmente y no permite la gestión individual de cuentas. Además, solo limita el número de conexiones simultáneas permitidas por una sola cuenta y no el uso que un cliente puede hacer una vez conectado. Ambos tipos de control son relevantes para muchos administradores de MySQL, especialmente para los que trabajan en proveedores de servicios de internet (ISPs).</p>
<p><em><strong>¿Qué puede limitar MySQL?:</strong></em></p>
<ul>
<li>
<p>Número de consultas que un usuario pueda hacer cada hora.</p>
</li>
<li>
<p>Número de updates que un usuario puede hacer cada hora.</p>
</li>
<li>
<p>Número de veces que un usuario puede acceder al servidor a la hora.</p>
</li>
<li>
<p>Número de conexiones simultaneas permitidas para cada usuario.</p>
</li>
</ul>
<hr>
<p><em><strong>Oracle:</strong></em></p>
<p>La asignación de un perfil a un usuario es una forma de restringir el uso de recursos. Cada usuario puede tener un perfil único. Antes de asignar un perfil a un usuario, es necesario que exista en la base de datos. El proceso de asignación de un perfil se realiza durante la creación de un usuario mediante el comando create USER o al modificarlo con ALTER USER.</p>
<ul>
<li>
<p>Los recursos que controlamos son recursos del núcleo del sistema, tales como el uso de la CPU, la duración de la sesión, entre otros.</p>
</li>
<li>
<p>Además de los recursos del sistema, también se establecen límites para el uso de las claves de acceso, como la duración de las mismas, el número de intentos permitidos, la posibilidad de reutilizarlas, entre otros.</p>
</li>
</ul>
<p>En este caso, se vuelve a presentar el mismo problema. Aunque ambos sistemas tienen un mecanismo para controlar el uso de recursos por parte de los usuarios, MySQL presenta menos opciones de configuración.</p>
<p>En comparación con Oracle, la configuración de los recursos en Oracle es mucho más completa y te permite tener un control preciso sobre prácticamente cualquier recurso utilizado por el usuario.</p>
<p><font color="#00ff00"><strong>5.</strong></font> <strong>Realiza consultas al diccionario de datos de MySQL para averiguar todos los privilegios que tiene un usuario concreto.</strong></p>
<p>Le añadiremos varios privilegios a un usuario y procederemos a ver todos los privilegios que utiliza:</p>
<div><pre><code>SHOW GRANTS FOR 'permisosuser'@'localhost';
</code></pre>
</div><p><img src="./../images/SAD/usuarios/5-mysql-usuarios.png" alt="image"></p>
<p><font color="#00ff00"><strong>6.</strong></font> <strong>Realiza consultas al diccionario de datos en MySQL para averiguar qué usuarios pueden consultar una tabla concreta.</strong></p>
<div><pre><code>SELECT user, table_name FROM mysql.tables_priv;
</code></pre>
</div><p><img src="./../images/SAD/usuarios/6-mysql-usuarios.png" alt="image"></p>
<h3 id="oracle"> ORACLE</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>Realiza un procedimiento llamado PermisosdeAsobreB que reciba dos nombres de usuario y muestre los permisos que tiene el primero de ellos sobre objetos del segundo.</strong></p>
<div><pre><code>create or replace procedure PermisosdeAsobreB (p_userA in varchar2, p_userB in varchar2)
is
begin
	-- Obtener los permisos de p_userA sobre objetos de p_userB
	for var in (select privilege, owner, table_name from dba_tab_privs where grantee = p_userA and owner = p_userB group by privilege, owner, table_name)
	loop
	-- Mostrar los permisos encontrados
	dbms_output.put_line('Privilegio: ' || var.privilege || ', Objeto: ' || var.table_name || ', Propietario: ' || var.owner);
	end loop;
end;
/
</code></pre>
</div><hr>
<div><pre><code>exec PermisosdeAsobreB('SYSTEM', 'SYS');
</code></pre>
</div><p><font color="#00ff00"><strong>2.</strong></font> <strong>Realiza un procedimiento llamado MostrarInfoPerfil que reciba el nombre de un perfil y muestre su composición y los usuarios que lo tienen asignado.</strong></p>
<div><pre><code>create or replace procedure Infoperfil (p_perfil dba_profiles.profile%type)
is
	cursor cursor
	is
	select resource_name, limit from dba_profiles where profile = p_perfil;
begin
	dbms_output.put_line('Composicion de: '|| p_perfil);	
	for var in cursor loop
		dbms_output.put_line('Recurso: '|| var.resource_name || ' Limites: '|| var.limit);
	end loop;
end;
/

create or replace procedure MostrarInfoPerfil (p_perfil dba_profiles.profile%type)
is
	cursor cursor
	is
	select username from dba_users where profile = p_perfil;
begin 
	Infoperfil(p_perfil);
	for var in cursor loop
		dbms_output.put_line('Usuarios con ese perfil: '|| var.username);
	end loop;
end;
/
</code></pre>
</div><hr>
<div><pre><code>exec MostrarInfoPerfil('DEFAULT');
</code></pre>
</div><h2 id="parte-grupal"> Parte Grupal</h2>
<h3 id="caso-practico-1"> CASO PRÁCTICO 1:</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>(ORACLE, Postgres, MySQL) Crea un usuario llamado Becario y, sin usar los roles de ORACLE, dale los siguientes privilegios: (1,5 puntos)</strong></p>
<ul>
<li>
<p><strong>Conectarse a la base de datos.</strong></p>
</li>
<li>
<p><strong>Modificar el número de errores en la introducción de la contraseña de cualquier usuario.</strong></p>
</li>
<li>
<p><strong>Modificar índices en cualquier esquema (este privilegio podrá pasarlo a quien quiera)</strong></p>
</li>
<li>
<p><strong>Insertar filas en scott.emp (este privilegio podrá pasarlo a quien quiera)</strong></p>
</li>
<li>
<p><strong>Crear objetos en cualquier tablespace.</strong></p>
</li>
<li>
<p><strong>Gestión completa de usuarios, privilegios y roles.</strong></p>
</li>
</ul>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>(ORACLE, Postgres, MySQL) Escribe una consulta que obtenga un script para quitar el privilegio de borrar registros en alguna tabla de SCOTT a los usuarios que lo tengan.</strong></p>
<p><font color="#00ff00"><strong>3.</strong></font> <strong>(ORACLE) Crea un tablespace TS2 con tamaño de extensión de 256K. Realiza una consulta que genere un script que asigne ese tablespace como tablespace por defecto a los usuarios que no tienen privilegios para consultar ninguna tabla de SCOTT, excepto a SYSTEM.</strong></p>
<p><font color="#00ff00"><strong>4.</strong></font> <strong>(ORACLE, Postgres) Realiza un procedimiento que reciba un nombre de usuario y nos muestre cuántas sesiones tiene abiertas en este momento. Además, para cada una de dichas sesiones nos mostrará la hora de comienzo y el nombre de la máquina, sistema operativo y programa desde el que fue abierta.</strong></p>
<p><font color="#00ff00"><strong>5.</strong></font> <strong>(ORACLE) Realiza un procedimiento que muestre los usuarios que pueden conceder privilegios de sistema a otros usuarios y cuales son dichos privilegios.</strong></p>
<div><pre><code>create or replace procedure ver_usuario_simple(p_rol varchar2,p_privilegio varchar2)
is
	cursor c_usuarios is
	select GRANTEE from dba_role_privs where GRANTED_ROLE = p_rol;
begin
	for v_usuarios in c_usuarios loop
		dbms_output.put_line('Usuario: '||v_usuarios.GRANTEE);
		dbms_output.put_line('Privilegio: '||p_privilegio);
		dbms_output.put_line(chr(13));
	end loop;
end;
/

create or replace procedure ver_usuario_compuesto(p_rol varchar2,p_privilegio varchar2)
is
	cursor c_compuesto is
	select GRANTEE from dba_role_privs start with GRANTED_ROLE = p_rol connect by GRANTED_ROLE = prior GRANTEE;
	v_analizarprivilegio number(1):=0;
begin
	select count(*) into v_analizarprivilegio from role_sys_privs where ROLE = p_rol and PRIVILEGE = p_privilegio;
	if v_analizarprivilegio != 0 then
		for v_compuesto in c_compuesto loop
			ver_usuario_simple(v_compuesto.GRANTEE, p_privilegio);
		end loop;
	else
		ver_usuario_simple(p_rol, p_privilegio);
	end if;
end;
/

create or replace procedure privilegios_superusuario_rol
is
	cursor c_privs is
	select GRANTEE, PRIVILEGE from dba_sys_privs where ADMIN_OPTION='YES' and GRANTEE in (select ROLE from DBA_ROLES);
	v_compuesto number(1):=0;
	v_rol varchar2(1000):='SIMPLE';
begin
	for v_privs in c_privs loop
		select count(*) into v_compuesto from DBA_ROLE_PRIVS where GRANTED_ROLE = v_privs.GRANTEE;
		if v_compuesto=0 then
			ver_usuario_simple(v_privs.GRANTEE, v_privs.PRIVILEGE);
		else
			ver_usuario_compuesto(v_privs.GRANTEE, v_privs.PRIVILEGE);
		end if;
	end loop;
end;
/

create or replace procedure privilegios_superusuario_directo
is
	cursor c_privsd is
	select GRANTEE, PRIVILEGE from dba_sys_privs where ADMIN_OPTION = 'YES' and GRANTEE in (select USERNAME from DBA_USERS);
begin
	for v_privsd in c_privsd loop
		dbms_output.put_line('Usuario: '||v_privsd.GRANTEE);
		dbms_output.put_line('Privilegio: '||v_privsd.PRIVILEGE);
		dbms_output.put_line(chr(13));
	end loop;
end;
/

create or replace procedure privilegios_superusuario
is
begin
	dbms_output.put_line('Usuarios que pueden dar privilegios');
	privilegios_superusuario_directo;
	privilegios_superusuario_rol;
end;
/
</code></pre>
</div><h3 id="caso-practico-2"> CASO PRÁCTICO 2:</h3>
<p><font color="#00ff00"><strong>1.</strong></font> <strong>(ORACLE) La vida de un DBA es dura. Tras pedirlo insistentemente, en tu empresa han contratado una persona para ayudarte. Decides que se encargará de las siguientes tareas:</strong></p>
<ul>
<li>
<p><strong>Resetear los archivos de log en caso de necesidad.</strong></p>
</li>
<li>
<p><strong>Crear funciones de complejidad de contraseña y asignárselas a  usuarios.</strong></p>
</li>
<li>
<p><strong>Eliminar la información de rollback. (este privilegio podrá pasarlo a quien quiera)</strong></p>
</li>
<li>
<p><strong>Modificar información existente en la tabla dept del usuario scott. (este privilegio podrá pasarlo a quien quiera)</strong></p>
</li>
<li>
<p><strong>Realizar pruebas de todos los procedimientos existentes en la base de datos.</strong></p>
</li>
<li>
<p><strong>Poner un tablespace fuera de línea.</strong></p>
</li>
</ul>
<p><strong>Crea un usuario llamado Ayudante y, sin usar los roles predefinidos de ORACLE, dale  los privilegios mínimos para que pueda resolver dichas tareas.</strong></p>
<p><strong>Pista: Si no recuerdas el nombre de un privilegio, puedes buscarlo en el diccionario de datos.</strong></p>
<p><font color="#00ff00"><strong>2.</strong></font> <strong>(ORACLE) Muestra el texto de la última sentencia SQL que se ejecuto en el servidor, junto con el número de veces que se ha ejecutado desde que se cargó en el Shared Pool y el tiempo de CPU empleado en su ejecución.</strong></p>
<div><pre><code>select distinct sql_text, executions, CPU_TIME
from v$sqlarea
order by first_load_TIME desc
fetch first 1 row only;  
</code></pre>
</div><p><font color="#00ff00"><strong>3.</strong></font> <strong>(ORACLE, Postgres) Realiza un procedimiento que reciba dos nombres de usuario y genere un script que asigne al primero los privilegios de inserción y modificación sobre todas las tablas del segundo, así como el de ejecución de cualquier procedimiento que tenga el segundo usuario.</strong></p>
<p><font color="#00ff00"><strong>4.</strong></font> <strong>(ORACLE) Realiza un procedimiento que genere un script que cree un rol conteniendo todos los permisos que tenga el usuario cuyo nombre reciba como parámetro, le hayan sido asignados a aquél directamente o a traves de roles. El nuevo rol deberá llamarse BackupPrivsNombreUsuario.</strong></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Presentación</title>
    <id>https://github.com/oscarlucas22/presentacion/</id>
    <link href="https://github.com/oscarlucas22/presentacion/"/>
    <updated>2023-01-19T12:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="presentacion"> Presentación</h1>
<p>Bienvenidos a mi blog personal al blog de <a href="./../home.html">Óscar Lucas</a>. Soy un alumno del IES Gonzalo Nazareno y resido en Dos Hermanas (Sevilla).</p>
<p>La idea principal de este blog es subir algunas de las tareas que vaya realizando a lo largo de mi curso de ASIR.</p>
<p>Espero que os guste y os sirva de ayuda para algunos. Un saludo.</p>
<center><i>Content not supported</i></center>]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <published>2023-01-19T12:13:11.000Z</published>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Copias de Seguridad y Restauración</title>
    <id>https://github.com/oscarlucas22/practicas/copias-seg-y-rest/</id>
    <link href="https://github.com/oscarlucas22/practicas/copias-seg-y-rest/"/>
    <updated>2023-03-07T17:02:54.427Z</updated>
    <content type="html"><![CDATA[<h1 id="copias-de-seguridad-y-restauracion"> Copias de Seguridad y Restauración</h1>
<h3 id="_1-realiza-una-copia-de-seguridad-logica-de-tu-base-de-datos-completa-teniendo-en-cuenta-los-siguientes-requisitos"> 1. Realiza una copia de seguridad lógica de tu base de datos completa, teniendo en cuenta los siguientes requisitos:</h3>
<ul>
<li>
<p><strong>La copia debe estar encriptada y comprimida.</strong></p>
<ul>
<li>
<p><em><strong>COMPRESSION</strong></em> = Sirve para comprimir el fichero de exportación.</p>
</li>
<li>
<p><em><strong>ENCRYPTION_PASSWORD</strong></em> = Sirve para encriptar el fichero, indicandole una contraseña.</p>
</li>
</ul>
</li>
<li>
<p><strong>Debe realizarse en un conjunto de ficheros con un tamaño máximo de 60 MB.</strong></p>
<ul>
<li><em><strong>FILESIZE</strong></em> = Sirve para indicar un tamaño maximo al fichero.</li>
</ul>
</li>
</ul>
<p>Utilizaremos la herramienta <code>expdp</code> para hacer una copia de seguridad completa.</p>
<p>Antes de realizar la exportación, crearemos una carpeta para almacenar los archivos exportados.</p>
<p>Luego, se debe registrar la ubicación de la carpeta donde se guardarán los archivos de exportación completos:</p>
<div><pre><code>create directory copiadb as '/home/oracle/copiadb';
</code></pre>
</div><p>Voy a crear un usuario con permisos de administrador.</p>
<div><pre><code>create user admin identified by &quot;root&quot;;
grant dba to admin;
</code></pre>
</div><p>Para iniciar la exportación, se debe ejecutar el siguiente comando:</p>
<div><pre><code>expdp admin/root DIRECTORY=copiadb DUMPFILE=copiadb.dmp FULL=YES LOGFILE=copiadb.log COMPRESSION=ALL DUMPFILE=compress.dmp ENCRYPTION_PASSWORD=passwd FILESIZE=60M
</code></pre>
</div><p><img src="./../images/ABD/copias/1-1.png" alt="image"></p>
<p>Aquí se pueden ver los archivos que han sido creados.</p>
<p><img src="./../images/ABD/copias/2-1.png" alt="image"></p>
<ul>
<li><strong>Programa la operación para que se repita cada día a una hora determinada.</strong></li>
</ul>
<p>Para programar la exportación, crearemos un script con el siguiente contenido:</p>
<div><pre><code>nano copiadb.sh
</code></pre>
</div><hr>
<div><pre><code>#!/bin/bash

expdp admin/root DIRECTORY=copiadb DUMPFILE=copiadb.dmp FULL=YES LOGFILE=copiadb.log COMPRESSION=ALL DUMPFILE=compress.dmp ENCRYPTION_PASSWORD=passwd FILESIZE=60M
</code></pre>
</div><p>Es necesario otorgar permisos de ejecución al script.</p>
<div><pre><code>chmod +x copiadb.sh
</code></pre>
</div><p>Para ejecutar manualmente el script, se debe ejecutar lo siguiente:</p>
<div><pre><code>./copiadb.sh
</code></pre>
</div><p>Programaremos la ejecución del script de copia de seguridad para que se ejecute todos los días a las 00:00 horas utilizando la herramienta <code>crontab</code>.</p>
<div><pre><code>crontab -e
</code></pre>
</div><hr>
<div><pre><code>0 0 * * * sleep 180; /home/oracle/copiadb.sh
</code></pre>
</div><h3 id="_2-restaura-la-copia-de-seguridad-logica-creada-en-el-punto-anterior"> 2. Restaura la copia de seguridad lógica creada en el punto anterior.</h3>
<p>Eliminaremos tablas de las bases de datos &quot;scott&quot; y &quot;prueba&quot; y posteriormente las restauraremos.</p>
<p><img src="./../images/ABD/copias/3-1.png" alt="image"></p>
<p>Una vez completada la eliminación de las tablas, procederemos a realizar la importación mediante el comando <code>impdp</code>.</p>
<div><pre><code>impdp admin/root DIRECTORY=copiadb DUMPFILE=copiadb.dmp FULL=YES ENCRYPTION_PASSWORD=passwd
</code></pre>
</div><p><img src="./../images/ABD/copias/4-1.png" alt="image"></p>
<p><img src="./../images/ABD/copias/5-1.png" alt="image"></p>
<p><img src="./../images/ABD/copias/6-1.png" alt="image"></p>
<h3 id="_3-pon-tu-base-de-datos-en-modo-archivelog-y-realiza-con-rman-una-copia-de-seguridad-fisica-en-caliente"> 3. Pon tu base de datos en modo ArchiveLog y realiza con RMAN una copia de seguridad física en caliente.</h3>
<ol>
<li>Para verificar si la base de datos se encuentra en modo ArchiveLog, se debe ejecutar la siguiente consulta:</li>
</ol>
<hr>
<div><pre><code>select log_mode from v$database;
</code></pre>
</div><ol start="2">
<li>Si, al ejecutar la consulta, se muestra que el valor de <code>log_mode</code> es <code>ARCHIVELOG</code>, significa que la base de datos ya está en modo ArchiveLog.</li>
</ol>
<p>En caso de que la base de datos no se encuentre en modo ArchiveLog, se debe cambiar el modo de registro mediante la siguiente consulta:</p>
<div><pre><code>shutdown immediate;
startup mount;
alter database archivelog;
alter database open;
</code></pre>
</div><p><img src="./../images/ABD/copias/1-3.png" alt="image"></p>
<ol start="3">
<li>Ahora crearemos un tablespace donde se almacenarán todos los archivos necesarios para la gestión de la restauración con RMAN.</li>
</ol>
<hr>
<div><pre><code>create tablespace TS_RMAN datafile '/opt/oracle/oradata/ORCLCDB/TS_RAMN.dbf' size 300M;
create user user_rman identified by root default tablespace TS_RMAN quota unlimited on TS_RMAN;
</code></pre>
</div><ol start="4">
<li>Asignaremos los permisos necesarios al usuario recién creado.</li>
</ol>
<hr>
<div><pre><code>grant recovery_catalog_owner to user_rman;
grant connect, resource to user_rman;
</code></pre>
</div><ol start="5">
<li>Es momento de ejecutar RMAN.</li>
</ol>
<hr>
<div><pre><code>rman
connect catalog user_rman
</code></pre>
</div><p><img src="./../images/ABD/copias/2-3.png" alt="image"></p>
<ol start="6">
<li>Vamos a crear el catálogo que hemos registrado previamente en el tablespace TS_RMAN.</li>
</ol>
<hr>
<div><pre><code>create catalog tablespace TS_RMAN;
</code></pre>
</div><ol start="7">
<li>A continuación, nos conectaremos al catálogo que acabamos de crear.</li>
</ol>
<hr>
<div><pre><code>rman target=/ catalog user_rman
</code></pre>
</div><p><img src="./../images/ABD/copias/3-3.png" alt="image"></p>
<ol start="8">
<li>Vamos a registrar nuestra base de datos.</li>
</ol>
<hr>
<div><pre><code>register database;
</code></pre>
</div><p><img src="./../images/ABD/copias/4-3.png" alt="image"></p>
<ol start="9">
<li>Iniciaremos el proceso de backup en caliente.</li>
</ol>
<hr>
<div><pre><code>backup database;
</code></pre>
</div><p><img src="./../images/ABD/copias/5-3.png" alt="image"></p>
<h3 id="_4-borra-un-fichero-de-datos-de-un-tablespace-e-intenta-recuperar-la-instancia-de-la-base-de-datos-a-partir-de-la-copia-de-seguridad-creada-en-el-punto-anterior"> 4. Borra un fichero de datos de un tablespace e intenta recuperar la instancia de la base de datos a partir de la copia de seguridad creada en el punto anterior.</h3>
<p>Eliminaré un archivo de un tablespace. Entre los tablespaces más comunes se encuentran:</p>
<ol>
<li>
<p><em><strong>SYSTEM</strong></em> tablespace: este es el tablespace predeterminado y contiene objetos del sistema y metadata importantes para el funcionamiento de la base de datos. No se recomienda almacenar objetos de usuario en este tablespace.</p>
</li>
<li>
<p><em><strong>SYSAUX</strong></em> tablespace: este tablespace se utiliza para almacenar datos y metadata de componentes de la base de datos opcionales, como Oracle Text y Oracle Spatial.</p>
</li>
<li>
<p><em><strong>USERS</strong></em> tablespace: este tablespace se utiliza para almacenar objetos de usuario, como tablas, índices y vistas.</p>
</li>
<li>
<p><em><strong>TEMP</strong></em> tablespace: este tablespace se utiliza para almacenar datos temporales generados por la base de datos durante la ejecución de consultas y otras operaciones.</p>
</li>
<li>
<p><em><strong>UNDO</strong></em> tablespace: este tablespace se utiliza para almacenar información de undo, que se utiliza para revertir transacciones y deshacer cambios en la base de datos.</p>
</li>
<li>
<p><em><strong>INDEX</strong></em> tablespace: este tablespace se utiliza para almacenar índices, que son objetos que se utilizan para acelerar la búsqueda de datos en la base de datos.</p>
</li>
</ol>
<p>En mi caso como voy a hacer pruebas con las tablas de los usuario voy a borrar el fichero del tablespace USERS, ya que es el que se encarga de almacenar los objetos de usuarios, tablas, vistas...</p>
<ol>
<li>Para descubrir el archivo del tablespace &quot;USERS&quot;, procedí a ejecutar lo siguiente:</li>
</ol>
<hr>
<div><pre><code>select file_name from dba_data_files where tablespace_name = 'USERS';
</code></pre>
</div><p><img src="./../images/ABD/copias/1-4.png" alt="image"></p>
<ol start="2">
<li>Borraremos el fichero</li>
</ol>
<hr>
<div><pre><code>rm /opt/oracle/oradata/ORCLCDB/users01.dbf
</code></pre>
</div><p>Planeo verificar que se ha eliminado de manera efectiva, consultando las tablas que se encontraban en ese tablespace.</p>
<p><img src="./../images/ABD/copias/2-4.png" alt="image"></p>
<ol start="3">
<li>Vamos a intentar recuperar el archivo del tablespace utilizando RMAN.</li>
</ol>
<hr>
<div><pre><code>rman target=/ catalog user_rman
</code></pre>
</div><ol start="4">
<li>Antes de realizar la restauración, es necesario desactivar el tablespace correspondiente.</li>
</ol>
<hr>
<div><pre><code>SQL &quot;alter tablespace USERS offline immediate&quot;;
</code></pre>
</div><p><img src="./../images/ABD/copias/3-4.png" alt="image"></p>
<ol start="5">
<li>Ahora sí, procederemos a restaurar el tablespace USERS.</li>
</ol>
<hr>
<div><pre><code>restore tablespace USERS;
</code></pre>
</div><p><img src="./../images/ABD/copias/4-4.png" alt="image"></p>
<ol start="6">
<li>Luego de finalizar la restauración, activaremos nuevamente el tablespace.</li>
</ol>
<hr>
<div><pre><code>recover tablespace USERS;
</code></pre>
</div><p><img src="./../images/ABD/copias/5-4.png" alt="image"></p>
<div><pre><code>SQL &quot;alter tablespace USERS online&quot;;
</code></pre>
</div><p><img src="./../images/ABD/copias/6-4.png" alt="image"></p>
<p>Finalmente, verificaremos que todo se encuentra en orden.</p>
<p><img src="./../images/ABD/copias/7-4.png" alt="image"></p>
<h3 id="_5-borra-un-fichero-de-control-e-intenta-recuperar-la-base-de-datos-a-partir-de-la-copia-de-seguridad-creada-en-el-punto-anterior"> 5. Borra un fichero de control e intenta recuperar la base de datos a partir de la copia de seguridad creada en el punto anterior.</h3>
<ol>
<li>Borramos un fichero de control</li>
</ol>
<hr>
<div><pre><code>rm /opt/oracle/oradata/ORCLCDB/control02.ctl
</code></pre>
</div><p><img src="./../images/ABD/copias/1-5.png" alt="image"></p>
<ol start="2">
<li>Forzaremos el apagado de la base de datos, y la pondremos en modo no montada.</li>
</ol>
<hr>
<div><pre><code>shutdown abort
startup nomount
</code></pre>
</div><p><img src="./../images/ABD/copias/2-5.png" alt="image"></p>
<ol start="3">
<li>Accederemos a rman manualmente desde el fichero backup, puesto que la base de datos ya no esta montada.</li>
</ol>
<hr>
<div><pre><code>rman
connect target
</code></pre>
</div><p><img src="./../images/ABD/copias/3-5.png" alt="image"></p>
<ol start="3">
<li>Restauraremos el fichero de control</li>
</ol>
<hr>
<div><pre><code>restore controlfile from '/opt/oracle/product/19c/dbhome_1/dbs/c-2890428600-20230306-01';
</code></pre>
</div><p><img src="./../images/ABD/copias/4-5.png" alt="image"></p>
<ol start="4">
<li>Volvemos a montar la base de datos</li>
</ol>
<hr>
<div><pre><code>alter database mount;
</code></pre>
</div><p><img src="./../images/ABD/copias/5-5.png" alt="image"></p>
<ol start="5">
<li>Reseteamos los logs</li>
</ol>
<hr>
<div><pre><code>alter database open resetlogs;
</code></pre>
</div><ol start="6">
<li>Abrimos la base de datos</li>
</ol>
<hr>
<div><pre><code>alter database open;
</code></pre>
</div><ol start="7">
<li>Hacemos las comprobaciones</li>
</ol>
<p><img src="./../images/ABD/copias/6-5.png" alt="image"></p>
<h3 id="_6-documenta-el-empleo-de-las-herramientas-de-copia-de-seguridad-y-restauracion-de-postgres"> 6. Documenta el empleo de las herramientas de copia de seguridad y restauración de Postgres.</h3>
<p>Existen varias herramientas de copia de seguridad de PostgreSQL, cada una con sus propias ventajas y desventajas. Algunas de las más comunes son:</p>
<ol>
<li>
<p><em><strong>pg_dump</strong></em>: es una herramienta de línea de comandos que se incluye con PostgreSQL y que permite hacer copias de seguridad de una base de datos completa o de una selección de tablas. Puede ser utilizado para hacer copias de seguridad de una base de datos en un archivo, en una secuencia de comandos SQL o en una salida binaria.</p>
</li>
<li>
<p><em><strong>pg_dumpall</strong></em>: es una herramienta de línea de comandos que se utiliza para hacer una copia de seguridad de todas las bases de datos en un servidor PostgreSQL. Esto incluye todas las bases de datos de usuario, así como las bases de datos del sistema.</p>
</li>
<li>
<p><em><strong>Barman</strong></em>: es una herramienta de copia de seguridad y recuperación de bases de datos PostgreSQL de código abierto. Ofrece una solución de copia de seguridad para bases de datos PostgreSQL, incluyendo soporte para copias de seguridad remotas y restauración automatizada.</p>
</li>
<li>
<p><em><strong>pgBackRest</strong></em>: es una herramienta de copia de seguridad y restauración de bases de datos PostgreSQL de alto rendimiento y escalable. Se centra en la velocidad de copia de seguridad y recuperación, y ofrece opciones avanzadas de compresión, encriptación y almacenamiento.</p>
</li>
<li>
<p><em><strong>WAL-E</strong></em>: es una herramienta de copia de seguridad y recuperación de bases de datos PostgreSQL que se enfoca en la protección de datos en tiempo real. Utiliza los archivos de registro de transacciones (WAL) para crear copias de seguridad incrementales de una base de datos PostgreSQL y para recuperar una base de datos hasta un punto específico en el tiempo.</p>
</li>
</ol>
<p>Cada herramienta de copia de seguridad de PostgreSQL tiene sus propias características únicas y puede ser más adecuada para ciertas situaciones. Por lo tanto, es importante considerar cuidadosamente qué herramienta se utilizará para hacer una copia de seguridad de la base de datos.</p>
<p>A continuación mostreré un ejemplo de <code>pg_dump</code> sobre la tabla &quot;scott&quot;:</p>
<ol>
<li>Crearé un directorio para guardar los ficheros:</li>
</ol>
<hr>
<div><pre><code>mkdir /var/lib/postgresql/copiadb
</code></pre>
</div><ol start="2">
<li>Ejecutamos el comando:</li>
</ol>
<hr>
<div><pre><code>pg_dump -U postgres -d scott &gt; /var/lib/postgresql/copiadb/CopiaScott.sql
</code></pre>
</div><ol start="3">
<li>Creare una nueva base de datos para restaurar la base de datos:</li>
</ol>
<hr>
<div><pre><code>create database copiascott with owner postgres;
grant all privileges on database copiascott to postgres;
</code></pre>
</div><p><img src="./../images/ABD/copias/1-6.png" alt="image"></p>
<ol start="4">
<li>Importamos la base de datos</li>
</ol>
<hr>
<div><pre><code>psql -U postgres -d copiascott &lt; /var/lib/postgresql/copiadb/CopiaScott.sql
</code></pre>
</div><p><img src="./../images/ABD/copias/2-6.png" alt="image"></p>
<p>Y una vez finalizado comprobaremos que la base de datos se ha restaurado completamente:</p>
<p><img src="./../images/ABD/copias/3-6.png" alt="image"></p>
<h3 id="_7-documenta-el-empleo-de-las-herramientas-de-copia-de-seguridad-y-restauracion-de-mysql"> 7. Documenta el empleo de las herramientas de copia de seguridad y restauración de MySQL.</h3>
<p>El comando mysqldump proporciona varias opciones que se pueden utilizar para personalizar la copia de seguridad. Algunas de estas opciones son:</p>
<ul>
<li>
<p><code>--user</code>: especifica el nombre de usuario que se utilizará para conectarse a la base de datos.</p>
</li>
<li>
<p><code>--password</code>: proporciona la contraseña correspondiente al usuario.</p>
</li>
<li>
<p><code>--host</code>: indica el servidor donde se encuentra la base de datos.</p>
</li>
<li>
<p><code>--port</code>: especifica el número de puerto que se utilizará para la conexión.</p>
</li>
<li>
<p><code>--single-transaction</code>: realiza la copia de seguridad dentro de una única transacción, lo que asegura que se copie una imagen consistente de la base de datos.</p>
</li>
<li>
<p><code>--add-drop-database</code>: agrega una instrucción &quot;DROP DATABASE&quot; antes de crear cada base de datos, lo que permite que la copia de seguridad pueda ser utilizada para recrear toda la base de datos.</p>
</li>
<li>
<p><code>--compress</code>: comprime la copia de seguridad mientras se está generando.</p>
</li>
<li>
<p><code>--result-file</code>: permite especificar el nombre y la ruta del archivo de salida para la copia de seguridad.</p>
</li>
<li>
<p><code>--tables</code>: permite especificar las tablas que se desean incluir en la copia de seguridad.</p>
</li>
<li>
<p><code>--databases</code>: permite especificar las bases de datos que se desean incluir en la copia de seguridad.</p>
</li>
<li>
<p><code>--lock-tables</code>: bloquea las tablas mientras se realiza la copia de seguridad, lo que garantiza que no se realicen cambios en las tablas mientras se está copiando.</p>
</li>
<li>
<p><code>--ignore-table</code>: permite excluir tablas específicas de la copia de seguridad.</p>
</li>
<li>
<p><code>--routines</code>: incluye las rutinas almacenadas en la base de datos (procedimientos almacenados, funciones, etc.).</p>
</li>
<li>
<p><code>--triggers</code>: incluye los triggers definidos en la base de datos.</p>
</li>
<li>
<p><code>--skip-comments</code>: omite los comentarios en la copia de seguridad.</p>
</li>
</ul>
<p>Para llevar a cabo una copia completa de la base de datos de MySQL, utilizaremos nuevamente la herramienta <code>mysqldump</code>, pero esta vez agregaremos el parámetro <code>--all-databases</code>.</p>
<div><pre><code>mysqldump -u root -p --all-databases &gt; copiadb.sql
</code></pre>
</div><p><img src="./../images/ABD/copias/1-7.png" alt="image"></p>
<p>A continuación, eliminaré algunas tablas de la base de datos &quot;proyecto&quot; y otras de la base de datos &quot;scott&quot;.</p>
<p><img src="./../images/ABD/copias/2-7.png" alt="image"></p>
<p>Ahora procederemos a restaurar las tablas.</p>
<div><pre><code>mysql -u root -p scott &lt; copiadb.sql
mysql -u root -p proyecto &lt; copiadb.sql
</code></pre>
</div><p>Luego, verificaremos las bases de datos para asegurarnos de que las tablas se hayan restaurado correctamente.</p>
<p><img src="./../images/ABD/copias/3-7.png" alt="image"></p>
<h3 id="_8-documenta-el-empleo-de-las-herramientas-de-copia-de-seguridad-y-restauracion-de-mongodb"> 8. Documenta el empleo de las herramientas de copia de seguridad y restauración de MongoDB.</h3>
<p>Podemos utilizar la herramienta <code>mongodump</code> para realizar copias de seguridad en MongoDB. Esta herramienta nos permite hacer una copia de seguridad de la base de datos completa o de una colección específica.</p>
<p>Primero crearemos un directorio donde se almacenarán las copias de seguridad que realizaremos de las bases de datos.</p>
<div><pre><code>mkdir -p /var/backups/copiasdb
</code></pre>
</div><p>Ejecutamos el comando de <code>mongodump</code>.</p>
<div><pre><code>mongodump -u olucas -p root -d Prueba -o /var/backups/copiasdb/Prueba --authenticationDatabase admin
</code></pre>
</div><p><img src="./../images/ABD/copias/1-8.png" alt="image"></p>
<p>Para restaurar una copia de seguridad en MongoDB, podemos utilizar la herramienta <code>mongorestore</code>. Con esta herramienta, podemos restaurar la base de datos completa o una colección específica.</p>
<ol>
<li>Para restaurar una base de datos completa, ejecutaremos el siguiente comando:</li>
</ol>
<hr>
<div><pre><code>mongorestore -u olucas -p root --db Prueba2 /var/backups/copiasdb/Prueba/Prueba/ --authenticationDatabase admin
</code></pre>
</div><p><img src="./../images/ABD/copias/2-8.png" alt="image"></p>
<p>Como podemos observar, la base de datos Prueba2 se ha restaurado correctamente.</p>
<p><img src="./../images/ABD/copias/3-8.png" alt="image"></p>
<ol start="2">
<li>Para restaurar una colección en concreto, ejecutaremos el siguiente comando:</li>
</ol>
<hr>
<div><pre><code>mongorestore -u olucas -p root --db Prueba3 --collection prueba1 /var/backups/copiasdb/Prueba/Prueba/prueba1.bson --authenticationDatabase admin
</code></pre>
</div><p><img src="./../images/ABD/copias/4-8.png" alt="image"></p>
<p>Como podemos observar, la colección prueba1 de la base de datos Prueba3 se ha restaurado correctamente.</p>
<p><img src="./../images/ABD/copias/5-8.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Instalación y configuración de un servidor de correos en el VPS</title>
    <id>https://github.com/oscarlucas22/practicas/correos/</id>
    <link href="https://github.com/oscarlucas22/practicas/correos/"/>
    <updated>2023-03-07T17:02:54.431Z</updated>
    <content type="html"><![CDATA[<h1 id="instalacion-y-configuracion-de-un-servidor-de-correos-en-el-vps"> Instalación y configuración de un servidor de correos en el VPS</h1>
<h2 id="practica-servidor-de-correos"> Práctica: Servidor de correos</h2>
<p><strong>Instala y configura de manera adecuada el servidor de correos en tu VPS. El nombre del servidor de correo será mail.tudominio.es (Este es el nombre que deberá aparecer en el registro MX).</strong></p>
<h2 id="gestion-de-correos-desde-el-servidor"> Gestión de correos desde el servidor</h2>
<p><strong>El envío y recepción se hará desde el servidor usando la herramienta mail.</strong></p>
<ul>
<li><strong><em>Tarea 1</em>: Documenta una prueba de funcionamiento, donde envíes desde tu servidor local al exterior. Muestra el log donde se vea el envío. Muestra el correo que has recibido. Muestra el registro SPF.</strong></li>
</ul>
<hr>
<p>He accedido a la sección de DNS de mi alojamiento web para establecer el registro MX, que debe estar vinculado a un registro de clase A. También he creado el registro SPF en este momento.</p>
<p><img src="./../images/SRI/correos/1_1.png" alt="image"></p>
<p>Luego, instalamos Postfix en la VPS y especificamos el dominio (olucass.com) durante la instalación. Además, instalamos los paquetes requeridos para enviar correos electrónicos.</p>
<div><pre><code>apt install postfix bsd-mailx
</code></pre>
</div><p>Debido a que disponemos de una dirección IP pública en la VPS, no requerimos agregar el relay en la configuración de Postfix. Por lo tanto, podemos continuar directamente con el envío de correos electrónicos a mi cuenta de Gmail.</p>
<p><img src="./../images/SRI/correos/2_1.png" alt="image"></p>
<p>Ahora veamos los logs para ver si se ha enviado:</p>
<p><img src="./../images/SRI/correos/3_1.png" alt="image"></p>
<p>Como podemos observar, de acuerdo con el registro, el correo se ha enviado exitosamente. Ahora, verifiquemos si llegó a mi cliente de correo electrónico.</p>
<p><img src="./../images/SRI/correos/4_1.png" alt="image"></p>
<p>Como vemos, he recibido correctamente el correo, por lo que podemos decir que esta primera tarea ha sido un éxito.</p>
<ul>
<li><strong><em>Tarea 2</em>: Documenta una prueba de funcionamiento, donde envíes un correo desde el exterior (gmail, hotmail,…) a tu servidor local. Muestra el log donde se vea el envío. Muestra cómo has leído el correo. Muestra el registro MX de tu dominio.</strong></li>
</ul>
<hr>
<p>Vamos a mandar un correo desde mi cliente de correos gmail hacia mi vps:</p>
<p><img src="./../images/SRI/correos/1_2.png" alt="image"></p>
<p>Como hemos demostrado en la tarea previa, en el registro DNS de mi VPS existe un registro de clase MX que apunta a mi servidor, por lo que no debería haber ningún obstáculo para recibir correos electrónicos. Verifiquemos los registros de la VPS para determinar si el correo ha llegado.</p>
<p><img src="./../images/SRI/correos/2_2.png" alt="image"></p>
<p>En los registros se refleja la recepción del correo electrónico. Para ver su contenido, utilizaremos la herramienta &quot;mail&quot;.</p>
<p><img src="./../images/SRI/correos/3_2.png" alt="image"></p>
<p><img src="./../images/SRI/correos/4_2.png" alt="image"></p>
<p>Con esto hemos acabado la segunda tarea de forma satisfactoria.</p>
<h2 id="uso-de-alias-y-redirecciones"> Uso de alias y redirecciones</h2>
<ul>
<li><strong><em>Tarea 3</em>: Uso de alias y redirecciones.</strong></li>
</ul>
<p><strong>Vamos a comprobar como los procesos del servidor pueden mandar correos para informar sobre su estado. Por ejemplo cada vez que se ejecuta una tarea cron podemos enviar un correo informando del resultado. Normalmente estos correos se mandan al usuario root del servidor, para ello:</strong></p>
<div><pre><code>$ crontab -e
</code></pre>
</div><p><strong>E indico donde se envía el correo:</strong></p>
<div><pre><code>MAILTO = root
</code></pre>
</div><p><strong>Puedes poner alguna tarea en el cron para ver como se mandan correo.</strong></p>
<p><strong>Posteriormente usando alias y redirecciones podemos hacer llegar esos correos a nuestro correo personal.</strong></p>
<p><strong>Configura el cron para enviar correo al usuario root. Comprueba que están llegando esos correos al root. Crea un nuevo alias para que se manden a un usuario sin privilegios. Comprueban que llegan a ese usuario. Por último crea una redirección para enviar esos correo a tu correo personal (gmail,hotmail,…).</strong></p>
<hr>
<p>Para empezar he creado una tarea cron que se ejecuta cada 3 minutos y he hecho que mande el mail al usuario “root”:</p>
<p><img src="./../images/SRI/correos/1_3.png" alt="image"></p>
<p>El script que ejecuta es el siguiente:</p>
<p><img src="./../images/SRI/correos/2_3.png" alt="image"></p>
<p>Es un script sencillo que nos ayudará a realizar las pruebas necesarias. Ahora, crearemos un alias en el archivo &quot;/etc/aliases&quot; para que los correos electrónicos recibidos por &quot;root&quot; se reenvíen a mi usuario &quot;olucas&quot;.</p>
<p><img src="./../images/SRI/correos/3_3.png" alt="image"></p>
<p>Para que se apliquen los cambios realizados en este fichero debemos ejecutar el siguiente comando:</p>
<div><pre><code>newaliases
</code></pre>
</div><p>Ahora los correos que le lleguen al usuario “root”, deberían llegarle también al usuario &quot;olucas&quot;:</p>
<p><img src="./../images/SRI/correos/4_3.png" alt="image"></p>
<p><img src="./../images/SRI/correos/5_3.png" alt="image"></p>
<p>Para que los correos electrónicos lleguen a nuestra cuenta principal, debemos crear un archivo llamado &quot;.forward&quot; en el directorio &quot;~&quot; del usuario, y agregar las direcciones de correo a las que deseamos reenviar los mensajes.</p>
<div><pre><code>nano ~/.forward

oscarlucasleo124@gmail.com
</code></pre>
</div><p>Veamos si llegan a mi correo:</p>
<p><img src="./../images/SRI/correos/6_3.png" alt="image"></p>
<p>Como podemos observar, los correos electrónicos se han reenviado correctamente, por lo que podemos considerar esta tarea finalizada.</p>
<h2 id="para-asegurar-el-envio"> Para asegurar el envío</h2>
<ul>
<li><strong><em>Tarea 4:</em> (No obligatoria): Configura de manera adecuada DKIM es tu sistema de correos. Comprueba el registro DKIM en la página <a href="https://mxtoolbox.com/dkim.aspx" target="_blank" rel="noopener noreferrer">https://mxtoolbox.com/dkim.aspx<i>Content not supported</i></a>. Configura postfix para que firme los correos que envía. Manda un correo y comprueba la verificación de las firmas en ellos.</strong></li>
</ul>
<p>En esta tarea, vamos a establecer la autenticación de correo electrónico a través de &quot;DKIM&quot; (DomainKeys Identified Mail) en nuestra VPS. Este método garantiza la integridad del mensaje desde su envío hasta su recepción y se basa en la publicación de una clave pública en un registro TXT del servidor DNS. El servidor de correo electrónico firmará los mensajes con esta clave pública y los clientes podrán verificar la firma mediante la clave pública en el servidor DNS.</p>
<p>Con lo anterior en mente, ahora procederemos a instalar los paquetes requeridos para establecer DKIM en nuestra VPS.</p>
<div><pre><code>apt install opendkim opendkim-tools
</code></pre>
</div><p>Ahora modificaremos el fichero de configuración de DKIM (/etc/opendkim.conf):</p>
<div><pre><code>nano /etc/opendkim.conf

Syslog                  yes
SyslogSuccess           yes
Canonicalization        relaxed/simple
OversignHeaders         From
Domain                  olucass.com
Selector                dkim
KeyFile         		/etc/dkimkeys/dkim.private
UserID                  opendkim
UMask                   007
Socket                  inet:8891@localhost
PidFile                 /run/opendkim/opendkim.pid
TrustAnchorFile         /usr/share/dns/root.key
</code></pre>
</div><p>De los parámetros anteriores he dejado por defecto la mayoría. Los que he cambiado son los siguientes:</p>
<ul>
<li>
<p><strong>Dominio</strong>: Especificamos nuestro dominio.</p>
</li>
<li>
<p><strong>Selector</strong>: Un nombre único que utilizaremos para subir la clave pública al servidor DNS y para que el destinatario pueda identificarla fácilmente.</p>
</li>
<li>
<p><strong>KeyFile</strong>: La ubicación de la clave privada que usaremos para firmar los mensajes.</p>
</li>
<li>
<p><strong>Socket</strong>: Cambiamos el socket UNIX por uno TCP/IP (comentamos el que viene por defecto y descomentamos este). Debemos actualizar el archivo /etc/default/opendkim para reflejar este cambio.</p>
<p>nano /etc/default/opendkim</p>
<p>SOCKET=inet:8891@localhost</p>
</li>
</ul>
<p>Ahora debemos hacer un ajuste en la configuración de Postfix en el archivo /etc/postfix/main.cf para especificar que se utilice DKIM para firmar los mensajes enviados.</p>
<div><pre><code>nano /etc/postfix/main.cf

milter_default_action = accept
milter_protocol = 2
smtpd_milters = inet:localhost:8891
non_smtpd_milters = $smtpd_milters
</code></pre>
</div><p>Ahora que hemos terminado con la configuración, es hora de generar la clave pública y privada de la que hemos hablado antes. Para hacer esto, nos dirigimos al directorio especificado previamente en la configuración (/etc/dkimkeys) y ejecutamos el siguiente comando:</p>
<div><pre><code>opendkim-genkey -s dkim -d olucass.com -b 1024
</code></pre>
</div><p>Donde:</p>
<ul>
<li>
<p>“-s:” Indicamos el “Selector” al cual nombramos en la configuración de DKIM.</p>
</li>
<li>
<p>“-d:” Indicamos el dominio.</p>
</li>
<li>
<p>“-b:” Indicamos el tamaño de la clave.</p>
</li>
</ul>
<p>Al par de claves que se han generado debemos cambiarle el propietario:</p>
<div><pre><code>chown opendkim: dkim.private dkim.txt
</code></pre>
</div><p>Ahora solo necesitamos agregar el registro TXT en el servidor DNS con la clave pública. El registro debe tener el siguiente formato: [selector]._domainkey. Entonces, mi registro quedaría así:</p>
<p><img src="./../images/SRI/correos/1_4.png" alt="image"></p>
<p>Si usamos la herramienta que se menciona en el enunciado, podemos comprobar que el registro se ha añadido correctamente:</p>
<p><img src="./../images/SRI/correos/2_4.png" alt="image"></p>
<p>Para asegurarnos de que el servidor es capaz de firmar mensajes con nuestra clave privada, debemos enviar un correo y verificar si se ha firmado correctamente. Antes de hacer esto, es necesario reiniciar los servicios de Postfix y OpenDKIM.</p>
<div><pre><code>systemctl restart opendkim postfix
</code></pre>
</div><p>Comprobemos si nuestra vps está escuchando en el puerto que le hemos indicado (8891):</p>
<div><pre><code>netstat -tlnp | egrep opendkim
</code></pre>
</div><p><img src="./../images/SRI/correos/3_4.png" alt="image"></p>
<p>Ahora mandaremos un mensaje a mi cuenta de gmail y veremos si nos indica que está verificado por dkim:</p>
<p><img src="./../images/SRI/correos/4_4.png" alt="image"></p>
<p>Veamos el mensaje:</p>
<p><img src="./../images/SRI/correos/5_4.png" alt="image"></p>
<p>Y el contenido original del mensaje:</p>
<p><img src="./../images/SRI/correos/6_4.png" alt="image"></p>
<p>Como vemos, nos indica que está verificado con DKIM, por lo que podemos decir que esta tarea ha sido un éxito.</p>
<h2 id="para-luchar-contra-el-spam"> Para luchar contra el SPAM</h2>
<ul>
<li><strong><em>Tarea 5</em>: (No obligatorio): Configura de manera adecuada Postfix para que tenga en cuenta el registro SPF de los correos que recibe. Muestra el log del correo para comprobar que se está haciendo el testeo del registro SPF.</strong></li>
</ul>
<p>Para que postfix pueda verificar los registros SPF de los correos que recibe, es necesario instalar un paquete adicional para agregar esta capacidad, ya que no está disponible por defecto.</p>
<div><pre><code>apt install postfix-policyd-spf-python
</code></pre>
</div><p>Ahora es necesario ajustar la configuración de Postfix para aprovechar las nuevas funcionalidades instaladas para verificar el correo entrante. Para hacer esto, debemos editar el archivo <code>/etc/postfix/master.cf</code>.</p>
<div><pre><code>nano /etc/postfix/master.cf

policyd-spf  unix  -    n       n       -       0       spawn
    user=policyd-spf argv=/usr/bin/policyd-spf
</code></pre>
</div><p>Para que postfix pueda evaluar los registros SPF de los correos entrantes, debemos hacer cambios en su configuración. Específicamente, debemos agregar las nuevas funcionalidades recién instaladas en el archivo <code>/etc/postfix/master.cf</code>. Luego, para que postfix sepa qué hacer con los mensajes que pasen por el filtro, debemos modificar la configuración en el archivo <code>/etc/postfix/main.cf</code>.</p>
<div><pre><code>policyd-spf_time_limit = 3600
smtpd_recipient_restrictions = check_policy_service unix:private/policyd-spf
</code></pre>
</div><p>Para aplicar los cambios realizados en la configuración de postfix, deberemos reiniciar el servicio de postfix.</p>
<div><pre><code>systemctl restart postfix
</code></pre>
</div><p>Ahora es momento de verificar si todo lo que hemos realizado funciona correctamente. Para ello, enviaremos un correo a nuestra VPS y revisaremos los registros del log para verificar que todo se haya ejecutado de manera satisfactoria.</p>
<p><img src="./../images/SRI/correos/1_5.png" alt="image"></p>
<p>Como vemos, el correo ha pasado filtro SPF, por lo que hemos podido recibirlo de forma correcta.</p>
<ul>
<li><strong><em>Tarea 6</em>: (No obligatoria): Configura un sistema antispam. Realiza comprobaciones para comprobarlo.</strong></li>
</ul>
<p>Vamos a utilizar SpamAssassin para combatir el spam, que actuará como un filtro en Postfix y nos notificará cuáles de los correos recibidos son considerados spam. Procederemos a instalar los paquetes necesarios para el funcionamiento de SpamAssassin.</p>
<div><pre><code>apt install spamassassin spamc
</code></pre>
</div><p>Ahora iniciaremos y habilitaremos el servicio de SpamAssassin:</p>
<div><pre><code>systemctl start spamassassin
systemctl enable spamassassin
</code></pre>
</div><p>Para que SpamAssassin pueda utilizar una base de datos actualizada para determinar si un correo es spam o no, vamos a cambiar su configuración para que se actualice una vez al día. Para hacer esto, editaremos la línea &quot;CRON&quot; en el archivo <code>/etc/default/spamassassin</code> y cambiaremos su valor a &quot;1&quot;.</p>
<div><pre><code>nano /etc/default/spamassassin

CRON=1
</code></pre>
</div><p>Ahora debemos decirle a Postfix que utilice SpamAssassin como filtro para identificar correos spam. Para ello, agregaremos lo siguiente a su configuración:</p>
<div><pre><code>nano /etc/postfix/master.cf
</code></pre>
</div><hr>
<div><pre><code>smtp      inet  n       -       y       -       -       smtpd
  -o content_filter=spamassassin
submission inet n       -       y       -       -       smtpd
  -o content_filter=spamassassin
spamassassin unix -     n       n       -       -       pipe
  user=debian-spamd argv=/usr/bin/spamc -f -e /usr/sbin/sendmail -oi -f ${sender} ${recipient}
</code></pre>
</div><p>Para concluir la configuración de SpamAssassin, vamos a establecer cómo serán identificados los mensajes de correo considerados como spam. Para ello, editamos el archivo <code>/etc/spamassassin/local.cf</code> y activamos la siguiente línea removiendo el comentario:</p>
<div><pre><code>nano /etc/spamassassin/local.cf

rewrite_header Subject *****SPAM*****
</code></pre>
</div><p>Para hacer efectivos los cambios en la configuración, debemos reiniciar los servicios correspondientes.</p>
<div><pre><code>systemctl restart postfix spamassassin
</code></pre>
</div><p>Para verificar si el filtro anti-spam está funcionando correctamente, podemos enviarnos un correo de prueba que incluya la siguiente línea:</p>
<div><pre><code>XJS*C4JDBQADN1.NSBN3*2IDNEN*GTUBE-STANDARD-ANTI-UBE-TEST-EMAIL*C.34X
</code></pre>
</div><p>Cualquier correo que contenga la anterior cadena es inmediatamente considerado como spam, por lo que es perfecta para realizar las pruebas que necesitamos. De esta forma, mandamos el siguiente correo:</p>
<p><img src="./../images/SRI/correos/1_6.png" alt="image"></p>
<p>Ahora comprobemos si el mensaje aparece en los logs como si fuera spam:</p>
<p><img src="./../images/SRI/correos/2_6.png" alt="image"></p>
<p>En los logs aparece como spam. Veamos si lo marca como spam en nuestro buzón:</p>
<p><img src="./../images/SRI/correos/3_6.png" alt="image"></p>
<p>Como vemos, lo ha marcado como spam y ha añadido la cabecera que le indicamos, por lo que podemos identificar los correos spam de forma mucho más sencilla.</p>
<ul>
<li><strong><em>Tarea 7</em>: (No obligatoria): Configura un sistema antivirus. Realiza comprobaciones para comprobarlo.</strong></li>
</ul>
<p>Para añadir una capa extra de seguridad contra virus en los correos, utilizaremos &quot;ClamAV&quot;. Este programa funcionará como filtro adicional para los mensajes que recibamos a través de postfix y nos notificará sobre aquellos que considere como virus. Antes de poder emplear &quot;ClamAV&quot;, es necesario instalar algunos paquetes específicos.</p>
<div><pre><code>apt install clamsmtp clamav-daemon arc arj bzip2 cabextract lzop nomarch p7zip pax tnef
</code></pre>
</div><p>Al instalarlo, se ha creado un proceso que escucha en la interfaz de loopback:</p>
<div><pre><code>netstat -tlnp | egrep clamsmtp
</code></pre>
</div><p><img src="./../images/SRI/correos/1_7.png" alt="image"></p>
<p>A continuación debemos arrancar y habilitar el demonio de ClamAV:</p>
<div><pre><code>systemctl start clamav-daemon
systemctl enable clamav-daemon
</code></pre>
</div><p>Ahora es necesario hacer algunos cambios en la configuración de postfix para asegurarnos de que los correos recibidos se escaneen en busca de virus, para ello agregaremos las directivas necesarias.</p>
<div><pre><code>nano /etc/postfix/master.cf
</code></pre>
</div><hr>
<div><pre><code>scan unix -       -       n       -       16       smtp
-o smtp_data_done_timeout=1200
-o smtp_send_xforward_command=yes
-o disable_dns_lookups=yes
127.0.0.1:10025 inet n       -       n       -       16       smtpd
-o content_filter=
-o local_recipient_maps=
-o relay_recipient_maps=
-o smtpd_restriction_classes=
-o smtpd_client_restrictions=
-o smtpd_helo_restrictions=
-o smtpd_sender_restrictions=
-o smtpd_recipient_restrictions=permit_mynetworks,reject
-o mynetworks_style=host
-o smtpd_authorized_xforward_hosts=127.0.0.0/8
</code></pre>
</div><p>También debemos añadir al fichero de configuración principal de postfix el socket por el que debe comunicarse con ClamAV:</p>
<div><pre><code>nano /etc/postfix/main.cf

content_filter = scan:127.0.0.1:10026
</code></pre>
</div><p>Con esto ya estaría listo. Solo tendríamos que reiniciar el servicio de postfix para aplicar los cambios que hemos hecho:</p>
<div><pre><code>systemctl restart postfix
</code></pre>
</div><p>Para probar el antivirus, nos mandaremos un correo desde nuestro cliente que contenga la siguiente cadena:</p>
<div><pre><code>X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
</code></pre>
</div><p>Veamos si funciona el filtro anti-virus. Para ello, enviaremos un correo de prueba que contenga la siguiente línea:</p>
<p><img src="./../images/SRI/correos/2_7.png" alt="image"></p>
<p>Comprobamos que el log muestra que el mensaje ha sido identificado como virus y por lo tanto ha sido descartado. Con esto podemos dar por finalizada la tarea.</p>
<h2 id="gestion-de-correos-desde-un-cliente"> Gestión de correos desde un cliente</h2>
<ul>
<li><strong><em>Tarea 8</em>: Configura el buzón de los usuarios de tipo Maildir. Envía un correo a tu usuario y comprueba que el correo se ha guardado en el buzón Maildir del usuario del sistema correspondiente. Recuerda que ese tipo de buzón no se puede leer con la utilidad mail.</strong></li>
</ul>
<p>Para configurar postfix para usar un buzón de tipo Maildir, debemos editar su configuración principal y especificar que en lugar de mbox, utilice Maildir.</p>
<div><pre><code>nano /etc/postfix/main.cf

home_mailbox = Maildir/
</code></pre>
</div><p>Ahora debemos reiniciar el servicio de postfix para aplicar los cambios:</p>
<div><pre><code>systemctl restart postfix
</code></pre>
</div><p>Debemos reemplazar la herramienta de visualización de correos &quot;mail&quot; por &quot;mutt&quot; porque después de modificar la configuración principal de postfix para utilizar un buzón de tipo Maildir, ya no es posible utilizar &quot;mail&quot;. &quot;Mutt&quot; nos permitirá ver los correos que recibamos.</p>
<div><pre><code>apt install mutt
</code></pre>
</div><p>Para que esta herramienta funcione, debemos crear el siguiente fichero con esta configuración:</p>
<div><pre><code>nano ~/.muttrc
</code></pre>
</div><hr>
<div><pre><code>set mbox_type=Maildir
set folder=&quot;~/Maildir&quot;
set mask=&quot;!^\\.[^.]&quot;
set mbox=&quot;~/Maildir&quot;
set record=&quot;+.Sent&quot;
set postponed=&quot;+.Drafts&quot;
set spoolfile=&quot;~/Maildir&quot;
</code></pre>
</div><p>Para comprobar si los correos están almacenados en el directorio Maildir, verificaremos el contenido del mismo.</p>
<p><img src="./../images/SRI/correos/1_8.png" alt="image"></p>
<p><img src="./../images/SRI/correos/2_8.png" alt="image"></p>
<p>Como vemos lo ha guardado en el directorio Maildir. Para visualizarlo, usaremos la herramienta mutt:</p>
<p><img src="./../images/SRI/correos/3_8.png" alt="image"></p>
<p><img src="./../images/SRI/correos/4_8.png" alt="image"></p>
<p>De esta manera, hemos verificado que los mensajes de correo están siendo guardados en el directorio Maildir y también hemos confirmado que podemos visualizarlos utilizando la herramienta Mutt.</p>
<ul>
<li><strong><em>Tarea 9</em>: Instala configura dovecot para ofrecer el protocolo IMAP. Configura dovecot de manera adecuada para ofrecer autentificación y cifrado.</strong></li>
</ul>
<p><strong>Para realizar el cifrado de la comunicación crea un certificado en LetsEncrypt para el dominio mail.iesgnXX.es. Recuerda que para el ofrecer el cifrado tiene varias soluciones:</strong></p>
<ul>
<li>
<ul>
<li><strong><em>IMAP con STARTTLS</em>: STARTTLS transforma una conexión insegura en una segura mediante el uso de SSL/TLS. Por lo tanto usando el mismo puerto 143/tcp tenemos cifrada la comunicación.</strong></li>
</ul>
</li>
<li>
<ul>
<li><strong><em>IMAPS</em>: Versión segura del protocolo IMAP que usa el puerto 993/tcp.</strong></li>
</ul>
</li>
<li>
<ul>
<li><strong>Ofrecer las dos posibilidades.</strong></li>
</ul>
</li>
</ul>
<p><strong>Elige una de las opciones anterior para realizar el cifrado. Y muestra la configuración de un cliente de correo (evolution, thunderbird, …) y muestra como puedes leer los correos enviado a tu usuario.</strong></p>
<p>Para empezar vamos a instalar dovecot en la VPS:</p>
<div><pre><code>apt install dovecot-imapd
</code></pre>
</div><p>Al instalarlo, habrá creado un proceso que estará escuchando en dos sockets TCP/IP diferentes: en el puerto 143 y en el puerto 993:</p>
<div><pre><code>netstat -tlnp | egrep dovecot
</code></pre>
</div><p><img src="./../images/SRI/correos/1_9.png" alt="image"></p>
<p>Vamos a obtener un certificado LetsEncrypt para el dominio mail.olucass.com para cifrar las comunicaciones.</p>
<div><pre><code>certbot certonly --standalone -d mail.olucass.com
</code></pre>
</div><p><img src="./../images/SRI/correos/2_9.png" alt="image"></p>
<p>Para proteger la comunicación, vamos a utilizar un certificado generado por LetsEncrypt para el dominio mail.olucass.com. Para hacer uso de este certificado, debemos ajustar la configuración de dovecot.</p>
<div><pre><code>nano /etc/dovecot/conf.d/10-ssl.conf
</code></pre>
</div><hr>
<div><pre><code>ssl_cert = &lt;/etc/letsencrypt/live/mail.olucass.com-0001/fullchain.pem
ssl_key = &lt;/etc/letsencrypt/live/mail.olucass.com-0001/privkey.pem
</code></pre>
</div><p>Indicaremos a dovecot la ubicación de los correos que deben ser cifrados y sincronizados con el cliente, los cuales se encuentran en el directorio ~/Maildir.</p>
<div><pre><code>nano /etc/dovecot/conf.d/10-mail.conf

mail_location = maildir:~/Maildir
</code></pre>
</div><p>Ahora reiniciaremos el servicio de dovecot para aplicar los cambios:</p>
<div><pre><code>systemctl restart dovecot
</code></pre>
</div><p>Estaremos verificando tanto la recepción de correo como el envío desde el cliente en la siguiente sección, al momento de configurar Evolution, que requiere también la configuración para el envío.</p>
<ul>
<li>
<p><strong><em>Tarea 11</em>: Configura de manera adecuada postfix para que podamos mandar un correo desde un cliente remoto. La conexión entre cliente y servidor debe estar autentificada con SASL usando dovecor y además debe estar cifrada. Para cifrar esta comunicación puedes usar dos opciones:</strong></p>
<ul>
<li>
<p><strong><em>ESMTP + STARTTLS</em>: Usando el puerto 567/tcp enviamos de forma segura el correo al servidor.</strong></p>
</li>
<li>
<p><strong><em>SMTPS</em>: Utiliza un puerto no estándar (465) para SMTPS (Simple Mail Transfer Protocol Secure). No es una extensión de smtp. Es muy parecido a HTTPS.</strong></p>
</li>
</ul>
</li>
</ul>
<p>Continuando con la tarea anterior, modificaremos la configuración de postfix para asegurar el envío de correos cifrados. Para ello, utilizaremos los certificados generados y estableceremos la autenticación a través de dovecot.</p>
<div><pre><code>nano /etc/postfix/main.cf
</code></pre>
</div><hr>
<div><pre><code>smtpd_tls_cert_file=/etc/letsencrypt/live/mail.olucass.com-0001/fullchain.pem
smtpd_tls_key_file=/etc/letsencrypt/live/mail.olucass.com-0001/privkey.pem

smtpd_sasl_auth_enable = yes
smtpd_sasl_type = dovecot
smtpd_sasl_path = private/auth
smtpd_sasl_authenticated_header = yes
broken_sasl_auth_clients = yes
</code></pre>
</div><p>Para usar los puertos 587/TCP y 465/TCP con postfix, deberemos modificar el archivo de configuración correspondiente y activar las directivas relevantes.</p>
<div><pre><code>nano /etc/postfix/master.cf
</code></pre>
</div><hr>
<div><pre><code>submission inet n       -       y       -       -       smtpd
  -o content_filter=spamassassin
  -o syslog_name=postfix/submission
  -o smtpd_tls_security_level=encrypt
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_tls_auth_only=yes
  -o smtpd_reject_unlisted_recipient=no
  -o smtpd_client_restrictions=$mua_client_restrictions
  -o smtpd_helo_restrictions=$mua_helo_restrictions
  -o smtpd_sender_restrictions=$mua_sender_restrictions
  -o smtpd_recipient_restrictions=
  -o smtpd_relay_restrictions=permit_sasl_authenticated,reject
  -o milter_macro_daemon_name=ORIGINATING
smtps     inet  n       -       y       -       -       smtpd
  -o syslog_name=postfix/smtps
  -o smtpd_tls_wrappermode=yes
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_reject_unlisted_recipient=no
  -o smtpd_client_restrictions=$mua_client_restrictions
  -o smtpd_helo_restrictions=$mua_helo_restrictions
  -o smtpd_sender_restrictions=$mua_sender_restrictions
  -o smtpd_recipient_restrictions=
  -o smtpd_relay_restrictions=permit_sasl_authenticated,reject
  -o milter_macro_daemon_name=ORIGINATING
</code></pre>
</div><p>A continuación debemos indicar a dovecot como tiene que realizar la autentificación. Para ello modificamos el siguiente fichero:</p>
<div><pre><code>nano /etc/dovecot/conf.d/10-master.conf

unix_listener /var/spool/postfix/private/auth {
mode = 0666
}
</code></pre>
</div><p>Con esto ya podemos reiniciar los servicios de postfix y dovecot para aplicar los cambios:</p>
<div><pre><code>systemctl restart postfix dovecot
</code></pre>
</div><p>Ahora ya podemos configurar el cliente de correos en nuestro anfitrión. En mi caso he elegido el cliente de correos “Evolution”</p>
<p><img src="./../images/SRI/correos/1_11.png" alt="image"></p>
<p><img src="./../images/SRI/correos/2_11.png" alt="image"></p>
<p><img src="./../images/SRI/correos/3_11.png" alt="image"></p>
<p><img src="./../images/SRI/correos/4_11.png" alt="image"></p>
<p>Una vez finalizados los cambios, podemos verificar si las carpetas ~/Maildir en la VPS se han sincronizado con el cliente de correos Evolution. Para ello, Evolution nos solicitará la contraseña de nuestro usuario en la VPS.</p>
<p><img src="./../images/SRI/correos/5_11.png" alt="image"></p>
<p>Vamos a probar si al mandar un correo desde gmail hasta nuestra vps se sincronizan las carpetas:</p>
<p><img src="./../images/SRI/correos/6_11.png" alt="image"></p>
<p><img src="./../images/SRI/correos/7_11.png" alt="image"></p>
<p>Como vemos, lo hemos recibido en el cliente Evolution, por lo que podemos decir que ambos directorios se sincronizan perfectamente.</p>
<p>Ahora comprobemos si somos capaces de enviar correos desde Evolution usando nuestra cuenta de la VPS a nuestro gmail:</p>
<p><img src="./../images/SRI/correos/8_11.png" alt="image"></p>
<p><img src="./../images/SRI/correos/9_11.png" alt="image"></p>
<p>Podemos comprobar que el mensaje se ha entregado correctamente, lo que indica que los procesos previos y este en sí han sido un éxito.</p>
<p><strong>Elige una de las opciones anterior para realizar el cifrado. Y muestra la configuración de un cliente de correo (evolution, thunderbird, …) y muestra como puedes enviar los correos.</strong></p>
<ul>
<li><strong><em>Tarea 10</em>: (No obligatoria): Instala un webmail (roundcube, horde, rainloop) para gestionar el correo del equipo mediante una interfaz web. Muestra la configuración necesaria y cómo eres capaz de leer los correos que recibe tu usuario.</strong></li>
</ul>
<p>He optado por utilizar Roundcube como webmail. Para su instalación en la VPS, elegí la opción de contenedores Docker, ya que cuenta con una imagen oficial en Docker Hub. Primero, debemos instalar Docker en la VPS.</p>
<div><pre><code>apt install docker.io
</code></pre>
</div><p>También crearemos un nuevo registro CNAME en el DNS para el nuevo servicio web:</p>
<p><img src="./../images/SRI/correos/1_10.png" alt="image"></p>
<p>Con esto ya podemos crear el contenedor con la imagen de “roundcube”:</p>
<div><pre><code>docker run -e ROUNDCUBEMAIL_DEFAULT_HOST=ssl://mail.olucass.com -e ROUNDCUBEMAIL_SMTP_SERVER=ssl://mail.olucass.com -e ROUNDCUBEMAIL_SMTP_PORT=465 -e ROUNDCUBEMAIL_DEFAULT_PORT=993 -p 8001:80 -d roundcube/roundcubemail
</code></pre>
</div><p>Una vez que se haya instalado Docker y creado el contenedor de roundcube, será necesario obtener un certificado de Let's Encrypt para configurar la conexión segura HTTPS.</p>
<div><pre><code>certbot certonly --standalone -d roundcube.olucass.com
</code></pre>
</div><p><img src="./../images/SRI/correos/2_10.png" alt="image"></p>
<p>Obtenido el fichero, ya podemos crear el VirtualHost que actuará como ProxyInverso para acceder a Round Cube:</p>
<div><pre><code>nano /etc/nginx/sites-available/roundcube.conf
</code></pre>
</div><hr>
<div><pre><code>server {
        listen 80;
        listen [::]:80;

        server_name roundcube.olucass.com;

        return 301 https://$host$request_uri;
}

server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;

        ssl    on;
        ssl_certificate /etc/letsencrypt/live/roundcube.olucass.com-0002/fullchain.pem;
        ssl_certificate_key     /etc/letsencrypt/live/roundcube.olucass.com-0002/privkey.pem;

        index index.html index.php index.htm index.nginx-debian.html;

        server_name roundcube.olucass.com;

        location / {
                proxy_pass http://localhost:8001;
                include proxy_params;
        }
}
</code></pre>
</div><p>A continuación creamos el enlace simbólico y reiniciamos nginx:</p>
<div><pre><code>ln -s /etc/nginx/sites-available/roundcube.conf /etc/nginx/sites-enabled/roundcube.conf
</code></pre>
</div><hr>
<div><pre><code>systemctl restart nginx
</code></pre>
</div><p>Una vez que hemos terminado, ya podemos acceder a Round Cube desde nuestro navegador web:</p>
<p><img src="./../images/SRI/correos/3_10.png" alt="image"></p>
<p>Ingresamos con nuestras credenciales:</p>
<p><img src="./../images/SRI/correos/4_10.png" alt="image"></p>
<p>Para confirmar que todo está funcionando correctamente, enviaremos un correo desde Gmail y lo revisaremos en nuestro buzón de correos en el webmail Roundcube.</p>
<p><img src="./../images/SRI/correos/5_10.png" alt="image"></p>
<p><img src="./../images/SRI/correos/6_10.png" alt="image"></p>
<p>Con esto hemos comprobado que la recepción de correos funciona.</p>
<ul>
<li><strong><em>Tarea 12</em>: (No obligatoria): Configura el cliente webmail para el envío de correo. Realiza una prueba de envío con el webmail.</strong></li>
</ul>
<p>Todo fue ajustado en las actividades previas, así que procederemos a probar el envío de un correo electrónico desde el servicio de correo web.</p>
<p><img src="./../images/SRI/correos/1_12.png" alt="image"></p>
<p><img src="./../images/SRI/correos/2_12.png" alt="image"></p>
<p><img src="./../images/SRI/correos/3_12.png" alt="image"></p>
<p>Podemos afirmar que el servicio de Gmail ha sido efectivo al recibir y enviar correos electrónicos en mi cuenta.</p>
<h2 id="comprobacion-final"> Comprobación final</h2>
<ul>
<li><strong><em>Tarea 13</em>: Prueba de envío de correo. En esta <a href="https://www.mail-tester.com/" target="_blank" rel="noopener noreferrer">página<i>Content not supported</i></a> tenemos una herramienta completa y fácil de usar a la que podemos enviar un correo para que verifique y puntúe el correo que enviamos. Captura la pantalla y muestra la puntuación que has sacado.</strong></li>
</ul>
<p>En consecuencia, haremos una prueba al enviar el correo a la dirección indicada y determinaremos nuestra calificación.</p>
<p><img src="./../images/SRI/correos/1_13.png" alt="image"></p>
<p><img src="./../images/SRI/correos/2_13.png" alt="image"></p>
<p>Los resultados son los siguientes:</p>
<p><img src="./../images/SRI/correos/3_13.png" alt="image"></p>
<p>A pesar de que el resultado aparenta ser insuficiente, en realidad es debido a factores que no se consideraron durante el proceso, por lo que podemos considerar la tarea completada.</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Almacenamiento</title>
    <id>https://github.com/oscarlucas22/practicas/almacenamiento/</id>
    <link href="https://github.com/oscarlucas22/practicas/almacenamiento/"/>
    <updated>2023-03-07T17:02:54.435Z</updated>
    <content type="html"><![CDATA[<h1 id="almacenamiento"> Almacenamiento</h1>
<h2 id="alumno-3"> Alumno 3:</h2>
<p><em><strong>orACLE:</strong></em></p>
<ol>
<li><strong>Muestra los objetos a los que pertenecen las extensiones del tablespace TS2 (creado por Alumno 2) y el tamaño de cada una de ellas.</strong></li>
</ol>
<p>Creamos un tablespace llamado TS2 que me ha mandado Alumno2.</p>
<div><pre><code>create TABLESPACE TS2
DATAFILE '/opt/oracle/ts2_1.dbf' 
SIZE 1M, '/opt/oracle/ts2_2.dbf' SIZE 1M;
</code></pre>
</div><p>Podemos verificar que ya tenemos nuestro tablespace creado y determinar su ubicación.</p>
<div><pre><code>select file_name, tablespace_name from dba_data_files where tablespace_name='TS2';
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/1_1.png" alt="image"></p>
<p>Haremos una prueba breve para evaluar el funcionamiento del espacio.</p>
<div><pre><code>create table pruebats2 (           
	mt_clave       number(3)    not null,
	mt_descripcion varchar2(50) null
	)  
	TABLESPACE TS2; 
</code></pre>
</div><p>Agregaremos algo de contenido.</p>
<div><pre><code>insert into pruebats2 (mt_clave, mt_descripcion) values (123, 'clave prueba1');
insert into pruebats2 (mt_clave, mt_descripcion) values (456, 'clave prueba2');
</code></pre>
</div><p>Verificaremos cuánto espacio libre ocupa actualmente nuestro tablespace.</p>
<div><pre><code>select tablespace_name, to_char(sum(nvl(bytes,0))/1024/1024, '99,999,990.99') as &quot;free space&quot;
from user_free_space
where tablespace_name = 'TS2'
group by tablespace_name;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/2_1.png" alt="image"></p>
<ol start="2">
<li><strong>Borra la tabla que está llenando TS2 consiguiendo que vuelvan a existir extensiones libres. Añade después otro fichero de datos a TS2.</strong></li>
</ol>
<p>Eliminaremos la tabla previamente creada y comprobaremos el espacio de almacenamiento de nuestro tablespace.</p>
<div><pre><code>drop table pruebats2;
</code></pre>
</div><hr>
<div><pre><code>select tablespace_name, to_char(sum(nvl(bytes,0))/1024/1024, '99,999,990.99') as &quot;free space&quot;
from user_free_space
where tablespace_name = 'TS2'
group by tablespace_name;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/1_2.png" alt="image"></p>
<p>Para comenzar, veremos los archivos que estamos utilizando:</p>
<div><pre><code>select substr(name, 1, 255)
from v$datafile;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/2_2.png" alt="image"></p>
<p>Agendaremos un nuevo archivo y verificaremos que se ha agregado a nuestro tablespace.</p>
<div><pre><code>alter tablespace TS2 add datafile '/home/oracle/prueba.dbf' size 10M;
</code></pre>
</div><hr>
<div><pre><code>select file_name,tablespace_name
from dba_data_files
where tablespace_name='TS2';
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/3_2.png" alt="image"></p>
<ol start="3">
<li><strong>Crea el tablespace TS3 gestionado localmente con un tamaño de extension uniforme de 128K y un fichero de datos asociado. Cambia la ubicación del fichero de datos y modifica la base de datos para que pueda acceder al mismo. Crea en TS3 dos tablas e inserta registros en las mismas. Comprueba que segmentos tiene TS3, qué extensiones tiene cada uno de ellos y en qué ficheros se encuentran.</strong></li>
</ol>
<p>Crearemos el nuevo tablespace TS3, que tendra un fichero añadido y una extension uniforme de 128K.</p>
<div><pre><code>create tablespace TS3 datafile '/home/oracle/ts3.dbf' size 50M extent management local uniform size 128K;
</code></pre>
</div><hr>
<div><pre><code>select file_name, tablespace_name
from dba_data_files
where tablespace_name='TS3';
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/1_3.png" alt="image"></p>
<p>Para modificar los archivos dentro de un tablespace indicado, primero deberemos apagarlo.</p>
<div><pre><code>alter tablespace TS3 offline;
</code></pre>
</div><p>Ahora procederemos a las modificacion de la ubicación del fichero.</p>
<div><pre><code>mv ts3.dbf ejer3/
</code></pre>
</div><hr>
<div><pre><code>alter tablespace TS3 rename datafile '/home/oracle/ts3.dbf' to '/home/oracle/ejer3/ts3.dbf';
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/2_3.png" alt="image"></p>
<p>Activamos el tablespace y comprobamos la nueva configuración.</p>
<div><pre><code>alter tablespace TS3 online;
</code></pre>
</div><hr>
<div><pre><code>select file_name, tablespace_name
from dba_data_files
where tablespace_name='TS3';
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/3_3.png" alt="image"></p>
<p>Creamos nuevas tablas y registros en TS3:</p>
<div><pre><code>create table peliculas (
	id_pelicula number PRIMARY KEY,
	titulo varchar2(100) not null,
	director varchar2(100) not null,
	fecha_lanzamiento DATE not null,
	duracion number not null
) tablespace TS3;


insert into peliculas (id_pelicula, titulo, director, fecha_lanzamiento, duracion)
values (2, 'The Avengers', 'Joss Whedon', to_date('04/05/2012'), 143);
insert into peliculas (id_pelicula, titulo, director, fecha_lanzamiento, duracion)
values (3, 'Interstellar', 'Christopher Nolan', to_date('05/11/2014'), 169);
insert into peliculas (id_pelicula, titulo, director, fecha_lanzamiento, duracion)
values (4, 'Inception', 'Christopher Nolan', to_date('06/07/2014'), 148);
insert into peliculas (id_pelicula, titulo, director, fecha_lanzamiento, duracion)
values (5, 'The Shawshank Redemption', 'Frank Darabont', to_date('23/09/1994'), 142);
</code></pre>
</div><hr>
<div><pre><code>create TABLE cines (
	id_cine number PRIMARY KEY,
	nombre varchar2(100) not null,
	direccion varchar2(200) not null,
	telefono varchar2(20) not null,
	numero_salas number not null
) tablespace TS3;


insert into cines (id_cine, nombre, direccion, telefono, numero_salas)
values (1, 'Cine 1', 'Dirección 1', '1234567890', 5);
insert into cines (id_cine, nombre, direccion, telefono, numero_salas)
values (2, 'Cine 2', 'Dirección 2', '0987654321', 7);
insert into cines (id_cine, nombre, direccion, telefono, numero_salas)
values (3, 'Cine 3', 'Dirección 3', '1112223333', 8);
insert into cines (id_cine, nombre, direccion, telefono, numero_salas)
values (4, 'Cine 4', 'Dirección 4', '4445556666', 9);
</code></pre>
</div><p>Comprobamos:</p>
<div><pre><code>select de.segment_name,de.extent_id,df.file_name,de.file_id
from dba_data_files  df, dba_extents de
where de.file_id = df.file_id
and de.tablespace_name = 'TS3'; 
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/4_3.png" alt="image"></p>
<ol start="4">
<li><strong>Redimensiona los ficheros asociados a los tres tablespaces que has creado de forma que ocupen el mínimo espacio posible para alojar sus objetos.</strong></li>
</ol>
<p>Comprobamos el espacio de almacenamiento de nuestros tablespaces:</p>
<div><pre><code>select sum(bytes)/1024||'KB', tablespace_name
from dba_segments
where tablespace_name like 'TS%'
group by tablespace_name;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/1_4.png" alt="image"></p>
<p>Redimensionaremos los ficheros y comprobaremos el espacio que ocupan.</p>
<div><pre><code>alter database datafile '/opt/oracle/ts2_1.dbf' resize 3M;
alter database datafile '/opt/oracle/ts2_2.dbf' resize 3M;
</code></pre>
</div><hr>
<div><pre><code>alter database datafile '/home/oracle/ejer3/ts3.dbf' resize 20M;
</code></pre>
</div><hr>
<div><pre><code>select sum(bytes)/1024||'KB', tablespace_name
from dba_segments
where tablespace_name like 'TS%'
group by tablespace_name;
</code></pre>
</div><hr>
<div><pre><code>select file_name,tablespace_name,(bytes/1024)||'KB'
from dba_data_files
where tablespace_name like 'TS%';
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/2_4.png" alt="image"></p>
<ol start="5">
<li><strong>Realiza un procedimiento llamado InformeRestricciones que reciba el nombre de una tabla y muestre los nombres de las restricciones que tiene, a qué columna o columnas afectan y en qué consisten exactamente.</strong></li>
</ol>
<p><em>Procedimiento para mostrar objetivo de cada restricción:</em></p>
<div><pre><code>create or replace procedure MostrarColumnaObjetivo(p_cons dba_constraints.constraint_name%type, p_nomtabla dba_constraints.table_name%type)
is
	v_objetivo varchar2(1);
begin
	select constraint_type into v_objetivo from dba_constraints where constraint_name = p_cons and table_name = p_nomtabla;
	if v_objetivo is null then
		dbms_output.put_line(chr(9)||'La restricción no cuenta con una descripción que muestre en que consiste.');
	elsif v_objetivo = 'P' then
		dbms_output.put_line(chr(9)||'Consiste en: Clave primaria');
	elsif v_objetivo = 'R' then
		dbms_output.put_line(chr(9)||'Consiste en: Clave foranea');
	elsif v_objetivo = 'C' then
		dbms_output.put_line(chr(9)||'Consiste en: Check');  
	else
		dbms_output.put_line(chr(9)||'Consiste en: Unique');
	end if;
end;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/5-1.png" alt="image"></p>
<p><em>Procedimiento para mostrar columnas a las que afecta una restricción:</em></p>
<div><pre><code>create or replace procedure MostrarColumnas(p_cons dba_cons_columns.constraint_name%type)
is
	cursor c_cursor is
	select distinct column_name, table_name from dba_cons_columns where constraint_name = p_cons;
begin
	for var in c_cursor loop
		dbms_output.put_line(chr(9)||'Columna afectada: '||var.column_name);
		MostrarColumnaObjetivo(p_cons, var.table_name);
	end loop;
end;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/5-2.png" alt="image"></p>
<p><em>Procedimiento para mostrar las restricciones que tiene la tabla que introducimos:</em></p>
<div><pre><code>create or replace procedure MostrarRestricciones(p_nomtabla dba_tables.table_name%type)
is
	cursor c_cursor is
	select distinct constraint_name from dba_constraints where table_name=p_nomtabla;
begin
	for var in c_cursor loop
		dbms_output.put_line(chr(10)||'Restriccion: '||var.constraint_name);
		MostrarColumnas(var.constraint_name);
	end loop;
end;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/5-3.png" alt="image"></p>
<p><em>Procedimiento principal (InformeRestricciones):</em></p>
<div><pre><code>create or replace procedure InformeRestricciones (p_nomtabla dba_tables.table_name%type)
is
begin
	MostrarRestricciones(p_nomtabla);
	end InformeRestricciones;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/5-4.png" alt="image"></p>
<div><pre><code>create table Alumnos(
	Nombre number(4),
	DNI varchar2(9),
	Curso number(4),
	constraint pk_nombre primary key (Nombre),
	constraint uk_dni unique (DNI),
	constraint ck_curso check (Curso in ('1ASIR', '2ASIR', '1SMR', '2SMR'))
	);

exec InformeRestricciones('ALUMNOS');
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/5.png" alt="image"></p>
<ol start="6">
<li>
<p><strong>Realiza un procedimiento llamado MostrarAlmacenamientoUsuario que reciba el nombre de un usuario y devuelva el espacio que ocupan sus objetos agrupando por dispositivos y archivos:</strong></p>
<div><pre><code> Usuario: NombreUsuario
 	Dispositivo:xxxx
 		Archivo: xxxxxxx.xxx
 				Tabla1......nnn K
 				…
 				TablaN......nnn K
 				Indice1.....nnn K
 				…
 				IndiceN.....nnn K
 		Total Espacio en Archivo xxxxxxx.xxx: nnnnn K
 		Archivo:...
 		…
 
 	
 	Total Espacio en Dispositivo xxxx: nnnnnn K
 	Dispositivo: yyyy
 	…
 Total Espacio Usuario en la BD: nnnnnnn K
</code></pre>
</div></li>
</ol>
<hr>
<p><em>Procedimiento mostrar TablaN......nnn K</em></p>
<div><pre><code>create or replace procedure TablasArchivo(p_nomuser varchar2, p_archivo number)
is
	cursor c_cursor is
	select distinct t.table_name, e.bytes/1024 as K from dba_tables t, dba_extents e where t.owner = upper(p_nomuser) and t.owner=e.owner and e.file_id=p_archivo;
begin
	for var IN c_cursor loop
		dbms_output.put_line(chr(10)||chr(9)||chr(9)||chr(9)||var.table_name||'......'||var.K||' K');
	end loop;
end;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/6-1.png" alt="image"></p>
<p><em>Procedimiento mostrar IndiceN......nnn K</em></p>
<div><pre><code>create or replace procedure IndiceArchivo(p_nomuser varchar2, p_archivo number)
is
	cursor c_cursor is
	select distinct i.index_name, e.bytes/1024 as KI from dba_indexes i, dba_extents e where i.owner = upper(p_nomuser) and i.owner=e.owner and e.file_id=p_archivo;
begin
	for var in c_cursor loop
		dbms_output.put_line(chr(9)||chr(9)||chr(9)||var.index_name||'......'||var.KI||' K');
	end loop;
end;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/6-2.png" alt="image"></p>
<p><em>Funcion total espacio archivos</em></p>
<div><pre><code>create or replace function f_TotalArchivo (p_nomuser varchar2,p_idfile number)
return number
is
	v_total number;
begin
	select distinct a.user_bytes/1024 into v_total from dba_data_files a, dba_extents b  where b.owner = upper(p_nomuser) and a.file_id = b.file_id and a.file_id = p_idfile;
	return v_total;
end;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/6-3.png" alt="image"></p>
<p><em>Funcion total espacio en dispositivo</em></p>
<div><pre><code>create or replace function f_TotalDispositivo (p_nomuser varchar2,p_idfile number)
return number
is
	v_total number;
begin
	select distinct sum(a.user_bytes)/1024 into v_total from dba_data_files a, dba_extents b  where b.owner = upper(p_nomuser) and a.file_id = b.file_id and a.file_id = p_idfile;
	return v_total;
end;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/6-4.png" alt="image"></p>
<p><em>Funcion total espacio en bd</em></p>
<div><pre><code>create or replace function f_TotalUsuario (p_nomuser varchar2)
return number
is
	v_total number;
begin
	select sum(bytes)/1024 into v_total from dba_segments where owner = upper(p_nomuser);
	return v_total;
end;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/6-5.png" alt="image"></p>
<p><em>Procedimiento mostrar dispositivos y archivos</em></p>
<div><pre><code>create or replace procedure DispositivoArchivo (p_nomuser varchar2)
is
cursor c_cursor is
select distinct REGEXP_SUBSTR(f.file_name, '^/[^/]+') as dispositivo, f.file_name as archivo, f.file_id, regexp_substr (f.file_name, '[^/]+$') as nombre_archivo from dba_extents e, dba_data_files f where f.file_id=e.file_id and owner = upper(p_nomuser);
begin
	for var in c_cursor loop
		dbms_output.put_line(chr(10)||chr(9)||'Dispositivo: '||var.dispositivo||chr(10)||chr(10)||chr(9)||chr(9)||'Archivo: '||var.archivo);
		TablasArchivo(p_nomuser,var.file_id);
		dbms_output.put_line(chr(9));
		IndiceArchivo(p_nomuser,var.file_id);
		dbms_output.put_line(chr(10)||chr(9)||chr(9)||'Total Espacio en Archivo '||var.nombre_archivo||': '||f_TotalArchivo(p_nomuser,var.file_id)||' K');
		dbms_output.put_line(chr(10)||chr(9)||'Total Espacio en Dispositivo '||var.dispositivo||': '||f_TotalDispositivo(p_nomuser,var.file_id)||' K');
end loop;
dbms_output.put_line(chr(10)||'Total Espacio Usuario en la BD: '||f_TotalUsuario(p_nomuser)||' K');
end;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/6-6.png" alt="image"></p>
<p><em>Procedimiento principal MostrarAlmacenamientoUsuario</em></p>
<div><pre><code>create or replace procedure MostrarAlmacenamientoUsuario (p_nomuser varchar2)
is
begin
	dbms_output.put_line(chr(10)||'Usuario: '||p_nomuser);
	DispositivoArchivo(p_nomuser);
end MostrarAlmacenamientoUsuario;
/
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/6-7.png" alt="image"></p>
<p><em>Comprobación</em></p>
<div><pre><code>exec MostrarAlmacenamientoUsuario('SCOTT');
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/6.png" alt="image"></p>
<p><em><strong>Postgres:</strong></em></p>
<ol start="7">
<li><strong>Averigua si es posible establecer cuotas de uso sobre los tablespaces en Postgres.</strong></li>
</ol>
<p>Sí, es posible establecer cuotas de uso en los tablespaces en PostgreSQL, pero no es una funcionalidad incorporada en la base de datos. Se pueden crear scripts personalizados o utilizar herramientas de terceros para limitar el espacio de almacenamiento disponible para cada usuario en un tablespace específico. Sin embargo, es importante tener en cuenta que esto puede ser un proceso complejo y requiere una planificación cuidadosa.</p>
<p><em><strong>MySQL:</strong></em></p>
<ol start="8">
<li><strong>Averigua si existe el concepto de extensión en MySQL y si coincide con el existente en Oracle.</strong></li>
</ol>
<p>No, en MySQL no existe el concepto de extensión. Sin embargo, MySQL permite la utilización de complementos o plugins que permiten ampliar las funcionalidades del sistema. Estos plugins se pueden instalar en el servidor de MySQL y proporcionan nuevas funcionalidades que no vienen incorporadas en la versión estándar de MySQL. Por ejemplo, existen plugins de seguridad, optimización, y también plugins que permiten habilitar nuevos protocolos de comunicación o mejorar la escalabilidad y rendimiento del sistema.</p>
<p>¿Coincide con el existente en Oracle?</p>
<p>Sí, en oracle existe un concepto similar al de las extensiones de MySQL, que se conoce como &quot;Paquetes&quot;. Los paquetes en oracle son un conjunto de funciones y procedimientos relacionados que se agrupan en un solo objeto lógico. Estos paquetes permiten encapsular lógica de negocios y compartirla fácilmente entre múltiples aplicaciones o usuarios.</p>
<p>Además de los paquetes, oracle también tiene otras características similares a las extensiones de MySQL, como por ejemplo, &quot;funciones externas&quot; (que permiten extender la funcionalidad de oracle utilizando lenguajes de programación externos) y &quot;tipos objeto&quot; (que permiten definir tipos de datos complejos en oracle).</p>
<p>En resumen, aunque el concepto no es exactamente el mismo, oracle tiene características similares a las extensiones de MySQL que permiten ampliar y mejorar la funcionalidad del sistema.</p>
<p><em><strong>MongoDB:</strong></em></p>
<ol start="9">
<li><strong>Averigua si en MongoDB puede saberse el espacio disponible para almacenar nuevos documentos.</strong></li>
</ol>
<p>Mongo posee una serie de funciones para mostrar diferentes datos de almacenamiento.</p>
<p>Ejemplos:</p>
<div><pre><code>#El tamaño de los datos en la colección.
db.collection.dataSize(): 

#Ver tamaño de un índice.
db.collection.index.stats().indexSizes:

#El tamaño de los datos más el de los índices.
db.collection.totalSize():

#El tamaño de los índices.
db.collection.totalIndexSize():
</code></pre>
</div><h2 id="parte-grupal"> Parte grupal:</h2>
<ol start="3">
<li><strong>Cread una secuencia para rellenar el campo deptno de la tabla dept de forma coherente con los datos ya existentes. Insertad al menos dos registros haciendo uso de la secuencia.</strong></li>
</ol>
<p>Creare una secuencia que incremente el codigo en 10 empezando desde el numero 50 y no se repita.</p>
<div><pre><code>create sequence secuenciaDeptno
start with 50
increment by 10
nocycle;
</code></pre>
</div><hr>
<div><pre><code>insert into scott.dept (DEPTNO, DNAME, LOC) values (secuenciaDeptno.nextval, 'ACCOUNTING', 'BOSTON');
insert into scott.dept (DEPTNO, DNAME, LOC) values (secuenciaDeptno.nextval, 'ACCOUNTING', 'MIAMI');
</code></pre>
</div><hr>
<div><pre><code>select * from scott.dept;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/3-grupal.png" alt="image"></p>
<ol start="8">
<li><strong>Resolved el siguiente caso práctico en orACLE:</strong></li>
</ol>
<p><strong>En nuestra empresa existen tres departamentos: Informática, Ventas y Producción. En Informática trabajan tres personas: Pepe, Juan y Clara. En Ventas trabajan Ana y Eva y en Producción Jaime y Lidia.</strong></p>
<p>a) <strong>Pepe es el administrador de la base de datos. Juan y Clara son los programadores de la base de datos, que trabajan tanto en la aplicación que usa el departamento de Ventas como en la usada por el departamento de Producción. Ana y Eva tienen permisos para insertar, modificar y borrar registros en las tablas de la aplicación de Ventas que tienes que crear, y se llaman Productos y Ventas, siendo propiedad de Ana. Jaime y Lidia pueden leer la información de esas tablas pero no pueden modificar la información. Crea los usuarios y dale los roles y permisos que creas conveniente.</strong></p>
<div><pre><code>create USER Pepe identified by Pepe;
GRANT dba to Pepe;
</code></pre>
</div><hr>
<div><pre><code>create USER Juan identified by Juan;
GRANT resource to Juan;
</code></pre>
</div><hr>
<div><pre><code>create USER Clara identified by Clara;
GRANT resource to Clara;
</code></pre>
</div><hr>
<div><pre><code>create TABLE Informatica (
id number(10) PRIMARY KEY,
fecha DATE not null,
producto varchar2(50) not null,
descripcion varchar2(200) not null,
precio number(10,2) not null
);
</code></pre>
</div><hr>
<div><pre><code>create USER Ana identified by Ana; 
GRANT create SESSION to Ana;
GRANT create table to Ana;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.1_grupal.png" alt="image"></p>
<div><pre><code>/q
sqlplus Ana/Ana

create TABLE Ventas (
id number(10) PRIMARY KEY,
fecha DATE not null,
producto varchar2(50) not null,
cantidad number(10) not null,
precio number(10,2) not null
);

create TABLE Productos (
id number(10) PRIMARY KEY,
fecha DATE not null,
producto varchar2(50) not null,
cantidad number(10) not null,
ubicacion varchar2(50) not null
);
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.2_grupal.png" alt="image"></p>
<div><pre><code>create USER Eva identified by Eva;
GRANT select on Ana.Ventas to Eva;
GRANT insert on Ana.Ventas to Eva;
GRANT update on Ana.Ventas to Eva;
GRANT delete on Ana.Ventas to Eva;
GRANT select on Ana.Productos to Eva;
GRANT insert on Ana.Productos to Eva;
GRANT update on Ana.Productos to Eva;
GRANT delete on Ana.Productos to Eva;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.3_grupal.png" alt="image"></p>
<div><pre><code>create USER Jaime identified by Jaime;
create USER Lidia identified by Lidia;
GRANT select on Ana.Ventas to Jaime;
GRANT select on Ana.Ventas to Lidia;
GRANT select on Ana.Productos to Jaime;
GRANT select on Ana.Productos to Lidia;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.4_grupal.png" alt="image"></p>
<p>Roles:</p>
<div><pre><code>#Producción
create ROLE Produccion;
GRANT select on Ana.Ventas to Produccion;
GRANT select on Ana.Productos to Produccion;

GRANT Produccion to Lidia;
GRANT Produccion to Jaime;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.5_grupal.png" alt="image"></p>
<div><pre><code>#Ventas
create ROLE Ventas;
GRANT select, insert, update, delete on Ana.Ventas to Ventas;
GRANT select, insert, update, delete on Ana.Productos to Ventas;
GRANT Ventas to Eva;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.6_grupal.png" alt="image"></p>
<p>b) <strong>Los espacios de tablas son System, Producción (ficheros prod1.dbf y prod2.dbf) y Ventas (fichero vent.dbf). Los programadores del departamento de Informática pueden crear objetos en cualquier tablespace de la base de datos, excepto en System. Los demás usuarios solo podrán crear objetos en su tablespace correspondiente teniendo un límite de espacio de 30 M los del departamento de Ventas y 100K los del de Producción. Pepe tiene cuota ilimitada en todos los espacios, aunque el suyo por defecto es System.</strong></p>
<p>Tablespace de System, Producción y Ventas:</p>
<div><pre><code>create TABLESPACE ts_produccion
DATAFILE 'prodr1.dbf' SIZE 100M,
'prodr2.dbf' SIZE 100M AUTOEXTend ON;

create TABLESPACE ts_venta
DATAFILE 'venta.dbf'
SIZE 100M AUTOEXTend ON;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.7_grupal.png" alt="image"></p>
<p>Cuotas para los usuarios:</p>
<div><pre><code>ALTER USER ANA QUOTA 30M ON ts_venta;
ALTER USER EVA QUOTA 30M ON ts_venta;
ALTER USER JAIME QUOTA 100K ON ts_produccion;
ALTER USER LIDIA QUOTA 100K ON ts_produccion;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.8_grupal.png" alt="image"></p>
<p>Modificación del tablespace de pepe:</p>
<div><pre><code>ALTER USER Pepe DEFAULT TABLESPACE SYSTEM;
GRANT UNLIMITED TABLESPACE TO Pepe;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.9_grupal.png" alt="image"></p>
<p>Revocamos los privilegios de creación de objetos alos usuarios del tablespace.</p>
<div><pre><code>GRANT UNLIMITED TABLESPACE TO JUAN;
GRANT UNLIMITED TABLESPACE TO CLARA;
ALTER USER JUAN QUOTA 0 ON SYSTEM;
ALTER USER CLARA QUOTA 0 ON SYSTEM;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.10_grupal.png" alt="image"></p>
<p>c) <strong>Pepe quiere crear una tabla Prueba que ocupe inicialmente 256K en el tablespace Ventas.</strong></p>
<div><pre><code>create TABLE Pepe.Prueba (
	Codigo    varchar2(5),
	Nombre    varchar2(30),
	constraint pk_codigo PRIMARY KEY(Codigo)
)
TABLESPACE ts_venta,
STorAGE (INITIAL 256K);
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.11_grupal.png" alt="image"></p>
<p>d) <strong>Pepe decide que los programadores tengan acceso a la tabla Prueba antes creada y puedan ceder ese derecho y el de conectarse a la base de datos a los usuarios que ellos quieran.</strong></p>
<div><pre><code>GRANT select ON Pepe.Prueba TO Juan WITH GRANT OPTION;
GRANT select ON Pepe.Prueba TO Clara WITH GRANT OPTION;
GRANT CONNECT TO Clara WITH ADMIN OPTION;
GRANT CONNECT TO Juan WITH ADMIN OPTION;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.12_grupal.png" alt="image"></p>
<p>f) <strong>Lidia y Jaime dejan la empresa, borra los usuarios y el espacio de tablas correspondiente, detalla los pasos necesarios para que no quede rastro del espacio de tablas.</strong></p>
<p>Borramos los usuarios, añadimos cascade para borrar todo el rastro dejado en otras tablas.</p>
<div><pre><code>DROP USER LIDIA cascade;
DROP USER JAIME cascade;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.13_grupal.png" alt="image"></p>
<p>Para borrar todo lo incluido en el tablespace</p>
<div><pre><code>drop tablespace ts_produccion including contents and datafiles;
</code></pre>
</div><p><img src="./../images/ABD/almacenamiento/8.14_grupal.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Auditoría</title>
    <id>https://github.com/oscarlucas22/practicas/auditoria/</id>
    <link href="https://github.com/oscarlucas22/practicas/auditoria/"/>
    <updated>2023-03-07T17:02:54.437Z</updated>
    <content type="html"><![CDATA[<h1 id="auditoria"> Auditoría</h1>
<h2 id="_1-activa-desde-sql-plus-la-auditoria-de-los-intentos-de-acceso-exitosos-al-sistema-comprueba-su-funcionamiento"> <strong>1. Activa desde SQL*Plus la auditoría de los intentos de acceso exitosos al sistema. Comprueba su funcionamiento.</strong></h2>
<p>Visualizaremos los parametros de auditorias:</p>
<div><pre><code>show parameter AUDIT
</code></pre>
</div><p><img src="./../images/ABD/auditoria/1-1.png" alt="image"></p>
<p>Nos aseguraremos de que el parámetro <code>AUDIT_TRAIL</code> esté establecido en DB. Puedes verificarlo ejecutando el siguiente comando:</p>
<div><pre><code>show parameter audit_trail
</code></pre>
</div><p><img src="./../images/ABD/auditoria/2-1.png" alt="image"></p>
<p>Si el valor devuelto no es DB, puedes establecerlo con el siguiente comando:</p>
<div><pre><code>alter system set audit_trail=db scope=spfile;
</code></pre>
</div><p>Activamos la auditoría para los intentos de acceso exitosos con el siguiente comando:</p>
<div><pre><code>audit session whenever successful;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/3-1.png" alt="image"></p>
<p>Comprobamos su activación.</p>
<div><pre><code>audit create session by lucas;
</code></pre>
</div><hr>
<div><pre><code>select * from dba_priv_audit_opts;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/4-1.png" alt="image"></p>
<p>Comprobamos el funcionamiento:</p>
<p>Primero iniciaremos sesión en la base de datos SQL*Plus con una cuenta de usuario existente con cualquiera de los siguientes comandos:</p>
<div><pre><code>sqlplus
</code></pre>
</div><hr>
<div><pre><code>sqlplus username/passwd
</code></pre>
</div><p><img src="./../images/ABD/auditoria/5-1.png" alt="image"></p>
<p>Si la autenticación es exitosa, la sesión se iniciará y deberías ver el prompt de SQL*Plus. Puedes comprobar que la auditoría está funcionando consultando la tabla de registros de auditoría <code>dba_audit_session</code>. Puedes hacerlo ejecutando el siguiente comando:</p>
<div><pre><code>select os_username, username, extended_timestamp from dba_audit_session where action_name = 'LOGON' and returncode = 0;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/6-1.png" alt="image"></p>
<p>Para finalizar, desactivaremos la auditoría.</p>
<div><pre><code>noaudit session whenever successful; 
</code></pre>
</div><p><img src="./../images/ABD/auditoria/7-1.png" alt="image"></p>
<h2 id="_2-realiza-un-procedimiento-en-pl-sql-que-te-muestre-los-accesos-fallidos-junto-con-el-motivo-de-los-mismos-transformando-el-codigo-de-error-almacenado-en-un-mensaje-de-texto-comprensible-contempla-todos-los-motivos-posibles-para-que-un-acceso-sea-fallido"> <strong>2. Realiza un procedimiento en PL/SQL que te muestre los accesos fallidos junto con el motivo de los mismos, transformando el código de error almacenado en un mensaje de texto comprensible. Contempla todos los motivos posibles para que un acceso sea fallido.</strong></h2>
<p>En primer lugar debemos de activar la auditoria de los aciertos fallidos:</p>
<div><pre><code>audit create session whenever not successful;
</code></pre>
</div><p>Función para devolver el motivo del error:</p>
<div><pre><code>create or replace function DevolverMotivo (p_error number)
return varchar2
is
    mensaje varchar2(40);
begin
    case p_error
        when 1017 then 
            mensaje:='Usuario/Password Incorrecta';
        when 28000 THEN
            mensaje:='Cuenta Bloqueada';
        when 1045 then
            mensaje:='Privilegios insuficientes';
        else
            mensaje:='Error Desconocido';
    end case;
return mensaje;
end;
/
</code></pre>
</div><p><img src="./../images/ABD/auditoria/1-2.png" alt="image"></p>
<p>Procedimiento:</p>
<div><pre><code>create or replace procedure MostrarAccesosFallidos
is
    cursor c_cursor is 
    select username, timestamp, returncode from dba_audit_session where action_name = 'LOGON' and returncode != 0;
    v_motivo varchar2(40);
begin
    dbms_output.put_line(chr(10)||chr(9)||chr(9)||'-- AUDITORIA DE ACCESOS FALLIDOS --');
    dbms_output.put_line(chr(10)||chr(9)||'Usuario'||chr(9)||chr(9)||'Fecha'||chr(9)||chr(9)||chr(9)||
        'Motivo');
    dbms_output.put_line(chr(9)||'----------------------------------------------------------------');
    for var in c_cursor loop
        v_motivo:=DevolverMotivo(var.returncode);
        dbms_output.put_line(chr(10)||chr(9)||var.username||chr(9)||chr(9)||to_char(var.timestamp,'YY/MM/DD DY HH24:MI')||chr(9)||v_motivo);
    end loop; 
end;
/
</code></pre>
</div><p><img src="./../images/ABD/auditoria/2-2.png" alt="image"></p>
<p>Comprobación del funcionamiento:</p>
<p>Para hacer la prueba voy a acceder con los usuarios &quot;lucas&quot;, &quot;oscar&quot; y &quot;oscarlucas&quot;. Con el usuario &quot;lucas&quot; voy a fallar en la contraseña, el usuario &quot;oscar&quot; esta bloqueado y el usuario &quot;oscarlucas&quot; no tiene privilegios.</p>
<p><img src="./../images/ABD/auditoria/3-2.png" alt="image"></p>
<p>Y ejecutaremos el procedimiento para ver su funcionamiento:</p>
<div><pre><code>exec MostrarAccesosFallidos;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/4-2.png" alt="image"></p>
<p>Para finalizar, desactivamos la auditoria</p>
<div><pre><code>noaudit create session whenever not successful;
</code></pre>
</div><h2 id="_3-activa-la-auditoria-de-las-operaciones-dml-realizadas-por-scott-comprueba-su-funcionamiento"> <strong>3. Activa la auditoría de las operaciones DML realizadas por SCOTT. Comprueba su funcionamiento.</strong></h2>
<p><a href="https://pastebin.com/pCBR7MwS" target="_blank" rel="noopener noreferrer">Esquema scott<i>Content not supported</i></a></p>
<p>Activamos la auditoría.</p>
<div><pre><code>audit insert table, update table, delete table by scott by access;
</code></pre>
</div><p>Donde:</p>
<ul>
<li>
<p>BY ACCESS : Realiza un registro por cada acción.</p>
</li>
<li>
<p>BY SESSION : Realiza un registro de todas las acciones por cada sesión iniciada.</p>
</li>
</ul>
<p>Realizamos una prueba:</p>
<div><pre><code>conn scott/tiger
insert into dept values(50, 'DH', 'Dos Hermanas');
update dept set loc = 'Sevilla' where deptno = 50;
delete from dept where deptno = 50;
commit;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/1-3.png" alt="image"></p>
<p>Para ver las acciones realizadas por SCOTT:</p>
<div><pre><code>audit all by scott by access;

select obj_name, action_name, timestamp from dba_audit_object where username = 'SCOTT';
</code></pre>
</div><p><img src="./../images/ABD/auditoria/2-3.png" alt="image"></p>
<h2 id="_4-realiza-una-auditoria-de-grano-fino-para-almacenar-informacion-sobre-la-insercion-de-empleados-con-sueldo-superior-a-2000-en-la-tabla-emp-de-scott"> <strong>4. Realiza una auditoría de grano fino para almacenar información sobre la inserción de empleados con sueldo superior a 2000 en la tabla emp de scott.</strong></h2>
<p>Creación de la auditoría de grano fino:</p>
<div><pre><code>begin
    dbms_fga.add_policy (
        object_schema      =&gt;  'scott',
        object_name        =&gt;  'emp',
        policy_name        =&gt;  'politica1',
        audit_condition    =&gt;  'sal &gt; 2000',
        statement_types    =&gt;  'insert'
    );
end;
/
</code></pre>
</div><p><img src="./../images/ABD/auditoria/1-4.png" alt="image"></p>
<p>Ver la política creada:</p>
<div><pre><code>select object_schema,object_name,policy_name,policy_text from dba_audit_policies;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/2-4.png" alt="image"></p>
<p>Realizamos una prueba:</p>
<div><pre><code>conn scott/tiger
</code></pre>
</div><hr>
<div><pre><code>insert into emp values(7940, 'MARK', 'CARRIER', null, sysdate, 3000, null, 10);
insert into emp values(7941, 'RICK', 'CARRIER', null, sysdate, 2001, null, 20);

commit;
</code></pre>
</div><p>Para visualizar las acciones realizadas.</p>
<div><pre><code>select sql_text from dba_fga_audit_trail where policy_name = 'POLITICA1';
</code></pre>
</div><p><img src="./../images/ABD/auditoria/3-4.png" alt="image"></p>
<p>Para eliminar la auditoría de grano fino:</p>
<div><pre><code>begin
    dbms_fga.drop_policy (
        object_schema      =&gt;  'scott',
        object_name        =&gt;  'emp',
        policy_name        =&gt;  'politica1'      
    );
end;
/
</code></pre>
</div><p><img src="./../images/ABD/auditoria/4-4.png" alt="image"></p>
<h2 id="_5-explica-la-diferencia-entre-auditar-una-operacion-by-access-o-by-session-ilustrandolo-con-ejemplos"> <strong>5. Explica la diferencia entre auditar una operación by access o by session ilustrándolo con ejemplos.</strong></h2>
<p><strong>BY ACCESS</strong>:</p>
<p>La auditoría por acceso implica registrar una entrada de auditoría cada vez que se lleva a cabo una operación de manipulación de datos (DML). Por ejemplo, esta técnica de auditoría permite registrar si un usuario ha insertado, actualizado o eliminado una fila de una tabla.</p>
<p>Primero vaciamos la tabla de auditoria eliminando los registros</p>
<div><pre><code>truncate table aud$;
</code></pre>
</div><p>Despues activamos la auditoría.</p>
<div><pre><code>audit insert table, update table, delete table by scott by access;
</code></pre>
</div><p>Realizaremos una serie de pruebas.</p>
<div><pre><code>conn scott/tiger

insert into scott.dept values(60, 'OLL', 'ESPAÑA');
update scott.dept set loc = 'MIAMI' where deptno = 60;
delete from scott.dept where deptno = 60;

commit;
</code></pre>
</div><p>Cambiamos al usuario administrador y comparamos registros:</p>
<div><pre><code>select username, action_name, timestamp, obj_name from dba_audit_object where username = 'SCOTT';
</code></pre>
</div><p><img src="./../images/ABD/auditoria/1-5.png" alt="image"></p>
<p><strong>BY SESSION</strong>:</p>
<p>La auditoría por sesión, en contraste con la auditoría por acceso, registra únicamente una entrada de auditoría por sesión. Aunque esta técnica de auditoría proporciona un registro menos detallado, mejora el rendimiento de la base de datos.</p>
<p>Primero vaciamos la tabla de auditoria eliminando los registros</p>
<div><pre><code>truncate table aud$;
</code></pre>
</div><p>Despues activamos la auditoría.</p>
<div><pre><code>audit insert table, update table, delete table by scott by session;
</code></pre>
</div><p>Realizaremos una serie de pruebas.</p>
<div><pre><code>conn scott/tiger

insert into scott.dept values(60, 'OLL', 'ESPAÑA');
update scott.dept set loc = 'MIAMI' where deptno = 60;
delete from scott.dept where deptno = 60;

commit;
</code></pre>
</div><p>Cambiamos al usuario administrador y comparamos registros:</p>
<div><pre><code>select username, action_name, timestamp, obj_name from dba_audit_object where username = 'SCOTT';
</code></pre>
</div><p><img src="./../images/ABD/auditoria/2-5.png" alt="image"></p>
<h2 id="_6-documenta-las-diferencias-entre-los-valores-db-y-db-extended-del-parametro-audit-trail-de-oracle-demuestralas-poniendo-un-ejemplo-de-la-informacion-sobre-una-operacion-concreta-recopilada-con-cada-uno-de-ellos"> <strong>6. Documenta las diferencias entre los valores db y db, extended del parámetro audit_trail de ORACLE. Demuéstralas poniendo un ejemplo de la información sobre una operación concreta recopilada con cada uno de ellos.</strong></h2>
<p>Las diferencias son mínimas y es que solo se diferencia en que db extend aparte de almacenarse en SYS.AUD$ también escribe valores en las columnas SQLBIND y SQLTEXT.</p>
<p>Ejemplo:</p>
<p>Para este ejemplo lo primero que deberemos hacer es activar las auditorias:</p>
<div><pre><code>show parameter audit;

alter system set audit_trail = db, extended scope = spfile;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/1-6.png" alt="image"></p>
<p>Deberemos de reiniciar la base de datos.</p>
<div><pre><code>shutdown
startup
</code></pre>
</div><p>Y comprobamos como hemos añadido un nuevo valor en la auditoria:</p>
<div><pre><code>show parameter audit;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/2-6.png" alt="image"></p>
<h2 id="_7-averigua-si-en-postgres-se-pueden-realizar-los-cuatro-primeros-apartados-si-es-asi-documenta-el-proceso-adecuadamente"> <strong>7. Averigua si en Postgres se pueden realizar los cuatro primeros apartados. Si es así, documenta el proceso adecuadamente.</strong></h2>
<p><em>ejer 1. Activa desde SQL</em>Plus la auditoría de los intentos de acceso exitosos al sistema. Comprueba su funcionamiento.*</p>
<p>El parámetro log_connections en PostgreSQL se utiliza para realizar la auditoría de los accesos exitosos al sistema.</p>
<p>Si queremos probar la funcionalidad del registro de accesos exitosos en PostgreSQL, debemos activar el parámetro correspondiente.</p>
<div><pre><code>sudo -u postgres psql

ALTER SYSTEM SET log_connections = 'ON';
</code></pre>
</div><p><img src="./../images/ABD/auditoria/1-7.png" alt="image"></p>
<p>Reiniciamos el servicio:</p>
<div><pre><code>sudo systemctl restart postgresql
</code></pre>
</div><p><img src="./../images/ABD/auditoria/2-7.png" alt="image"></p>
<p>Después de activar el parámetro, podemos verificar los registros de acceso exitosos en PostgreSQL accediendo al archivo /var/log/postgresql/postgresql-13-main.log (el nombre del archivo puede variar según la versión de PostgreSQL instalada y la ubicación puede ser diferente según el sistema operativo). Por ejemplo, si nos hemos conectado con el usuario &quot;scott&quot;, podemos comprobar si se ha registrado el acceso correctamente revisando el archivo de registros.</p>
<div><pre><code>tail /var/lib/postgresql/13/main/pg_log/postgresql-2023-03-01_140147.csv
</code></pre>
</div><p><img src="./../images/ABD/auditoria/3-7.png" alt="image"></p>
<p>En el archivo de registros, podremos observar la información de la conexión exitosa realizada con el usuario &quot;scott&quot;.</p>
<p><em>ejer 2. Realiza un procedimiento en PL/SQL que te muestre los accesos fallidos junto con el motivo de los mismos, transformando el código de error almacenado en un mensaje de texto comprensible. Contempla todos los motivos posibles para que un acceso sea fallido.</em></p>
<p>Incluso si intentas acceder al sistema utilizando un usuario inexistente o una contraseña incorrecta, cualquier falla en el intento se registrará en el archivo <code>/var/lib/postgresql/13/main/pg_log/postgresql-2023-03-01_140147.csv</code>. Para verificar esto, puedes intentar conectarte al sistema utilizando el nombre de usuario &quot;scott&quot; y una contraseña incorrecta.</p>
<div><pre><code>#Usuario existente (fallo contraseña)
psql -h localhost -U scott -d scott

#Usuario inexixtente
psql -h localhost -U auditoria -d scott
</code></pre>
</div><p><img src="./../images/ABD/auditoria/4-7.png" alt="image"></p>
<p><em>ejer 3. Activa la auditoría de las operaciones DML realizadas por SCOTT. Comprueba su funcionamiento.</em></p>
<p>En lugar de desarrollar una herramienta propia para la auditoría de operaciones DML, utilizaré una herramienta de terceros llamada audit-trigger. Esta herramienta ya proporciona todas las funciones necesarias para llevar a cabo la auditoría, aunque también podríamos optar por utilizar otras herramientas como pgaudit.</p>
<p>Antes de llevar a cabo la auditoría, descargo el archivo .sql que contiene la tabla de auditoría y los triggers necesarios para su creación.</p>
<div><pre><code>wget https://raw.githubusercontent.com/2ndQuadrant/audit-trigger/master/audit.sql
</code></pre>
</div><p>Importo el fichero en la base de datos:</p>
<div><pre><code>\i audit.sql
</code></pre>
</div><p><img src="./../images/ABD/auditoria/5-7.png" alt="image"></p>
<p>Una vez que he descargado el archivo .sql, puedo activar la auditoría para las tablas que deseo auditar. En este caso, he decidido auditar las tablas EMP y DEPT.</p>
<div><pre><code>SELECT audit.audit_table('emp');
SELECT audit.audit_table('dept');
</code></pre>
</div><p><img src="./../images/ABD/auditoria/6-7.png" alt="image"></p>
<p>Ejecuto algunas operaciones DML sobre las tablas:</p>
<div><pre><code>insert into dept values (50, 'NULO', 'MIAMI');
insert into emp values (9000, 'KING','PRESIDENT', null, to_date('25-02-2023','dd-mm-yyyy'), 5000, null, 10);

update dept set loc = 'DH' where deptno = 50;
update emp set ename = 'QUEEN' where empno = 9000;

delete from dept where deptno = 50;
delete from emp where empno = 9000;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/7-7.png" alt="image"></p>
<p>Y ahora, consulto la tabla de auditoría para comprobar que se han registrado las operaciones:</p>
<div><pre><code>select session_user_name, action, table_name, action_tstamp_clk, client_query from audit.logged_actions;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/8-7.png" alt="image"></p>
<p>Hemos podido verificar que las operaciones realizadas en las tablas &quot;emp&quot; y &quot;dept&quot; se han registrado correctamente. Sin embargo, es posible que la salida de la consola de psql no se muestre correctamente formateada.</p>
<p><em>ejer 4. Realiza una auditoría de grano fino para almacenar información sobre la inserción de empleados con sueldo superior a 2000 en la tabla emp de scott.</em></p>
<p>Para llevar a cabo esta tarea, el primer paso es crear una tabla que contendrá los datos de auditoría.</p>
<div><pre><code>create table emp_audit (
    id serial primary key,
    empno int,
    tarea varchar(20),
    sal decimal(7,2)
);
</code></pre>
</div><p><img src="./../images/ABD/auditoria/9-7.png" alt="image"></p>
<p>Una vez creada la tabla, procederé a escribir un disparador (trigger) que se encargará de registrar en la tabla &quot;emp_audit&quot; los datos de los empleados que se hayan insertado en la tabla &quot;EMP&quot; con un salario superior a 2000.</p>
<div><pre><code>create or replace function emp_audit() returns trigger as $$
begin
    insert into emp_audit (empno, tarea, sal) values (new.empno, TG_OP, new.sal);
return new;
end;
$$ language plpgsql;

create trigger emp_audit
after insert or update on emp
for each row
when (new.sal &gt; 2000)
execute function emp_audit();
</code></pre>
</div><p><img src="./../images/ABD/auditoria/10-7.png" alt="image"></p>
<p>Para probar el disparador, realizaré las siguientes acciones:</p>
<ol>
<li>
<p>Insertaré un empleado en la tabla &quot;EMP&quot; con un salario superior a 2000.</p>
</li>
<li>
<p>Insertaré otro empleado en la tabla &quot;EMP&quot; con un salario superior a 2000.</p>
</li>
<li>
<p>Insertaré otro empleado en la tabla &quot;EMP&quot; con un salario inferior a 2000.</p>
</li>
</ol>
<hr>
<div><pre><code>insert into emp values(7940, 'MARK', 'CARRIER', null, to_date('01-01-2023','dd-mm-yyyy'), 3000, null, 10);
insert into emp values(7941, 'RICK', 'CARRIER', null, to_date('01-02-2023','dd-mm-yyyy'), 2001, null, 20);
insert into emp values(7942, 'RICK', 'CARRIER', null, to_date('01-03-2023','dd-mm-yyyy'), 500, null, 20);
</code></pre>
</div><p>Si consulto la tabla de auditoría en este momento, podré observar que las operaciones se han registrado correctamente.</p>
<div><pre><code>select * from emp_audit;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/11-7.png" alt="image"></p>
<h2 id="_8-averigua-si-en-mysql-se-pueden-realizar-los-apartados-1-3-y-4-si-es-asi-documenta-el-proceso-adecuadamente"> <strong>8. Averigua si en MySQL se pueden realizar los apartados 1, 3 y 4. Si es así, documenta el proceso adecuadamente.</strong></h2>
<p><em>ejer 1. Activa desde SQLPlus la auditoría de los intentos de acceso exitosos al sistema. Comprueba su funcionamiento.</em></p>
<p>Para consultar las conexiones exitosas en MySQL, se inicia con la modificación del archivo de configuración llamado /etc/mysql/mariadb.conf.d/50-server.cnf:</p>
<div><pre><code>sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf
</code></pre>
</div><p>Después de abrir el archivo mencionado anteriormente, se procede a remover los comentarios de las siguientes líneas:</p>
<div><pre><code>general_log_file       = /var/log/mysql/mysql.log
general_log            = 1

log_error = /var/log/mysql/error.log
</code></pre>
</div><p>Se aplican los permisos adecuados al directorio de registros (logs) de MariaDB y se reinicia el servicio para que los cambios tengan efecto.</p>
<div><pre><code>sudo chown mysql:mysql /var/log/mysql/

sudo systemctl restart mariadb
</code></pre>
</div><p>Para verificar que todo funciona correctamente, se intenta iniciar sesión con un usuario existente y se verifica que la conexión se registra en el archivo de registros general de MySQL, llamado mysql.log.</p>
<div><pre><code>mysql -u scott -p

sudo tail /var/log/mysql/mysql.log
</code></pre>
</div><p><img src="./../images/ABD/auditoria/1-8.png" alt="image"></p>
<p><em>ejer 3. Activa la auditoría de las operaciones DML realizadas por SCOTT. Comprueba su funcionamiento.</em></p>
<p>En esta sección, siguiendo el mismo enfoque que con PostgreSQL, utilizaremos el plugin server_audit para MySQL. Este complemento debe instalarse para habilitar la capacidad de auditar las operaciones DML. Aunque este plugin también puede registrar conexiones exitosas, como vimos anteriormente, no era necesario usarlo para ese propósito.</p>
<p>La instalación del plugin es muy sencilla, solo se necesita ejecutar:</p>
<div><pre><code>INSTALL SONAME 'server_audit';
</code></pre>
</div><p><img src="./../images/ABD/auditoria/2-8.png" alt="image"></p>
<p>Una vez instalado, se procede a activar y configurar el plugin para que registre las operaciones DML realizadas por el usuario &quot;scott&quot;:</p>
<div><pre><code>sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf
</code></pre>
</div><p>Agrego las siguiente líneas:</p>
<div><pre><code>[server]
server_audit_events=CONNECT,QUERY,TABLE
server_audit_logging=ON
server_audit_incl_users=scott
server_audit_file_path=/var/log/mysql/audit.log
</code></pre>
</div><p>Reinicio el servicio y ejecuto algunas sentencias de prueba:</p>
<div><pre><code>sudo systemctl restart mariadb
</code></pre>
</div><hr>
<div><pre><code>mysql -u scott -p
use scott

insert into dept values(50, 'DH', 'Dos Hermanas');
update dept set loc = 'Sevilla' where deptno = 50;
delete from dept where deptno = 50;
</code></pre>
</div><p><img src="./../images/ABD/auditoria/3-8.png" alt="image"></p>
<p>Se revisa el archivo de auditoría y se observa que las operaciones se han registrado correctamente.</p>
<div><pre><code>sudo tail /var/log/mysql/audit.log -n 10
</code></pre>
</div><p><img src="./../images/ABD/auditoria/4-8.png" alt="image"></p>
<p><em>ejer 4. Realiza una auditoría de grano fino para almacenar información sobre la inserción de empleados con sueldo superior a 2000 en la tabla emp de scott.</em></p>
<p>Siguiendo el enfoque utilizado en PostgreSQL, se debe crear un trigger que se ejecute cada vez que se inserte un nuevo registro en la tabla &quot;emp&quot;. El trigger debe registrar esta operación en la tabla &quot;emp_audit&quot; para permitir una auditoría más detallada.</p>
<p>Creo la tabla:</p>
<div><pre><code>create table emp_audit (
    id serial primary key,
    empno int,
    tarea varchar(20),
    sal decimal(7,2)
);
</code></pre>
</div><p><img src="./../images/ABD/auditoria/5-8.png" alt="image"></p>
<p>Creo el trigger para los inserts:</p>
<p>delimiter //</p>
<p>create trigger emp_audit_insert
after insert on emp
for each row
begin
if new.sal &gt; 2000 then
insert into emp_audit (empno, tarea, sal) values (new.empno, 'insert', new.sal);
end if;
end //</p>
<p>delimiter ;</p>
<p><img src="./../images/ABD/auditoria/6-8.png" alt="image"></p>
<p>Para probar el disparador, realizaré las siguientes acciones:</p>
<ol>
<li>
<p>Insertaré un empleado en la tabla &quot;EMP&quot; con un salario superior a 2000.</p>
</li>
<li>
<p>Insertaré otro empleado en la tabla &quot;EMP&quot; con un salario superior a 2000.</p>
</li>
<li>
<p>Insertaré otro empleado en la tabla &quot;EMP&quot; con un salario inferior a 2000.</p>
</li>
</ol>
<hr>
<div><pre><code>insert into emp values(7940, 'MARK', 'CARRIER', null, str_to_date('01/01/2023', '%d/%m/%Y'), 3000, null, 10);
insert into emp values(7941, 'RICK', 'CARRIER', null, str_to_date('01/02/2023', '%d/%m/%Y'), 2001, null, 20);
insert into emp values(7942, 'RICK', 'CARRIER', null, str_to_date('01/03/2023', '%d/%m/%Y'), 500, null, 20);
</code></pre>
</div><p>Si consulto la tabla de auditoría en este momento, podré observar que las operaciones se han registrado correctamente.</p>
<p>select * from emp_audit;</p>
<p><img src="./../images/ABD/auditoria/7-8.png" alt="image"></p>
<h2 id="_9-averigua-las-posibilidades-que-ofrece-mongodb-para-auditar-los-cambios-que-va-sufriendo-un-documento-demuestra-su-funcionamiento"> <strong>9. Averigua las posibilidades que ofrece MongoDB para auditar los cambios que va sufriendo un documento. Demuestra su funcionamiento.</strong></h2>
<h2 id="_10-averigua-si-en-mongodb-se-pueden-auditar-los-accesos-a-una-coleccion-concreta-demuestra-su-funcionamiento"> <strong>10. Averigua si en MongoDB se pueden auditar los accesos a una colección concreta. Demuestra su funcionamiento.</strong></h2>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Cortafuegos II: Perimetral con nftables</title>
    <id>https://github.com/oscarlucas22/practicas/cortafuegoII/</id>
    <link href="https://github.com/oscarlucas22/practicas/cortafuegoII/"/>
    <updated>2023-03-07T17:02:54.440Z</updated>
    <content type="html"><![CDATA[<h1 id="cortafuegos-ii-perimetral-con-nftables"> Cortafuegos II: Perimetral con nftables</h1>
<p><strong>Realiza con nftables el ejercicio de la <a href="https://fp.josedomingo.org/seguridadgs/u03/perimetral_iptables.html" target="_blank" rel="noopener noreferrer">página<i>Content not supported</i></a> documentando las pruebas de funcionamiento realizadas.</strong></p>
<p><strong>Debes añadir después las reglas necesarias para que se permitan las siguientes operaciones:</strong></p>
<p><strong>a) Permite poder hacer conexiones ssh al exterior desde la máquina cortafuegos.</strong></p>
<p><strong>b) Permite hacer consultas DNS desde la máquina cortafuegos sólo al servidor 192.168.202.2. Comprueba que no puedes hacer un dig @1.1.1.1.</strong></p>
<p><strong>c) Permite que la máquina cortafuegos pueda navegar por internet.</strong></p>
<p><strong>e) Permitimos el ssh desde el cortafuego a la LAN</strong></p>
<p><strong>f) Permitimos hacer ping desde la LAN a la máquina cortafuegos.</strong></p>
<p><strong>g) Permite realizar conexiones ssh desde los equipos de la LAN</strong></p>
<p><strong>h) Instala un servidor de correos en la máquina de la LAN. Permite el acceso desde el exterior y desde el cortafuego al servidor de correos. Para probarlo puedes ejecutar un telnet al puerto 25 tcp.</strong></p>
<p><strong>i) Permite poder hacer conexiones ssh desde exterior a la LAN</strong></p>
<p><strong>j) Modifica la regla anterior, para que al acceder desde el exterior por ssh tengamos que conectar al puerto 2222, aunque el servidor ssh este configurado para acceder por el puerto 22.</strong></p>
<p><strong>k) Permite hacer consultas DNS desde la LAN sólo al servidor 192.168.202.2. Comprueba que no puedes hacer un dig @1.1.1.1.</strong></p>
<p><strong>l) Permite que los equipos de la LAN puedan navegar por internet.</strong></p>
<hr>
<h2 id="esquema-de-red"> Esquema de red</h2>
<p>Vamos a utilizar dos máquinas en openstack, que vamos a crear con la receta heat: <a href="https://fp.josedomingo.org/seguridadgs/u03/escenario2.yaml" target="_blank" rel="noopener noreferrer">escenario2.yaml<i>Content not supported</i></a>. La receta heat ha deshabilitado el cortafuego que nos ofrece openstack (todos los puertos de todos los protocolos están abiertos). Una máquina (que tiene asignada una IP flotante) hará de cortafuegos, y la otra será una máquina de la red interna 192.168.100.0/24.</p>
<h2 id="preparacion-nftables"> Preparación nftables</h2>
<h3 id="configuracion-de-las-rutas-por-defecto"> Configuración de las rutas por defecto</h3>
<p><strong>LAN:</strong></p>
<p><img src="./../images/SAD/cortafuegos2/1.png" alt="image"></p>
<div><pre><code>sudo ip route del default
sudo ip route add default via 192.168.100.2
</code></pre>
</div><h3 id="creacion-de-las-tablas-filter-y-nat"> Creación de las tablas filter y nat:</h3>
<div><pre><code>sudo nft add table inet filter
sudo nft add table inet nat
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/2.png" alt="image"></p>
<h3 id="creacion-de-las-cadenas-de-filter"> Creación de las cadenas de filter:</h3>
<div><pre><code>sudo nft add chain inet filter input { type filter hook input priority 0 \; counter \; policy accept \; }
sudo nft add chain inet filter output { type filter hook output priority 0 \; counter \; policy accept \; }
sudo nft add chain inet filter forward { type filter hook forward priority 0 \; counter \; policy accept \; }
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/3.png" alt="image"></p>
<h3 id="creacion-de-las-cadenas-de-nat"> Creación de las cadenas de nat:</h3>
<div><pre><code>sudo nft add chain inet nat prerouting { type nat hook prerouting priority 0 \; }
sudo nft add chain inet nat postrouting { type nat hook postrouting priority 100 \; }
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/4.png" alt="image"></p>
<h3 id="trafico-ssh-entrante-al-cortafuegos"> Tráfico ssh entrante al cortafuegos</h3>
<div><pre><code>sudo nft add rule inet filter input ip saddr 172.29.0.0/16 tcp dport 22 ct state new,established counter accept
sudo nft add rule inet filter output ip daddr 172.29.0.0/16 tcp sport 22 ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/5.png" alt="image"></p>
<h3 id="politicas-por-defecto"> Políticas por defecto</h3>
<div><pre><code>sudo nft chain inet filter input { policy drop \; }
sudo nft chain inet filter output { policy drop \; }
sudo nft chain inet filter forward { policy drop \; }
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/6.png" alt="image"></p>
<p>No puedo hacer ping a localhost:</p>
<div><pre><code>ping -c 5 127.0.0.1
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/7.png" alt="image"></p>
<p>No puedo establecer conexión mediante ping con Internet.</p>
<div><pre><code>ping -c 5 8.8.8.8
</code></pre>
</div><hr>
<div><pre><code>ping -c 5 1.1.1.1
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/8.png" alt="image"></p>
<p>Si después de este paso nuestra conexión ssh a la máquina no se interrumpe, entonces las dos reglas que aplicamos previamente están operando correctamente.</p>
<h3 id="activar-el-bit-de-forwarding"> Activar el bit de forwarding</h3>
<div><pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/9.png" alt="image"></p>
<h3 id="snat"> SNAT</h3>
<div><pre><code>sudo nft add rule inet nat postrouting oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 counter masquerade
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/10.png" alt="image"></p>
<h3 id="trafico-ssh-saliente-cortafuegos-lan"> Tráfico ssh saliente cortafuegos -&gt; LAN</h3>
<div><pre><code>sudo nft add rule inet filter output oifname &quot;ens4&quot; ip daddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept
sudo nft add rule inet filter input iifname &quot;ens4&quot; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/11.png" alt="image"></p>
<p>Pruebo que funciona:</p>
<div><pre><code>ssh debian@192.168.100.10
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/12.png" alt="image"></p>
<h3 id="trafico-loopback"> Tráfico loopback</h3>
<div><pre><code>sudo nft add rule inet filter output oifname &quot;lo&quot; counter accept
sudo nft add rule inet filter input iifname &quot;lo&quot; counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/13.png" alt="image"></p>
<p>Ahora el ping a &quot;localhost&quot; está funcionando correctamente.</p>
<div><pre><code>ping -c 3 127.0.0.1
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/14.png" alt="image"></p>
<h3 id="trafico-icmp"> Tráfico ICMP</h3>
<h3 id="permito-ping-entrante-desde-la-red-externa"> Permito ping entrante desde la red externa:</h3>
<div><pre><code>sudo nft add rule inet filter input iifname &quot;ens3&quot; icmp type echo-request counter accept
sudo nft add rule inet filter output oifname &quot;ens3&quot; icmp type echo-reply counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/15.png" alt="image"></p>
<p>Voy a verificar su funcionamiento desde mi equipo.</p>
<div><pre><code>ping -c 3 172.22.200.80
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/16.png" alt="image"></p>
<h3 id="permito-ping-saliente-cortafuegos-lan"> Permito ping saliente cortafuegos -&gt; LAN:</h3>
<div><pre><code>sudo nft add rule inet filter output oifname &quot;ens4&quot; icmp type echo-request counter accept
sudo nft add rule inet filter input iifname &quot;ens4&quot; icmp type echo-reply counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/17.png" alt="image"></p>
<p>Pruebo que funciona:</p>
<div><pre><code>ping -c 3 192.168.100.10
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/18.png" alt="image"></p>
<h3 id="forward-trafico-icmp-saliente-lan-internet"> FORWARD: tráfico icmp saliente LAN -&gt; Internet</h3>
<div><pre><code>sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 icmp type echo-request counter accept
sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip daddr 192.168.100.0/24 icmp type echo-reply counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/19.png" alt="image"></p>
<p>Voy a comprobar que el ping a Internet está funcionando correctamente.</p>
<div><pre><code>ping -c 3 8.8.8.8
</code></pre>
</div><hr>
<div><pre><code>ping -c 3 1.1.1.1
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/20.png" alt="image"></p>
<h3 id="forward-trafico-dns-saliente-desde-lan"> FORWARD: tráfico DNS saliente desde LAN</h3>
<div><pre><code>sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 udp dport 53 ct state new,established counter accept
sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip daddr 192.168.100.0/24 udp sport 53 ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/21.png" alt="image"></p>
<p>Pruebo que funciona:</p>
<div><pre><code>dig @1.1.1.1 www.example.org
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/22.png" alt="image"></p>
<h3 id="forward-trafico-http-https-saliente-desde-lan"> FORWARD: tráfico http/https saliente desde LAN</h3>
<div><pre><code>sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip protocol tcp ip saddr 192.168.100.0/24 tcp dport { 80,443 } ct state new,established counter accept
sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip protocol tcp ip daddr 192.168.100.0/24 tcp sport { 80,443 } ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/23.png" alt="image"></p>
<p>Compruebo el funcionamiento de http:</p>
<div><pre><code>curl portquiz.net:80
</code></pre>
</div><p>Compruebo el funcionamiento de https:</p>
<div><pre><code>curl portquiz.net:443
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/24.png" alt="image"></p>
<h3 id="forward-trafico-http-entrante-hacia-lan"> FORWARD: tráfico http entrante hacia LAN</h3>
<div><pre><code>sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip daddr 192.168.100.0/24 tcp dport 80 ct state new,established counter accept
sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 tcp sport 80 ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/25.png" alt="image"></p>
<h3 id="necesito-una-regla-dnat"> Necesito una regla DNAT:</h3>
<div><pre><code>sudo nft add rule inet nat prerouting iifname &quot;ens3&quot; tcp dport 80 counter dnat ip to 192.168.100.10
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/26.png" alt="image"></p>
<p>Compruebo el funcionamiento desde mi host:</p>
<div><pre><code>telnet 172.22.200.80 80
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/27.png" alt="image"></p>
<p><img src="./../images/SAD/cortafuegos2/28.png" alt="image"></p>
<h3 id="guardar-la-configuracion-del-cortafuegos-de-forma-persistente"> Guardar la configuración del cortafuegos de forma persistente</h3>
<div><pre><code>nft list ruleset &gt; /etc/nftables.conf
sudo systemctl start nftables
sudo systemctl enable nftables
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/29.png" alt="image"></p>
<h2 id="debes-anadir-despues-las-reglas-necesarias-para-que-se-permitan-las-siguientes-operaciones"> Debes añadir después las reglas necesarias para que se permitan las siguientes operaciones:</h2>
<h3 id="a-permite-poder-hacer-conexiones-ssh-al-exterior-desde-la-maquina-cortafuegos"> a) Permite poder hacer conexiones ssh al exterior desde la máquina cortafuegos.</h3>
<div><pre><code>sudo nft add rule inet filter output oifname &quot;ens3&quot; tcp dport 22 ct state new,established counter accept
sudo nft add rule inet filter input iifname &quot;ens3&quot; tcp sport 22 ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/30.png" alt="image"></p>
<p>Pruebo el funcionamiento de conectando a mi host:</p>
<div><pre><code>ssh oscar@172.29.0.65
</code></pre>
</div><p>![image]</p>
<h3 id="b-permite-hacer-consultas-dns-desde-la-maquina-cortafuegos-solo-al-servidor-192-168-202-2-comprueba-que-no-puedes-hacer-un-dig-1-1-1-1"> b) Permite hacer consultas DNS desde la máquina cortafuegos sólo al servidor 192.168.202.2. Comprueba que no puedes hacer un dig @1.1.1.1.</h3>
<div><pre><code>sudo nft add rule inet filter output ip daddr 192.168.202.2 udp dport 53 ct state new,established counter accept
sudo nft add rule inet filter input ip saddr 192.168.202.2 udp sport 53 ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/32.png" alt="image"></p>
<p>Pruebo que las consultas DNS a 192.168.202.2 funcionan:</p>
<div><pre><code>dig @192.168.202.2 www.example.org
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/33.png" alt="image"></p>
<p>Pruebo que las consultas DNS a 1.1.1.1 no funcionan:</p>
<div><pre><code>dig @1.1.1.1 www.example.org
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/33-1.png" alt="image"></p>
<h3 id="c-permite-que-la-maquina-cortafuegos-pueda-navegar-por-internet"> c) Permite que la máquina cortafuegos pueda navegar por internet.</h3>
<div><pre><code>sudo nft add rule inet filter output oifname &quot;ens3&quot; ip protocol tcp tcp dport { 80,443 } ct state new,established counter accept
sudo nft add rule inet filter input iifname &quot;ens3&quot; ip protocol tcp tcp sport { 80,443 } ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/34.png" alt="image"></p>
<p>Compruebo el funcionamiento de http:</p>
<div><pre><code>curl portquiz.net 80
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/35.png" alt="image"></p>
<p>Compruebo el funcionamiento de https:</p>
<div><pre><code>curl portquiz.net 443
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/36.png" alt="image"></p>
<h3 id="d-los-equipos-de-la-red-local-deben-poder-tener-conexion-al-exterior"> d) Los equipos de la red local deben poder tener conexión al exterior.</h3>
<p>Ya he llevado a cabo este paso durante la configuración previa de la máquina.</p>
<p>Las reglas que establecí para lograr su funcionamiento fueron:</p>
<div><pre><code>sudo nft add rule inet nat postrouting oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 counter masquerade
sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 icmp type echo-request counter accept
sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip daddr 192.168.100.0/24 icmp type echo-reply counter accept
</code></pre>
</div><p>Pruebo el funcionamiento:</p>
<div><pre><code>ping -c 3 8.8.8.8
</code></pre>
</div><hr>
<div><pre><code>ping -c 3 1.1.1.1
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/37.png" alt="image"></p>
<h3 id="e-permitimos-el-ssh-desde-el-cortafuego-a-la-lan"> e) Permitimos el ssh desde el cortafuego a la LAN.</h3>
<p>Ya he llevado a cabo este paso durante la configuración previa de la máquina. Las reglas que establecí para lograr su funcionamiento fueron:</p>
<div><pre><code>sudo nft add rule inet filter output oifname &quot;ens4&quot; ip daddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept
sudo nft add rule inet filter input iifname &quot;ens4&quot; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter accept
</code></pre>
</div><p>Pruebo el funcionamiento de conectando a mi host:</p>
<div><pre><code>ssh oscar@172.29.0.65
</code></pre>
</div><p>![image]</p>
<h3 id="f-permitimos-hacer-ping-desde-la-lan-a-la-maquina-cortafuegos"> f) Permitimos hacer ping desde la LAN a la máquina cortafuegos.</h3>
<div><pre><code>sudo nft add rule inet filter input iifname &quot;ens4&quot; icmp type echo-request counter accept
sudo nft add rule inet filter output oifname &quot;ens4&quot; icmp type echo-reply counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/39.png" alt="image"></p>
<p>Pruebo su funcionamiento:</p>
<div><pre><code>ping -c 3 192.168.100.2
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/40.png" alt="image"></p>
<h3 id="g-permite-realizar-conexiones-ssh-desde-los-equipos-de-la-lan"> g) Permite realizar conexiones ssh desde los equipos de la LAN.</h3>
<div><pre><code>sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept
sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip daddr 192.168.100.0/24 tcp sport 22 ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/41.png" alt="image"></p>
<p>Voy a verificar que funciona la conexión atravesando el cortafuegos desde mi equipo hacia la máquina.</p>
<div><pre><code>ssh oscar@172.29.0.65
</code></pre>
</div><p>![image]</p>
<h3 id="h-instala-un-servidor-de-correos-en-la-maquina-de-la-lan-permite-el-acceso-desde-el-exterior-y-desde-el-cortafuego-al-servidor-de-correos-para-probarlo-puedes-ejecutar-un-telnet-al-puerto-25-tcp"> h) Instala un servidor de correos en la máquina de la LAN. Permite el acceso desde el exterior y desde el cortafuego al servidor de correos. Para probarlo puedes ejecutar un telnet al puerto 25 tcp.</h3>
<p>Habilitar la conexión externa al servidor de correo dentro de la red local (LAN).</p>
<div><pre><code>sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip daddr 192.168.100.0/24 tcp dport 25 counter accept
sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 tcp sport 25 counter accept
sudo nft add rule inet nat prerouting iifname &quot;ens3&quot; tcp dport 25 counter dnat ip to 192.168.100.10
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/43.png" alt="image"></p>
<p>Pruebo el funcionamiento desde mi host:</p>
<div><pre><code>telnet 172.22.200.80 25
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/44.png" alt="image"></p>
<p>Configurar el firewall para permitir el acceso al servidor de correo de la red local (LAN) desde el exterior.</p>
<div><pre><code>sudo nft add rule inet filter output ip daddr 192.168.100.10 tcp dport 25 counter accept
sudo nft add rule inet filter input ip saddr 192.168.100.10 tcp sport 25 counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/45.png" alt="image"></p>
<p>Pruebo el funcionamiento desde el cortafuegos:</p>
<div><pre><code>telnet 192.168.100.10 25
</code></pre>
</div><p>![image]</p>
<h3 id="i-permite-poder-hacer-conexiones-ssh-desde-exterior-a-la-lan"> i) Permite poder hacer conexiones ssh desde exterior a la LAN.</h3>
<div><pre><code>sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip daddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept
sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter accept
sudo nft add rule inet nat prerouting iifname &quot;ens3&quot; tcp dport 22 counter dnat ip to 192.168.100.10
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/47.png" alt="image"></p>
<p>Pruebo el funcionamiento desde mi host:</p>
<div><pre><code>ssh debian@172.22.200.125
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/48.png" alt="image"></p>
<h3 id="j-modifica-la-regla-anterior-para-que-al-acceder-desde-el-exterior-por-ssh-tengamos-que-conectar-al-puerto-2222-aunque-el-servidor-ssh-este-configurado-para-acceder-por-el-puerto-22"> j) Modifica la regla anterior, para que al acceder desde el exterior por ssh tengamos que conectar al puerto 2222, aunque el servidor ssh este configurado para acceder por el puerto 22.</h3>
<div><pre><code>sudo nft add rule inet nat prerouting iifname &quot;ens3&quot; tcp dport 2222 counter dnat ip to 192.168.100.10:22
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/49.png" alt="image"></p>
<p>Pruebo su funcionamiento:</p>
<div><pre><code>ssh -p 2222 debian@172.22.200.125
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/50.png" alt="image"></p>
<h3 id="k-permite-hacer-consultas-dns-desde-la-lan-solo-al-servidor-192-168-202-2-comprueba-que-no-puedes-hacer-un-dig-1-1-1-1"> k) Permite hacer consultas DNS desde la LAN sólo al servidor 192.168.202.2. Comprueba que no puedes hacer un dig @1.1.1.1.</h3>
<p>Necesitamos identificar el handle de la regla que autoriza las consultas DNS a cualquier servidor.</p>
<div><pre><code>sudo nft -a list ruleset | grep 53
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/51.png" alt="image"></p>
<p>Antes de proceder, es necesario eliminar las reglas que permiten realizar consultas DNS a cualquier servidor.</p>
<div><pre><code>sudo nft delete rule inet filter forward handle 42 
sudo nft delete rule inet filter forward handle 43
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/52.png" alt="image"></p>
<p>En este momento podemos agregar las reglas que autorizan las consultas DNS únicamente hacia el servidor 192.168.202.2.</p>
<div><pre><code>sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip saddr 192.168.100.0/24 ip daddr 192.168.202.2 udp dport 53 ct state new,established counter accept
sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip saddr 192.168.202.2 ip daddr 192.168.100.0/24 udp sport 53 ct state established counter accept
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/53.png" alt="image"></p>
<p>Pruebo que las consultas DNS a 192.168.202.2 funcionan:</p>
<div><pre><code>dig @192.168.202.2 www.example.org
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/54.png" alt="image"></p>
<p>Pruebo que no puedo hacer consultas DNS a 1.1.1.1:</p>
<div><pre><code>dig @1.1.1.1 www.example.org
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/55.png" alt="image"></p>
<h3 id="l-permite-que-los-equipos-de-la-lan-puedan-navegar-por-internet"> l) Permite que los equipos de la LAN puedan navegar por internet.</h3>
<p>Ya completé esta tarea durante la configuración inicial de la máquina. Las reglas que establecí para que funcione son:</p>
<div><pre><code>sudo nft add rule inet filter forward iifname &quot;ens4&quot; oifname &quot;ens3&quot; ip protocol tcp ip saddr 192.168.100.0/24 tcp dport { 80,443 } ct state new,established counter accept
sudo nft add rule inet filter forward iifname &quot;ens3&quot; oifname &quot;ens4&quot; ip protocol tcp
</code></pre>
</div><p>Compuebo su funcionamiento:</p>
<div><pre><code>curl www.example.org
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos2/56.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Cortafuegos I: De nodo con iptables</title>
    <id>https://github.com/oscarlucas22/practicas/cortafuegoI/</id>
    <link href="https://github.com/oscarlucas22/practicas/cortafuegoI/"/>
    <updated>2023-03-07T17:02:54.443Z</updated>
    <content type="html"><![CDATA[<h1 id="cortafuegos-i-de-nodo-con-iptables"> Cortafuegos I: De nodo con iptables</h1>
<p>Página de la <a href="https://fp.josedomingo.org/seguridadgs/u03/ejercicio1.html" target="_blank" rel="noopener noreferrer">practica<i>Content not supported</i></a></p>
<hr>
<p>Vamos a crear nuestra maquina sobre la que vamos a trabajar</p>
<p><a href="https://pastebin.com/xJ6NjdGT" target="_blank" rel="noopener noreferrer">fichero<i>Content not supported</i></a></p>
<p>Cuando tengamos el fichero nos hiremos a Openstack e iniciaremos la maquina a traves de este fichero, sigue los siguientes pasos para crearla:</p>
<p><img src="./../images/SAD/cortafuegos1/creacion1.png" alt="image"></p>
<p><img src="./../images/SAD/cortafuegos1/creacion2.png" alt="image"></p>
<p>Importamos el fichero</p>
<p><img src="./../images/SAD/cortafuegos1/creacion3.png" alt="image"></p>
<p>Le daremos a &quot;Siguiente&quot; y rellenaremos las siguientes casillas:</p>
<p><img src="./../images/SAD/cortafuegos1/creacion4.png" alt="image"></p>
<p>Y ya comenzaria a instalarse. Una vez instalada nos saldria en la sección de &quot;Instancias&quot;</p>
<hr>
<p>Vamos a realizar los primeros pasos para implementar un cortafuegos en un nodo de una red, aquel que se ejecuta en el propio equipo que trata de proteger, lo que a veces se denomina un cortafuegos personal.</p>
<h2 id="limpieza-de-las-reglas-previas"> Limpieza de las reglas previas</h2>
<div><pre><code>iptables -F
iptables -t nat -F
iptables -Z
iptables -t nat -Z
</code></pre>
</div><h2 id="vamos-a-permitir-ssh"> Vamos a permitir ssh</h2>
<p>Cómo estamos conectado a la máquina por ssh, vamos a permitir la conexión ssh desde la red 172.22.0.0/16, antes de cambiar las políticas por defecto a DROP, para no perder la conexión:</p>
<div><pre><code>iptables -A INPUT -s 172.22.0.0/16 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A OUTPUT -d 172.22.0.0/16 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT

iptables -A INPUT -s 172.29.0.0/16 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A OUTPUT -d 172.29.0.0/16 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
</code></pre>
</div><h2 id="politica-por-defecto"> Política por defecto</h2>
<div><pre><code>iptables -P INPUT DROP
iptables -P OUTPUT DROP
</code></pre>
</div><p>Comprobamos que el equipo no puede acceder a ningún servicio ni de Internet ni de la red local, ya que la política lo impide.</p>
<p><img src="./../images/SAD/cortafuegos1/1.png" alt="image"></p>
<p><img src="./../images/SAD/cortafuegos1/1.1.png" alt="image"></p>
<h2 id="permitimos-trafico-para-la-interfaz-loopback"> Permitimos tráfico para la interfaz loopback</h2>
<div><pre><code>iptables -A INPUT -i lo -p icmp -j ACCEPT
iptables -A OUTPUT -o lo -p icmp -j ACCEPT
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos1/2.png" alt="image"></p>
<h2 id="peticiones-y-respuestas-protocolo-icmp"> Peticiones y respuestas protocolo ICMP</h2>
<div><pre><code>iptables -A INPUT -i ens3 -p icmp --icmp-type echo-reply -j ACCEPT
iptables -A OUTPUT -o ens3 -p icmp --icmp-type echo-request -j ACCEPT
</code></pre>
</div><p>Comprobamos su funcionamiento haciendo ping a una IP pública:</p>
<p><img src="./../images/SAD/cortafuegos1/3.png" alt="image"></p>
<h2 id="consultas-y-respuestas-dns"> Consultas y respuestas DNS</h2>
<div><pre><code>iptables -A OUTPUT -o ens3 -p udp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT -i ens3 -p udp --sport 53 -m state --state ESTABLISHED -j ACCEPT
</code></pre>
</div><p>Comprobamos su funcionamiento con una consulta DNS:</p>
<p><img src="./../images/SAD/cortafuegos1/4.png" alt="image"></p>
<h2 id="trafico-http-que-la-maquina-pueda-navegar"> Tráfico http (que la máquina pueda navegar)</h2>
<div><pre><code>iptables -A OUTPUT -o ens3 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT -i ens3 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT
</code></pre>
</div><p>Comprobamos que funciona accediendo a un servicio http (!no https)</p>
<p><img src="./../images/SAD/cortafuegos1/5.png" alt="image"></p>
<h2 id="trafico-https"> Tráfico https</h2>
<div><pre><code>iptables -A OUTPUT -o ens3 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT -i ens3 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT
</code></pre>
</div><p>Comprobamos que funciona abriendo un navegador y accediendo a cualquier sitio web (hoy en día la mayoría son https). En mi caso lo he hecho con lynx:</p>
<div><pre><code>apt install lynx
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos1/6.png" alt="image"></p>
<h2 id="permitimos-el-acceso-a-nuestro-servidor-web"> Permitimos el acceso a nuestro servidor web</h2>
<div><pre><code>iptables -A INPUT -i ens3 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A OUTPUT -o ens3 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT
</code></pre>
</div><p>En mi caso he vuelto a hacer la comprobación por lynx (lynx &quot;mi-ip-flotante&quot;)</p>
<p><img src="./../images/SAD/cortafuegos1/7.png" alt="image"></p>
<hr>
<h2 id="ejercicios"> Ejercicios</h2>
<p><strong>1. Permite poder hacer conexiones ssh al exterior.</strong></p>
<p>Vamos a añadir las reglas que permitan realizar conexiones ssh al exterior:</p>
<div><pre><code>iptables -A INPUT -i ens3 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
iptables -A OUTPUT -o ens3 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
</code></pre>
</div><p>Probemos si podemos conectarnos por ssh a otra máquina:</p>
<p><img src="./../images/SAD/cortafuegos1/tarea1-1.png" alt="image"></p>
<p>Efectivamente, podemos conectarnos, por lo que podemos decir que la regla funciona correctamente.</p>
<p><strong>2. Deniega el acceso a tu servidor web desde una ip concreta.</strong></p>
<p>Antes de agregar la regla de bloqueo, es importante considerar las reglas de INPUT que ya tenemos establecidas:</p>
<div><pre><code>iptables -L -v -n
</code></pre>
</div><p>Si agregamos la regla de bloqueo al final, no sería efectiva, ya que siempre se superpondría con la regla previa que permite todo el tráfico HTTP entrante.</p>
<p>Para solucionarlo, añadimos por encima la nueva regla.</p>
<p>Necesitamos saber el número de línea específico, así que ejecutamos el siguiente comando:</p>
<div><pre><code>iptables -L -v -n --line-numbers
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos1/tarea2-0.png" alt="image"></p>
<p>Vamos a añadir la regla de bloqueo en la posición marcada para que funcione:</p>
<div><pre><code>iptables -I INPUT 6 -s 10.0.0.216/32 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j DROP
</code></pre>
</div><p>Esta regla permitirá el acceso a nuestro servidor web desde cualquier máquina que no tenga la dirección IP especificada. Verifiquemos si funciona:</p>
<ul>
<li>Desde otra ip que no es la bloqueada:</li>
</ul>
<p><img src="./../images/SAD/cortafuegos1/tarea2-1.png" alt="image"></p>
<ul>
<li>Desde la ip bloqueda:</li>
</ul>
<p><img src="./../images/SAD/cortafuegos1/tarea2-2.png" alt="image"></p>
<p>Como vemos, podemos acceder desde cualquier máquina que no sea la que tenga la ip que tenemos bloqueada.</p>
<p><strong>3. Permite hacer consultas DNS sólo al servidor 192.168.202.2. Comprueba que no puedes hacer un dig @1.1.1.1.</strong></p>
<p>En esta situación, estamos enfrentando un problema similar al del ejercicio anterior. Sin embargo, en este caso necesitamos eliminar dos reglas antiguas que permitían todo el tráfico DNS saliente.</p>
<div><pre><code>iptables -L -v -n --line-numbers
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos1/tarea3-0.png" alt="image"></p>
<p>Aun si añadiéramos las nuevas reglas por encima de estas, si ejecutamos el comando <code>dig</code> a 1.1.1.1, se produciría una coincidencia con estas reglas, lo que permitiría el tráfico. Esto no es lo que buscamos.</p>
<p>Primero, borramos las reglas antiguas:</p>
<div><pre><code>iptables -D INPUT 5
iptables -D OUTPUT 5
</code></pre>
</div><p>Despues añadimos las siguientes reglas:</p>
<div><pre><code>iptables -A INPUT -s 192.168.202.2/32 -p udp --sport 53 -m state --state ESTABLISHED -j ACCEPT
iptables -A OUTPUT -d 192.168.202.2/32 -p udp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
</code></pre>
</div><p>Vemos que no podemos hacer un dig @1.1.1.1:</p>
<p><img src="./../images/SAD/cortafuegos1/tarea3-1.png" alt="image"></p>
<p>Pero si podemos usar el servidor dns que hay en “192.168.202.2”:</p>
<p><img src="./../images/SAD/cortafuegos1/tarea3-2.png" alt="image"></p>
<p><strong>4. No permitir el acceso al servidor web de www.josedomingo.org (Tienes que utilizar la ip). ¿Puedes acceder a fp.josedomingo.org?</strong></p>
<p>Una vez más, si agregamos la siguiente regla al final, tendremos un conflicto de reglas, ya que antes tenemos una que permite todo el tráfico HTTP de salida. Los emparejamientos siempre se detendrían ahí.</p>
<div><pre><code>iptables -L -v -n --line-numbers
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos1/tarea4-0.png" alt="image"></p>
<p>Es necesario agregar la regla de bloqueo por encima de la regla previamente mostrada:</p>
<div><pre><code>iptables -I OUTPUT 5 -d 37.187.119.60/32 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j DROP
</code></pre>
</div><p>Ahora no podemos acceder a esa url desde esta máquina debido a la regla del cortafuegos:</p>
<p><img src="./../images/SAD/cortafuegos1/tarea4-1.png" alt="image"></p>
<p>Tampoco podemos acceder a fp.josedomingo.org, ya que tiene la misma ip, y la tenemos bloqueada:</p>
<p><img src="./../images/SAD/cortafuegos1/tarea4-2.png" alt="image"></p>
<p>Sin embargo, si que podemos acceder a otros dominios que no tengan esa ip:</p>
<p><img src="./../images/SAD/cortafuegos1/tarea4-3.png" alt="image"></p>
<p>Como vemos, la regla funciona bien, pero debemos tener cuidado al bloquear ciertas ips, ya que podríamos estar bloqueando más servicios de los que queremos.</p>
<p><strong>5. Permite mandar un correo usando nuestro servidor de correo: babuino-smtp. Para probarlo ejecuta un telnet bubuino-smtp.gonzalonazareno.org 25.</strong></p>
<p>Lo primero que haremos será crear las reglas Iptables:</p>
<div><pre><code>iptables -A OUTPUT -d 192.168.203.3 -p tcp --dport 25 -j ACCEPT
iptables -A INPUT -s 192.168.203.3 -p tcp --sport 25 -j ACCEPT
</code></pre>
</div><p>Pruebo que funciona con telnet:</p>
<div><pre><code>telnet babuino-smtp.gonzalonazareno.org 25
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos1/tarea5-1.png" alt="image"></p>
<p><strong>6. Instala un servidor mariadb, y permite los accesos desde la ip de tu cliente. Comprueba que desde otro cliente no se puede acceder.</strong></p>
<p>Instalamos mariadb-server y permitimos conexiones remotas:</p>
<div><pre><code>apt install mariadb-server
</code></pre>
</div><p>Editamos el siguiente fichero <code>/etc/mysql/mariadb.conf.d/50-server.cnf</code>:</p>
<div><pre><code>bind-address            = 0.0.0.0
</code></pre>
</div><p>Reiniciamos mariadb:</p>
<div><pre><code>systemctl restart mariadb
</code></pre>
</div><p>A continuación, habilitamos el tráfico entrante desde mi máquina host:</p>
<div><pre><code>iptables -A INPUT -s 10.0.0.180 -p tcp --dport 3306 -j ACCEPT
iptables -A OUTPUT -d 10.0.0.180 -p tcp --sport 3306 -j ACCEPT
</code></pre>
</div><p>Creo un usuario en la maquina para despues comprobar el funcionamiento:</p>
<p><img src="./../images/SAD/cortafuegos1/tarea6-1.png" alt="image"></p>
<p>Probamos que funciona:</p>
<div><pre><code>mariadb -u cortafuegos -h 10.0.0.72 -p
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos1/tarea6-2.png" alt="image"></p>
<p>Verificamos que el tráfico se bloquea desde otro cliente:</p>
<div><pre><code>mariadb -u cortafuegos -h 10.0.0.72 -p
</code></pre>
</div><p><img src="./../images/SAD/cortafuegos1/tarea6-3.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Informática Forense</title>
    <id>https://github.com/oscarlucas22/practicas/forense/</id>
    <link href="https://github.com/oscarlucas22/practicas/forense/"/>
    <updated>2023-03-07T17:02:54.449Z</updated>
    <content type="html"><![CDATA[<h1 id="informatica-forense"> Informática Forense</h1>
<p><strong>La informática forense es el conjunto de técnicas que nos permite obtener la máxima información posible tras un incidente o delito informático.</strong></p>
<p><strong>En esta práctica, realizarás la fase de toma de evidencias y análisis de las mismas sobre una máquina Linux y otra Windows. Supondremos que pillamos al delincuente in fraganti y las máquinas se encontraban encendidas. Opcionalmente, podéis realizar el análisis de un dispositivo Android.</strong></p>
<p><strong>Sobre cada una de las máquinas debes realizar un volcado de memoria y otro de disco duro, tomando las medidas necesarias para certificar posteriormente la cadena de custodia.</strong></p>
<p><strong>Debes tratar de obtener las siguientes informaciones:</strong></p>
<p><strong>Apartado A) Máquina Windows.</strong></p>
<p><strong>Por comandos:</strong></p>
<p><strong>1. Procesos en ejecución.</strong></p>
<p><strong>2. Servicios en ejecución.</strong></p>
<p><strong>3. Puertos abiertos.</strong></p>
<p><strong>4. Conexiones establecidas por la máquina.</strong></p>
<p><strong>5. Sesiones de usuario establecidas remotamente.</strong></p>
<p><strong>6. Ficheros transferidos recientemente por NetBios.</strong></p>
<p><strong>7. Contenido de la caché DNS.</strong></p>
<p><strong>8. Variables de entorno.</strong></p>
<p><strong>Analizando el Registro de Windows:</strong></p>
<p><strong>9. Dispositivos USB conectados</strong></p>
<p><strong>10. Redes wifi utilizadas recientemente.</strong></p>
<p><strong>11. Configuración del firewall de nodo.</strong></p>
<p><strong>12. Programas que se ejecutan en el Inicio.</strong></p>
<p><strong>13. Asociación de extensiones de ficheros y aplicaciones.</strong></p>
<p><strong>14. Aplicaciones usadas recientemente.</strong></p>
<p><strong>15. Ficheros abiertos recientemente.</strong></p>
<p><strong>16. Software Instalado.</strong></p>
<p><strong>17. Contraseñas guardadas.</strong></p>
<p><strong>18. Cuentas de Usuario</strong></p>
<p><strong>Con Aplicaciones de terceros:</strong></p>
<p><strong>19. Historial de navegación y descargas. Cookies.</strong></p>
<p><strong>20. Volúmenes cifrados</strong></p>
<p><strong>Sobre la imagen del disco:</strong></p>
<p><strong>21. Archivos con extensión cambiada.</strong></p>
<p><strong>22. Archivos eliminados.</strong></p>
<p><strong>23. Archivos Ocultos.</strong></p>
<p><strong>24. Archivos que contienen una cadena determinada.</strong></p>
<p><strong>25. Búsqueda de imágenes por ubicación.</strong></p>
<p><strong>26. Búsqueda de archivos por autor.</strong></p>
<p><strong>Apartado B) Máquina Linux.</strong></p>
<p><strong>Intenta realizar las mismas operaciones en una máquina Linux para aquellos apartados que tengan sentido y no se realicen de manera idéntica a Windows.</strong></p>
<p><strong>Apartado C)</strong></p>
<p><strong>En un dispositivo Android, trata de hacer un volcado de memoria y recuperar información de ubicación, llamadas, mensajes, aplicaciones de mensajería, perfiles en redes sociales, etc...</strong></p>
<p><strong>Algunos kits de herramientas forenses open-source:</strong></p>
<p><strong>Caine</strong>
<strong>DFF (Digital Forensics Framework)</strong>
<strong>The Sleuth Kit</strong>
<strong>Helix Live CD</strong>
<strong>Digital Evidence and Forensics Toolkit (DEFT)</strong></p>
<p><strong>Para análisis de memoria:</strong></p>
<p><strong>Volatility</strong>
<strong>Access Data FTK Imager</strong>
<strong>MDD</strong></p>
<p><strong>Para análisis de registro de Windows:</strong></p>
<p><strong>AccessData Registry Viewer</strong>
<strong>Kape</strong>
<strong>Fred (Forensic Registry Editor)</strong></p>
<p><strong>Para análisis de discos duros:</strong></p>
<p><strong>Autopsy</strong></p>
<p><strong>Herramientas gratuitas para Android:</strong></p>
<p><strong>AFLogical OSE</strong>
<strong>OSAF (Open Source Android Forensics)</strong>
<strong>Andriller</strong>
<strong>ADEL (Android Data Extractor Lite)</strong>
<strong>WhatsApp Xtract</strong>
<strong>Skype Xtractor</strong>
<strong>Android Pattern Lock Cracker</strong></p>
<p><strong>Para saber algo más:</strong></p>
<p><strong>Cursos básicos de Análisis Forense Linux y Windows en OpenWebinars.</strong>
**Cursos gratuitos en TryHackMe.**AD</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">LDAPs</title>
    <id>https://github.com/oscarlucas22/practicas/ldaps/</id>
    <link href="https://github.com/oscarlucas22/practicas/ldaps/"/>
    <updated>2023-03-07T17:02:54.452Z</updated>
    <content type="html"><![CDATA[<h1 id="ldaps"> LDAPs</h1>
<p><strong>Configura el servidor LDAP de alfa para que utilice el protocolo ldaps:// a la vez que el ldap:// utilizando el certificado x509 de la práctica de https o solicitando el correspondiente a través de gestiona. Realiza las modificaciones adecuadas en los clientes ldap de alfa para que todas las consultas se realicen por defecto utilizando ldaps://</strong></p>
<p>Para empezar, crearemos el directorio que usaremos para almacenar las claves SSL y le otorgaremos los permisos adecuados. Luego, procederemos a generar la clave RSA.</p>
<div><pre><code>mkdir /etc/ssl/private
chmod 700 /etc/ssl/private/
openssl genrsa 4096 &gt; /etc/ssl/private/alfa.key
</code></pre>
</div><p><img src="./../images/ASO/ldaps/1.png" alt="image"></p>
<p>Vamos a generar un archivo utilizando la clave previamente creada y lo presentaremos para obtener la firma de la autoridad certificadora de IES Gonzalo Nazareno.</p>
<p><img src="./../images/ASO/ldaps/2.png" alt="image"></p>
<p>En este apartado utilizaremos los certificados generados.</p>
<p><img src="./../images/ASO/ldaps/3.png" alt="image"></p>
<p>Para llevar a cabo este ejercicio, trasladaremos los archivos a sus respectivas carpetas correspondientes.</p>
<div><pre><code>sudo mv gonzalonazareno.crt /etc/ssl/certs/
sudo mv alfa.crt /etc/ssl/certs/
sudo mv alfa.key /etc/ssl/private/
</code></pre>
</div><p>Para permitir al usuario openldap acceder al archivo y al directorio que lo contiene, necesitamos concederle los permisos necesarios. Para lograr esto de manera más precisa y eficiente, instalaremos el paquete acl antes de asignar los permisos correspondientes.</p>
<div><pre><code>sudo apt install acl
</code></pre>
</div><hr>
<div><pre><code>setfacl -m u:openldap:r-x /etc/ssl/private
setfacl -m u:openldap:r-x /etc/ssl/private/alfa.key
</code></pre>
</div><p>Antes de iniciar la configuración, comprobaremos que el servicio slapd utiliza el mismo puerto que ldap (389/TCP).</p>
<div><pre><code>netstat -tlnp | egrep 'slapd'
</code></pre>
</div><p><img src="./../images/ASO/ldaps/4.png" alt="image"></p>
<p>Ya que abordaremos los parámetros de configuración como si fueran atributos de un objeto en el directorio, será necesario crear un archivo con extensión .ldif que contenga las modificaciones que se llevarán a cabo.</p>
<div><pre><code>sudo nano seguro.ldif
</code></pre>
</div><hr>
<div><pre><code>dn: cn=config
changetype: modify
replace: olcTLSCACertificateFile
olcTLSCACertificateFile: /etc/ssl/certs/gonzalonazareno.crt           
-
replace: olcTLSCertificateKeyFile
olcTLSCertificateKeyFile: /etc/ssl/private/alfa.key
-
replace: olcTLSCertificateFile
olcTLSCertificateFile: /etc/ssl/certs/alfa.crt
</code></pre>
</div><p>A continuación, importaremos el archivo para modificar los atributos de la configuración mediante el uso de ldapmodify.</p>
<div><pre><code>ldapmodify -Y EXTERNAL -H ldapi:/// -f seguro.ldif
</code></pre>
</div><p><img src="./../images/ASO/ldaps/5.png" alt="image"></p>
<p>De manera predeterminada, el protocolo no incluye la opción de ldaps, por lo que deberemos implementarla.</p>
<div><pre><code>sudo nano /etc/default/slapd
</code></pre>
</div><hr>
<div><pre><code>SLAPD_SERVICES=&quot;ldap:/// ldapi:/// ldaps:///&quot;
</code></pre>
</div><p>Procederemos a reiniciar el servicio slapd y luego verificaremos su estado actual.</p>
<div><pre><code>systemctl restart slapd
systemctl status slapd
</code></pre>
</div><p><img src="./../images/ASO/ldaps/6.png" alt="image"></p>
<p>Verificaremos que el nuevo protocolo se esté ejecutando correctamente en el puerto 636/TCP.</p>
<div><pre><code>netstat -tlnp | egrep 'slapd'
</code></pre>
</div><p><img src="./../images/ASO/ldaps/7.png" alt="image"></p>
<p>En el lado del cliente, al igual que importamos certificados de autoridades certificadoras en el navegador para usar el protocolo HTTPS, debemos hacer lo mismo para aplicaciones manejadas desde la línea de comandos que utilizan otros protocolos cifrados, como ldaps://. El paquete encargado de manejar la lista de autoridades certificadoras es ca-certificates.</p>
<p>Para hacer esto, debemos copiar el certificado de la autoridad certificadora IES Gonzalo Nazareno desde /etc/ssl/certs/ a /usr/local/share/ca-certificates/, crear un enlace simbólico y concatenarlo en el archivo ca-certificates.crt utilizando los siguientes comandos:</p>
<div><pre><code>cp /etc/ssl/certs/gonzalonazareno.crt /usr/local/share/ca-certificates/
update-ca-certificates
</code></pre>
</div><p><img src="./../images/ASO/ldaps/8.png" alt="image"></p>
<p>Para verificar que todo funciona correctamente, realizaremos una búsqueda anónima en el directorio utilizando LDAP sobre SSL/TLS.</p>
<div><pre><code>ldapsearch -x -b &quot;dc=olucas,dc=gonzalonazareno,dc=org&quot; -H ldaps://localhost:636
</code></pre>
</div><p><img src="./../images/ASO/ldaps/9.png" alt="image"></p>
<p>Ahora, necesitamos configurar correctamente LDAP para que utilice el protocolo ldaps:// por defecto. Para lograr esto, debemos agregar la especificación ldaps://localhost a la directiva URI.</p>
<div><pre><code>nano /etc/ldap/ldap.conf
URI     ldaps://alfa.olucas.gonzalonazareno.org
</code></pre>
</div><p>Volveremos a realizar la misma consulta realizada anteriormente sin especificar el método de conexión.</p>
<div><pre><code>ldapsearch -x -b &quot;dc=olucas,dc=gonzalonazareno,dc=org&quot;
</code></pre>
</div><p><img src="./../images/ASO/ldaps/10.png" alt="image"></p>
<p>Podemos verificar que ahora se está utilizando el protocolo SSL/TLS de forma predeterminada al utilizar LDAP.</p>
<hr>
<p><em>Cliente Rocky</em></p>
<p>Vamos a crear un fichero de configuración para el cliente:</p>
<div><pre><code>nano /etc/openldap/ldap.conf
</code></pre>
</div><hr>
<div><pre><code>BASE dc=olucas,dc=gonzalonazareno,dc=org
URI ldaps://alfa.olucas.gonzalonazareno.org
</code></pre>
</div><p>Despues de hacer esto meteremos en la ruta <code>/etc/pki/ca-trust/source/anchors/</code> el fichero de gonzalonazareno.crt</p>
<p>Para guardar estos cambios ejecutaremos el siguiente comando:</p>
<div><pre><code>update-ca-trust
</code></pre>
</div><p>Una vez que ya tenemos el fichero de configuración, podemos comprobar que funciona correctamente:</p>
<div><pre><code>ldapsearch -x -b &quot;dc=olucas,dc=gonzalonazareno,dc=org&quot;
</code></pre>
</div><p><img src="./../images/ASO/ldaps/1-rocky.png" alt="image"></p>
<p>Como podemos ver, funciona correctamente.</p>
<p>Ahora vamos a comprobar que funciona correctamente desde el cliente Rocky. Para ello, usaremos el siguiente comando para conectarnos al servidor LDAP con el usuario prueba y verificar la autentificación:</p>
<div><pre><code>ldapwhoami -x -D &quot;uid=prueba,ou=Personas,dc=olucas,dc=gonzalonazareno,dc=org&quot; -W
</code></pre>
</div><p><img src="./../images/ASO/ldaps/2-rocky.png" alt="image"></p>
<p>Como podemos ver, funciona correctamente.</p>
<p>Creamos el directorio de montaje:</p>
<div><pre><code>mkdir /home/nfs
mkdir /home/nfs/prueba
chown 2001:2001 /home/nfs/prueba
</code></pre>
</div><p>Para solucionar el problema de no visualizar los cambios en la carpeta de inicio del usuario prueba, debemos montarla a través de NFS. De esta manera, podremos acceder a los cambios realizados desde cualquier cliente conectado.</p>
<p>Cargamos el módulo:</p>
<div><pre><code>modprobe nfs
</code></pre>
</div><p>Ejecutamos lo siguiente para que se cargue el modulo automáticamente:</p>
<div><pre><code>echo NFS | tee -a /etc/modules
</code></pre>
</div><p>Lo montamos mediante systemd:</p>
<div><pre><code>nano /etc/systemd/system/home-nfs.mount
</code></pre>
</div><p>Añadimos las siguientes líneas:</p>
<div><pre><code>[Unit]
Description=script de montaje NFS
Requires=NetworkManager.service
After=NetworkManager.service
[Mount]
What=172.16.0.1:/home/nfs
Where=/home/nfs
Options=_netdev,auto
Type=nfs
[Install]
WantedBy=multi-user.target
</code></pre>
</div><p>Reiniciamos el servicio:</p>
<div><pre><code>systemctl daemon-reload
systemctl start home-nfs.mount
systemctl enable home-nfs.mount
</code></pre>
</div><hr>
<div><pre><code>systemctl status home-nfs.mount
</code></pre>
</div><p><img src="./../images/ASO/ldaps/3-rocky.png" alt="image"></p>
<p><img src="./../images/ASO/ldaps/4-rocky.png" alt="image"></p>
<p>Ahora vamos a comprobar que funciona correctamente al loguearnos con el usuario prueba:</p>
<p><img src="./../images/ASO/ldaps/5-rocky.png" alt="image"></p>
<p>Hasta aquí la configuración del cliente Rocky.</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Kubernetes</title>
    <id>https://github.com/oscarlucas22/practicas/kubernetes/</id>
    <link href="https://github.com/oscarlucas22/practicas/kubernetes/"/>
    <updated>2023-03-07T17:02:54.454Z</updated>
    <content type="html"><![CDATA[<h1 id="kubernetes"> Kubernetes</h1>
<p><strong>En IAW has creado dos imágenes de dos aplicaciones: bookmedik (php) y polls (python django). Elige una de ellas y despliégala en kubernetes. Para ello vamos a hacer dos ejercicios:</strong></p>
<p>En este <a href="./../practicas/python-docker.html">post</a> realizamos la implantación de una aplicación en Docker. En este post vamos a realizar el despliegue de la misma aplicación en Kubernetes.</p>
<h2 id="ejercicio1-despliegue-en-minikube"> Ejercicio1: Despliegue en minikube</h2>
<p><strong>Escribe los ficheros yaml que te posibilitan desplegar la aplicación en minikube. Recuerda que la base de datos debe tener un volumen para hacerla persistente. Debes crear ficheros para los deployments, services, ingress, volúmenes,…</strong></p>
<p><strong>Despliega la aplicación en minikube.</strong></p>
<p><font color="#0000FF">Paso 1</font> Creamos los ficheros yaml para crear un ConfigMap y un Secret donde guardaremos las variables de entorno.</p>
<div><pre><code>kubectl create cm cm-mariad --from-literal=mysql_usuario=bookmedik \
                            --from-literal=basededatos=bookmedik \
                            -o yaml --dry-run=client &gt; bd_datos_configmap.yaml

kubectl create secret generic secret-mariadb --from-literal=password=bookmedik \
                                             --from-literal=rootpass=root \
                                             -o yaml --dry-run=client &gt; bd_passwords_secret.yaml
</code></pre>
</div><p><font color="#0000FF">Paso 2</font> Creamos el volumen y el fichero de despliegue para mariadb</p>
<ul>
<li>Volumen para mariadb</li>
</ul>
<hr>
<div><pre><code>nano pvc-bookmedik.yaml
</code></pre>
</div><hr>
<div><pre><code>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
    name: pvc-bookmedik
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi
</code></pre>
</div><ul>
<li>Despliegue de mariadb</li>
</ul>
<hr>
<div><pre><code>nano mariadb-deployment.yaml
</code></pre>
</div><hr>
<div><pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: mariadb
  labels:
    app: mariadb
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mariadb
      tier: backend
  template:
    metadata:
      labels:
        app: mariadb
        tier: backend
    spec:
      volumes:
        - name: vol-mariadb
          persistentVolumeClaim:
            claimName: pvc-bookmedik
      containers:
        - name: cont-mariadb
          image: mariadb
          env:
            - name: MARIADB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: secret-mariadb
                  key: rootpass
            - name: MARIADB_DATABASE
              valueFrom:
                configMapKeyRef:
                  name: cm-mariadb
                  key: basededatos
            - name: MARIADB_USER
              valueFrom:
                configMapKeyRef:
                  name: cm-mariadb
                  key: mysql_usuario
            - name: MARIADB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: secret-mariadb
                  key: password
          ports:
            - name: mariadb-server
              containerPort: 3306
          volumeMounts:
            - mountPath: &quot;/var/lib/mysql&quot;
              name: vol-mariadb
</code></pre>
</div><ul>
<li>Servicio de mariadb</li>
</ul>
<hr>
<div><pre><code>nano mariadb-srv.yaml
</code></pre>
</div><hr>
<div><pre><code>apiVersion: v1
kind: Service
metadata:
  name: mariadb
  labels:
    app: mariadb
    tier: backend
spec:
  type: ClusterIP
  ports:
  - port: 3306
    targetPort: mariadb-server
  selector:
    app: mariadb
    tier: backend
</code></pre>
</div><p><font color="#0000FF">Paso 3</font> Creamos los ficheros de despliegue y servicios para bookmedik.</p>
<ul>
<li>Despliegue de bookmedik</li>
</ul>
<hr>
<div><pre><code>nano bookmedik-deployment.yaml
</code></pre>
</div><hr>
<div><pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: bookmedik
  labels:
    app: bookmedik
    tier: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: bookmedik
      tier: frontend
  template:
    metadata:
      labels:
        app: bookmedik
        tier: frontend
    spec:
      containers:
      - name: cont-bookmedik
        image: oscarlucas/bookmedik:v1
        env:
          - name: USER_BOOKMEDIK
            valueFrom:
              configMapKeyRef:
                name: cm-mariadb
                key: mysql_usuario
          - name: PASSWD_BOOKMEDIK
            valueFrom:
              secretKeyRef:
                name: secret-mariadb
                key: password
          - name: DB_HOST
            value: mariadb
          - name: NOMBRE_DB
            valueFrom:
              configMapKeyRef:
                name: cm-mariadb
                key: basededatos
        ports:
          - name: http-server
            containerPort: 80
</code></pre>
</div><ul>
<li>Servicio de bookmedik</li>
</ul>
<hr>
<div><pre><code>nano bookmedik-srv.yaml
</code></pre>
</div><hr>
<div><pre><code>apiVersion: v1
kind: Service
metadata:
  name: bookmedik
  labels:
    app: bookmedik
    tier: frontend
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: http-server
  selector:
    app: bookmedik
    tier: frontend
</code></pre>
</div><p><font color="#0000FF">Paso 4</font> Creamos todo y anotamos la primera versión de la aplicación.</p>
<div><pre><code>kubectl apply -f .
</code></pre>
</div><p>Y apuntamos el lanzamiento de la primera versión de bookmedik:</p>
<div><pre><code>kubectl annotate deployment.apps/bookmedik kubernetes.io/change-cause=&quot;Versión 1&quot;
</code></pre>
</div><p>Podemos observar como se han creado todos los recursos que hemos definido:</p>
<div><pre><code>kubectl get all
</code></pre>
</div><p><img src="./../images/SRI/kb/1.png" alt="image"></p>
<p><font color="#0000FF">Paso 5</font> Accedemos a la aplicación y comprobamos que funciona correctamente.</p>
<p><img src="./../images/SRI/kb/2.png" alt="image"></p>
<p>Y comprobamos que podemos acceder:</p>
<p><img src="./../images/SRI/kb/3.png" alt="image"></p>
<p><font color="#0000FF">Paso 6</font> Creamos el fichero Ingress para acceder a la aplicación desde el exterior.</p>
<div><pre><code>nano ingress.yaml
</code></pre>
</div><hr>
<div><pre><code>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress
spec:
  rules:
  - host: www.olucas-bookmedik.org
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: bookmedik
            port:
              number: 80
</code></pre>
</div><p>Y lo creamos:</p>
<div><pre><code>kubectl apply -f ingress.yaml
</code></pre>
</div><p><font color="#0000FF">Paso 7</font> Modificamos el fichero <code>/etc/hosts</code> para que apunte a la IP del nodo maestro.</p>
<p><font color="#0000FF">Paso 8</font> Accedemos a la aplicación desde el navegador.</p>
<p><img src="./../images/SRI/kb/4.png" alt="image"></p>
<p>Y accedemos a la zona de administración:</p>
<p><img src="./../images/SRI/kb/5.png" alt="image"></p>
<p><font color="#0000FF">Paso 9</font> Creamos información para probar la persistencia de la base de datos cuando borremos la base de datos de mariadb.</p>
<p><img src="./../images/SRI/kb/6.png" alt="image"></p>
<ul>
<li>Eliminamos el despliegue de mariadb.</li>
</ul>
<hr>
<div><pre><code>kubectl delete mariadb-deployment.yaml
</code></pre>
</div><ul>
<li>Comprobamos que la base de datos no funciona.</li>
</ul>
<p><img src="./../images/SRI/kb/7.png" alt="image"></p>
<p><font color="#0000FF">Paso 10</font> Ahora nos toca escalar el despliegue de la aplicación a 3 réplicas y lo podemos hacer de dos formas:</p>
<p>Para escalar el despliegue de bookmedik a tres pods hay dos opciones: o lo hacemos a través de la terminal y el cambio sería temporal o modificamos el fichero .yaml del despliegue y alteramos el número de pods. Yo he optado por la primera opción:</p>
<div><pre><code>kubectl scale deployment.apps/bookmedik --replicas=3
</code></pre>
</div><p>Vemos que se han creado los nuevos pods:</p>
<p><img src="./../images/SRI/kb/8.png" alt="image"></p>
<p><font color="#0000FF">Paso 11</font> Vamos a crear una imagen docker, pero con alguna modficación, para probar el despliegue de una nueva versión de la aplicación.</p>
<ul>
<li>Modificamos el fichero index.php de la aplicación para que muestre la versión de la aplicación.</li>
</ul>
<p><img src="./../images/SRI/kb/9.png" alt="image"></p>
<p>En mi caso, le he cambiado el texto de la página principal y de la pestaña del navegador.</p>
<ul>
<li>Creamos la imagen docker con la nueva versión de la aplicación.</li>
</ul>
<hr>
<div><pre><code>docker build -t oscarlucas/bookmedik:v1_1 .
</code></pre>
</div><ul>
<li>Subimos la imagen a docker hub.</li>
</ul>
<hr>
<div><pre><code>docker push oscarlucas/bookmedik:v1_1
</code></pre>
</div><ul>
<li>Modificamos el fichero de despliegue para que use la nueva versión de la imagen.</li>
</ul>
<p><img src="./../images/SRI/kb/10.png" alt="image"></p>
<ul>
<li>Aplicamos los cambios.</li>
</ul>
<hr>
<div><pre><code>kubectl apply -f bookmedik-deployment.yaml
</code></pre>
</div><ul>
<li>Comprobamos que se ha desplegado la nueva versión de la aplicación.</li>
</ul>
<p><img src="./../images/SRI/kb/11.png" alt="image"></p>
<p>Y que podemos acceder a la zona de administración.</p>
<p><img src="./../images/SRI/kb/12.png" alt="image"></p>
<h2 id="ejercicio2-despliegue-en-otra-distribucion-de-kubernetes"> Ejercicio2: Despliegue en otra distribución de kubernetes</h2>
<p><strong>Instala un clúster de kubernetes (más de un nodo). Tienes distintas opciones para construir un cluster de kubernetes: Alternativas para instalación simple de k8s.</strong></p>
<p><strong>Realiza el despliegue de la aplicación en el nuevo clúster. Es posible que no tenga instalado un ingress master, por lo que no va a funcionar el ingress (puedes buscar como hacer la instalación: por ejemplo el nginx master).</strong></p>
<p><strong>Escala la aplicación y ejecuta kubectl get pods -o wide para ver cómo se ejecutan en los distintos nodos del clúster.</strong></p>
<hr>
<p>En esta parte, vamos a instalar un cluster de kubernetes. Pero lo haremos en una distribución diferente a la que hemos usado hasta ahora. Pero debemos hacerlo en otra versión, y he decidido hacerlo en k3s, que es una versión ligera de kubernetes.</p>
<p><font color="#0000FF">Paso 1</font> Creamos 3 nodos, uno maestro y dos esclavos.</p>
<div><pre><code>Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.define :master do |master|
    master.vm.box = &quot;debian/buster64&quot;
    master.vm.hostname = &quot;master&quot;
    master.vm.network :private_network, ip: &quot;192.168.0.1&quot;
    master.nfs.verify_installed = false
    master.vm.synced_folder '.', '/vagrant', disabled: true
    master.vm.provider &quot;libvirt&quot; do |v|
      v.memory = 3072
      v.cpus = 2
    end
  end
  config.vm.define :node1 do |node1|
    node1.vm.box = &quot;debian/buster64&quot;
    node1.vm.hostname = &quot;node1&quot;
    node1.vm.network :private_network, ip: &quot;192.168.0.2&quot;
    node1.nfs.verify_installed = false
    node1.vm.synced_folder '.', '/vagrant', disabled: true
    node1.vm.provider &quot;libvirt&quot; do |v|
      v.memory = 3072
      v.cpus = 2
    end
  end
  config.vm.define :node2 do |node2|
    node2.vm.box = &quot;debian/buster64&quot;
    node2.vm.hostname = &quot;node2&quot;
    node2.vm.network :private_network, ip: &quot;192.168.0.3&quot;
    node2.nfs.verify_installed = false
    node2.vm.synced_folder '.', '/vagrant', disabled: true
    node2.vm.provider &quot;libvirt&quot; do |v|
      v.memory = 3072
      v.cpus = 2
    end
  end
end
</code></pre>
</div><p><font color="#0000FF">Paso 2</font> Instalamos k3s en el nodo maestro.</p>
<div><pre><code>curl -sfL https://get.k3s.io | sh -
</code></pre>
</div><p><img src="./../images/SRI/kb/13.png" alt="image"></p>
<p>Y comprobamos que está listo.</p>
<div><pre><code>kubectl get nodes
</code></pre>
</div><p><img src="./../images/SRI/kb/14.png" alt="image"></p>
<p><font color="#0000FF">Paso 3</font> Identificamos el token del nodo maestro.</p>
<div><pre><code>sudo cat /var/lib/rancher/k3s/server/node-token
</code></pre>
</div><p><img src="./../images/SRI/kb/15.png" alt="image"></p>
<p><font color="#0000FF">Paso 4</font> Ejecutamos lo siguiente:</p>
<div><pre><code>curl -sfL https://get.k3s.io | K3S_URL=https://192.168.121.236:6443 K3S_TOKEN=K10f5139d923389039d43c7d10b32d2238cd20158dce4430da3f344cd5a34b59470::server:a88a45d0d75b2cf990ece4c5bedf8458 sh -
</code></pre>
</div><p><em>node1</em></p>
<p><img src="./../images/SRI/kb/16.png" alt="image"></p>
<p><em>node2</em></p>
<p><img src="./../images/SRI/kb/17.png" alt="image"></p>
<p>El comando anterior nos instala k3s en el nodo esclavo y lo añade al cluster. En el parámetro URL, debemos poner la IP del nodo maestro y en el parámetro token, el token que hemos obtenido en el paso anterior.</p>
<p><font color="#0000FF">Paso 5</font> Comprobamos que los nodos están listos.</p>
<div><pre><code>kubectl get nodes
</code></pre>
</div><p><font color="#0000FF">Paso 6</font> Instalamos git en el nodo maestro ( master).</p>
<div><pre><code>sudo apt install git
</code></pre>
</div><p><font color="#0000FF">Paso 7</font> Clonamos el repositorio de la aplicación.</p>
<div><pre><code>git clone https://github.com/oscarlucas22/kubernete-docker.git
</code></pre>
</div><p><font color="#0000FF">Paso 8</font> Rehacemos los pasos que hicimos en el ejercicio anterior:</p>
<ul>
<li>Creamos los ficheros yaml para crear un ConfigMap y un Secret donde guardaremos las variables de entorno.</li>
</ul>
<hr>
<div><pre><code>kubectl create cm cm-mariadb --from-literal=mysql_usuario=bookmedik --from-literal=basededatos=bookmedik

kubectl create secret generic secret-mariadb --from-literal=password=bookmedik --from-literal=rootpass=root 
</code></pre>
</div><ul>
<li>Creamos los recursos:</li>
</ul>
<hr>
<div><pre><code>kubectl apply -f .
</code></pre>
</div><ul>
<li>Comprobamos que todo está listo.</li>
</ul>
<hr>
<div><pre><code>kubectl get all
</code></pre>
</div><p><img src="./../images/SRI/kb/18.png" alt="image"></p>
<ul>
<li>Accedemos a la dirección que hemos establecido en el fichero &quot;ingress.yaml&quot;.</li>
</ul>
<p><img src="./../images/SRI/kb/19.png" alt="image"></p>
<p>Y que podemos acceder a la zona de administración.</p>
<p><img src="./../images/SRI/kb/20.png" alt="image"></p>
<p><font color="#0000FF">Paso 9</font> Escalamos el despliegue como hemos hecho en el ejercicio anterior, y lo realizaremos con 3 replicas. Para ello, primero, veamos de nuevo que contamos con 2 replicas y vamos a extenderlo a 1 más.</p>
<ul>
<li>Antes de escalar el despliegue, vamos a ver las replicas que tenemos.</li>
</ul>
<hr>
<div><pre><code>kubectl get pods -o wide
</code></pre>
</div><p><img src="./../images/SRI/kb/21.png" alt="image"></p>
<ul>
<li>Ahora, vamos a escalar el despliegue.</li>
</ul>
<hr>
<div><pre><code>kubectl scale deployment.apps/bookmedik --replicas=3
</code></pre>
</div><ul>
<li>Comprobamos que se ha escalado correctamente y que tenemos 3 replicas.</li>
</ul>
<hr>
<div><pre><code>kubectl get pods -o wide
</code></pre>
</div><p><img src="./../images/SRI/kb/22.png" alt="image"></p>
<ul>
<li>Comprobamos que podemos acceder a la aplicación.</li>
</ul>
<p><img src="./../images/SRI/kb/23.png" alt="image"></p>
<p>Y que podemos acceder a la zona de administración.</p>
<p><img src="./../images/SRI/kb/24.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Poblar un directorio LDAP desde un fichero CSV</title>
    <id>https://github.com/oscarlucas22/practicas/ldap-csv/</id>
    <link href="https://github.com/oscarlucas22/practicas/ldap-csv/"/>
    <updated>2023-03-07T17:02:54.455Z</updated>
    <content type="html"><![CDATA[<h1 id="poblar-un-directorio-ldap-desde-un-fichero-csv"> Poblar un directorio LDAP desde un fichero CSV</h1>
<ul>
<li>
<p><strong>Crear entre todos los alumnos de la clase que vayan a hacer esta tarea un fichero CSV que incluya información personal de cada uno incluyendo los siguientes datos:</strong></p>
<ul>
<li>
<p><strong>Nombre</strong></p>
</li>
<li>
<p><strong>Apellidos</strong></p>
</li>
<li>
<p><strong>Dirección de correo electrónico</strong></p>
</li>
<li>
<p><strong>Nombre de usuario</strong></p>
</li>
<li>
<p><strong>Clave pública ssh</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Añadir otro fichero con la información de las máquinas de los alumnos (solo informativo) :</strong></p>
<ul>
<li>
<p><strong>Hostname</strong></p>
</li>
<li>
<p><strong>IPv4</strong></p>
</li>
<li>
<p><strong>clave pública ssh de la máquina</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Añadir el esquema openssh-lpk al directorio para poder incluir claves públicas ssh en un directorio LDAP.</strong></p>
</li>
<li>
<p><strong>Hacer un script en bash o en python que utilice el fichero como entrada y pueble el directorio LDAP con un objeto para cada alumno utilizando los ObjectClass posixAccount e inetOrgPerson.</strong></p>
</li>
<li>
<p><strong>Configurar el sistema para que sean válidos los usuarios del LDAP.</strong></p>
</li>
<li>
<p><strong>Configurar el servicio ssh para que permita acceder a los usuarios del LDAP utilizando las claves públicas que hay allí, en lugar de almacenarlas en <code>.ssh/authorized_keys</code>, que sólo permita acceder a los equipos que estén en el LDAP en lugar del fichero .ssh/known_hosts y que se cree el directorio &quot;home&quot; al vuelo.</strong></p>
</li>
</ul>
<hr>
<h3 id="crear-entre-todos-los-alumnos-de-la-clase-que-vayan-a-hacer-esta-tarea-un-fichero-csv-que-incluya-informacion-personal-de-cada-uno-incluyendo-los-siguientes-datos"> Crear entre todos los alumnos de la clase que vayan a hacer esta tarea un fichero CSV que incluya información personal de cada uno incluyendo los siguientes datos:</h3>
<p>Avanzamos con la creación del archivo en cuestión.</p>
<div><pre><code>nano usuarios.csv
</code></pre>
</div><p>El fichero quedaría de la siguiente forma:</p>
<div><pre><code>nombre,apellidos,correo,usuario,clave_pública
</code></pre>
</div><h3 id="anadir-el-esquema-openssh-lpk-al-directorio-para-poder-incluir-claves-publicas-ssh-en-un-directorio-ldap"> Añadir el esquema openssh-lpk al directorio para poder incluir claves públicas ssh en un directorio LDAP.</h3>
<p>Una vez completada la creación de estos dos archivos, debemos agregar el esquema openssh-lpk. Para ello, generaremos un archivo ldif con la definición del esquema en <code>/etc/ldap/schema/</code>.</p>
<div><pre><code>nano /etc/ldap/schema/openssh-lpk.ldif
</code></pre>
</div><hr>
<div><pre><code>dn: cn=openssh-lpk,cn=schema,cn=config
objectClass: olcSchemaConfig
cn: openssh-lpk
olcAttributeTypes: ( 1.3.6.1.4.1.24552.500.1.1.1.13 NAME 'sshPublicKey'
DESC 'MANDATORY: OpenSSH Public key'
EQUALITY octetStringMatch
SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 )
olcObjectClasses: ( 1.3.6.1.4.1.24552.500.1.1.2.0 NAME 'ldapPublicKey' SUP top AUXILIARY
DESC 'MANDATORY: OpenSSH LPK objectclass'
MAY ( sshPublicKey $ uid )
)
</code></pre>
</div><p>Y lo importamos con el siguiente comando:</p>
<div><pre><code>ldapadd -Y EXTERNAL -H ldapi:/// -f openssh-lpk.ldif
</code></pre>
</div><h3 id="hacer-un-script-en-bash-o-en-python-que-utilice-el-fichero-como-entrada-y-pueble-el-directorio-ldap-con-un-objeto-para-cada-alumno-utilizando-los-objectclass-posixaccount-e-inetorgperson"> Hacer un script en bash o en python que utilice el fichero como entrada y pueble el directorio LDAP con un objeto para cada alumno utilizando los ObjectClass posixAccount e inetOrgPerson.</h3>
<p>Ahora, centrémonos en el script que agregará los usuarios al directorio LDAP a partir del archivo CSV. He elegido usar Python y un módulo llamado &quot;python3-ldap&quot;. Para evitar problemas de compatibilidad con otras versiones de paquetes, es recomendable crear un entorno virtual y instalar el módulo en él. Por lo tanto, creemos el entorno virtual:</p>
<div><pre><code>apt install python3-venv

python3 -m venv ldap
</code></pre>
</div><p>A continuación, instalemos el módulo necesario. Hay que tener en cuenta que algunas versiones del módulo pueden presentar errores, por lo que es recomendable descargar y utilizar una versión comprobada y que funcione correctamente.</p>
<div><pre><code>pip install python3-ldap

pip install ldap3==2.6
</code></pre>
</div><p>Ahora vayamos al script en cuestión:</p>
<div><pre><code>nano poblarusuarios.py 
</code></pre>
</div><hr>
<div><pre><code>#!/usr/bin/env python

import ldap3
from ldap3 import Connection, ALL
from getpass import getpass
from sys import exit

#### VARIABLES

# Shell que se le asigna a los usuarios
shell = '/bin/bash'

# Ruta absoluta del directorio que contiene los directorios personales de los usuarios. Terminado en &quot;/&quot;
home_dir = '/home/'

# El valor inicial para los UID que se asignan al insertar usuarios. 
uid_number = 5000

# El GID que se le asigna a los usuarios. Si no se manda al anadir el usuario da error.
gid = 5000

#### VARIABLES

# Leemos el fichero .csv de los usuarios y guardamos cada linea en una lista.
with open('user.csv', 'r') as usuarios:
usuarios = usuarios.readlines()


#### Parametros para la conexion
ldap_ip = 'ldaps://localhost:389'
dominio_base = 'dc=olucas,dc=gonzalonazareno,dc=org'
user_admin = 'admin' 
contrasena = getpass('Contrasena: ')

# Intenta realizar la conexion.
conn = Connection(ldap_ip, 'cn={},{}'.format(user_admin, dominio_base),contrasena)

# conn.bind() devuelve &quot;True&quot; si se ha establecido la conexion y &quot;False&quot; en caso contrario.

# Si no se establece la conexion imprime por pantalla un error de conexion.
if not conn.bind():
print('No se ha podido conectar con ldap') 
if conn.result['description'] == 'invalidCredentials':
    print('Credenciales no validas.')
# Termina el script.
exit(0)

# Recorre la lista de usuarios
for user in usuarios:
# Separa los valores del usuario usando como delimitador &quot;,&quot;, y asigna cada valor a la variable correspondiente.
user = user.split(',')
cn = user[0]
sn = user[1]
mail = user[2]
uid = user[3]
ssh = user[4]

#Anade el usuario.
conn.add(
    'uid={},ou=Personas,{}'.format(uid, dominio_base),
    object_class = 
    [
    'inetOrgPerson',
    'posixAccount', 
    'ldapPublicKey'
    ],
    attributes =
    {
    'cn': cn,
    'sn': sn,
    'mail': mail,
    'uid': uid,
    'uidNumber': str(uid_number),
    'gidNumber': str(gid),
    'homeDirectory': '{}{}'.format(home_dir,uid),
    'loginShell': shell,
    'sshPublicKey': str(ssh)
    })

if conn.result['description'] == 'entryAlreadyExists':
    print('El usuario {} ya existe.'.format(uid))

# Aumenta el contador para asignar un UID diferente a cada usuario (cada vez que ejecutemos el script debemos asegurarnos de ante mano que no existe dicho uid en el directorio ldap, o se solaparian los datos)
uid_number += 1

#Cierra la conexion.
conn.unbind()
</code></pre>
</div><p>Y vemos si funciona con el archivo anterior:</p>
<p><img src="./../images/ASO/ldap-csv/1.png" alt="image"></p>
<p>Comprobamos si se han añadido los usuarios indicados:</p>
<p><img src="./../images/ASO/ldap-csv/2.png" alt="image"></p>
<h3 id="configurar-el-sistema-para-que-sean-validos-los-usuarios-del-ldap"> Configurar el sistema para que sean válidos los usuarios del LDAP.</h3>
<p>Para ello, debemos modificar el archivo <code>/etc/ldap/ldap.conf</code> en el cliente y realizar los siguientes cambios:</p>
<div><pre><code>nano /etc/ldap/ldap.conf

BASE dc=olucas,dc=gonzalonazareno,dc=org
URI ldap://localhost
</code></pre>
</div><p>Además, debemos ajustar la configuración del NSS (Name Service Switch) para que el sistema pueda verificar los UID y GID en el directorio LDAP.</p>
<div><pre><code>nano /etc/nsswitch.conf

passwd:         files systemd ldap
group:          files systemd ldap
shadow:         files ldap
</code></pre>
</div><p>Para que esto funcione, es necesario instalar y configurar correctamente el siguiente paquete:</p>
<div><pre><code>apt install libnss-ldap
</code></pre>
</div><p>Ahora podemos iniciar sesión en la máquina con los usuarios que se encuentran en el directorio LDAP (por ejemplo, usaré el usuario &quot;impmon&quot; que creé en un ejercicio anterior).</p>
<p><img src="./../images/ASO/ldap-csv/3.png" alt="image"></p>
<h3 id="configurar-el-servicio-ssh-para-que-permita-acceder-a-los-usuarios-del-ldap-utilizando-las-claves-publicas-que-hay-alli-en-lugar-de-almacenarlas-en-ssh-authorized-keys-y-que-se-cree-el-directorio-home-al-vuelo"> Configurar el servicio ssh para que permita acceder a los usuarios del LDAP utilizando las claves públicas que hay allí, en lugar de almacenarlas en .ssh/authorized_keys y que se cree el directorio “home” al vuelo.</h3>
<p>Para que al acceder con dichos usuarios se cree el directorio home del usuario, debemos ejecutar lo siguiente:</p>
<div><pre><code>echo &quot;session    required        pam_mkhomedir.so&quot; &gt;&gt; /etc/pam.d/common-session
</code></pre>
</div><p>Ahora volvemos a entrar con el usuario anterior y vemos si se ha creado su directorio home:</p>
<p><img src="./../images/ASO/ldap-csv/3.png" alt="image"></p>
<p>Pasemos a configurar el sistema para que acepte el acceso por ssh a los usuarios que tengan sus claves públicas en el directorio de ldap.</p>
<p>Para comenzar, debemos crear un script que busque las claves públicas registradas para el usuario especificado. Debido a ciertos parámetros de seguridad de SSH, se requiere que el script se encuentre en un directorio propiedad de root y que tenga permisos específicos. Por lo tanto, he decidido crear el script en <code>/opt</code>:</p>
<div><pre><code>nano /opt/buscarclave.sh 

#!/bin/bash

ldapsearch -x -u -LLL -o ldif-wrap=no '(&amp;(objectClass=posixAccount)(uid='&quot;$1&quot;'))' 'sshPublicKey' | sed -n 's/^[ \t]*sshPublicKey::[ \t]*\(.*\)/\1/p' | base64 -d
</code></pre>
</div><p>Y cambiamos los permisos del script:</p>
<div><pre><code>chmod 755 /opt/buscarclave.sh 
</code></pre>
</div><p>Podemos ver que el script encuentra las claves de forma adecuada:</p>
<p><img src="./../images/ASO/ldap-csv/4.png" alt="image"></p>
<p>Ahora añadimos las siguientes líneas al fichero /etc/ssh/sshd_config:</p>
<div><pre><code>nano /etc/ssh/sshd_config

AuthorizedKeysCommand /opt/buscarclave.sh
AuthorizedKeysCommandUser nobody
</code></pre>
</div><p>Y reiniciamos el servicio de ssh para aplicar los cambios:</p>
<div><pre><code>systemctl restart sshd
</code></pre>
</div><p>Verifiquemos si es posible acceder a través de SSH usando los usuarios de LDAP que tengan sus claves en el directorio:</p>
<p><em>Comprobacion de mi usuario</em></p>
<p><img src="./../images/ASO/ldap-csv/5.png" alt="image"></p>
<p><em>Comprobación de usuario de Angel</em></p>
<p><img src="./../images/ASO/ldap-csv/6.png" alt="image"></p>
<p><img src="./../images/ASO/ldap-csv/7.png" alt="image"></p>
<p><em>Comprobación del usuario de Alfonso</em></p>
<p><img src="./../images/ASO/ldap-csv/8.png" alt="image"></p>
<p><img src="./../images/ASO/ldap-csv/9.png" alt="image"></p>
<p>¡Gracias!</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Instalación y configuración inicial de OpenLDAP</title>
    <id>https://github.com/oscarlucas22/practicas/ldap/</id>
    <link href="https://github.com/oscarlucas22/practicas/ldap/"/>
    <updated>2023-03-07T17:02:54.456Z</updated>
    <content type="html"><![CDATA[<h1 id="instalacion-y-configuracion-inicial-de-openldap"> Instalación y configuración inicial de OpenLDAP</h1>
<p><strong>Realiza la instalación y configuración básica de OpenLDAP en alfa, utilizando como base el nombre DNS asignado. Deberás crear un usuario llamado prueba y configurar una máquina cliente basada en Debian y Rocky para que pueda validarse en servidor ldap configurado anteriormente con el usuario prueba.</strong></p>
<p><font color="#FFFF00"><strong>Paso 1</strong></font> Configuración de OpenLDAP en el servidor: Instalación y configuración de OpenLDAP.Instalación y configuración de OpenLDAP en el Servidor</p>
<p>El FQDN de mi alfa es este:</p>
<div><pre><code>hostname -f 

alfa.olucas.gonzalonazareno.org
</code></pre>
</div><p>Antes de continuar, debemos instalar los paquetes &quot;slapd&quot; y &quot;ldap-utils&quot; de OpenLDAP. &quot;Slapd&quot; es el paquete central de OpenLDAP, mientras que &quot;ldap-utils&quot; ofrece herramientas de línea de comandos para manejar el servidor OpenLDAP.</p>
<div><pre><code>apt install slapd ldap-utils
</code></pre>
</div><p>Luego de esto, se requerirá que configure la contraseña del administrador de OpenLDAP.</p>
<p>Introduce tu contraseña y selecciona ‘OK‘, luego pulsa‘ENTER’.</p>
<p><img src="./../images/ASO/ldap/1.png" alt="image"></p>
<p>Repite tu contraseña y selecciona‘OK’, y pulsa‘ENTER’ de nuevo. Y la instalación de OpenLDAP se habrá completado.</p>
<p><img src="./../images/ASO/ldap/2.png" alt="image"></p>
<p>Durante la instalación nos pedirá la contraseña que usará el usuario administrador de LDAP, en mi caso la he puesto como “root”:</p>
<p>Una vez instalado, podemos comprobar que nos ha abierto el puerto TCP 389, que es por el que estará escuchando las peticiones:</p>
<div><pre><code>netstat -tlnp | egrep slap
</code></pre>
</div><p><img src="./../images/ASO/ldap/3.png" alt="image"></p>
<p>Una vez que hemos verificado que OpenLDAP está activo y funcionando, podemos proceder a instalar el paquete de herramientas necesario para nuestro trabajo.</p>
<div><pre><code>apt install ldap-utils
</code></pre>
</div><p>Ahora podemos utilizar el comando &quot;ldapsearch&quot; con las credenciales que proporcionamos durante la instalación (si deseamos realizar la búsqueda como administrador) para acceder al contenido de nuestro directorio.</p>
<div><pre><code>ldapsearch -x -D &quot;cn=admin,dc=olucas,dc=gonzalonazareno,dc=org&quot; -b &quot;dc=olucas,dc=gonzalonazareno,dc=org&quot; -W
</code></pre>
</div><p><img src="./../images/ASO/ldap/4.png" alt="image"></p>
<p>Con esto, hemos concluido la instalación de OpenLDAP. Sin embargo, para mantener una mayor organización de los objetos que creemos, vamos a crear un par de objetos llamados &quot;Unidades Organizativas&quot;. Para lograr esto, crearemos un archivo .ldif con la siguiente información:</p>
<div><pre><code>nano UdsOrg.ldif
</code></pre>
</div><hr>
<div><pre><code>dn: ou=Personas,dc=olucas,dc=gonzalonazareno,dc=org
objectClass: top
objectClass: organizationalUnit
ou: Personas

dn: ou=Grupos,dc=olucas,dc=gonzalonazareno,dc=org
objectClass: top
objectClass: organizationalUnit
ou: Grupos
</code></pre>
</div><p>Una vez que hemos preparado el archivo, podemos agregarlo a nuestro directorio con el siguiente comando:</p>
<div><pre><code>ldapadd -x -D &quot;cn=admin,dc=olucas,dc=gonzalonazareno,dc=org&quot; -f UdsOrg.ldif -W
</code></pre>
</div><p><img src="./../images/ASO/ldap/5.png" alt="image"></p>
<p>Para eliminar las unidades organizativas, utilizaremos el siguiente comando:</p>
<div><pre><code>ldapdelete -x -D 'cn=admin,dc=olucas,dc=gonzalonazareno,dc=org' -W ou=Personas,dc=olucas,dc=gonzalonazareno,dc=org
ldapdelete -x -D 'cn=admin,dc=olucas,dc=gonzalonazareno,dc=org' -W ou=Grupos,dc=olucas,dc=gonzalonazareno,dc=org
</code></pre>
</div><p>Podemos comprobar que, efectivamente, se han producido los cambios:</p>
<div><pre><code>ldapsearch -x -b dc=olucas,dc=gonzalonazareno,dc=org
</code></pre>
</div><p><img src="./../images/ASO/ldap/6.png" alt="image"></p>
<p>También crearemos un grupo llamado grupos:</p>
<div><pre><code>nano grupos.ldif
</code></pre>
</div><hr>
<div><pre><code>dn: cn=prueba,ou=Grupos,dc=olucas,dc=gonzalonazareno,dc=org
objectClass: top
objectClass: posixGroup
gidNumber: 2001
cn: prueba
</code></pre>
</div><p>Una vez que ya tenemos el fichero, lo añadiremos a nuestro directorio:</p>
<div><pre><code>ldapadd -x -D 'cn=admin,dc=olucas,dc=gonzalonazareno,dc=org' -W -f grupos.ldif
</code></pre>
</div><p><img src="./../images/ASO/ldap/7.png" alt="image"></p>
<p>Como podemos ver, se ha creado correctamente:</p>
<div><pre><code>ldapsearch -x -b dc=olucas,dc=gonzalonazareno,dc=org
</code></pre>
</div><p><img src="./../images/ASO/ldap/8.png" alt="image"></p>
<p>Para borrarlo, usaremos el siguiente comando:</p>
<div><pre><code>ldapdelete -x -D 'cn=admin,dc=olucas,dc=gonzalonazareno,dc=org' -W cn=prueba,ou=Group,dc=olucas,dc=gonzalonazareno,dc=org
</code></pre>
</div><p>Generaremos una contraseña cifrada para el usuario de prueba. Es necesario cifrar la contraseña del usuario con el comando &quot;slappasswd&quot;, que producirá un resultado para copiar en el campo &quot;userPassword&quot;.</p>
<div><pre><code>slappasswd
</code></pre>
</div><p><img src="./../images/ASO/ldap/9.png" alt="image"></p>
<p>Tras esto, crearé un usuario llamado prueba:</p>
<div><pre><code>nano usuarios.ldif
</code></pre>
</div><hr>
<div><pre><code>dn: uid=prueba,ou=Personas,dc=olucas,dc=gonzalonazareno,dc=org
objectClass: top
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: person
cn: prueba
uid: prueba
uidNumber: 2001
gidNumber: 2001
homeDirectory: /home/nfs/prueba
loginShell: /bin/bash
userPassword: {SSHA}1unJBHIQ1DYG/qNBKwhqpAMN5Lq2Bobj
sn: prueba
givenName: prueba
</code></pre>
</div><p>Una vez que ya tenemos el fichero, lo añadiremos a nuestro directorio:</p>
<div><pre><code>ldapadd -x -D 'cn=admin,dc=olucas,dc=gonzalonazareno,dc=org' -W -f usuarios.ldif
</code></pre>
</div><p><img src="./../images/ASO/ldap/10.png" alt="image"></p>
<p>Podemos comprobar que se ha añadido el usuario prueba al grupo prueba:</p>
<div><pre><code>ldapsearch -x -b dc=olucas,dc=gonzalonazareno,dc=org
</code></pre>
</div><p><img src="./../images/ASO/ldap/11.png" alt="image"></p>
<p>Para borrar el usuario prueba, usaremos el siguiente comando:</p>
<div><pre><code>ldapdelete -x -D 'cn=admin,dc=olucas,dc=gonzalonazareno,dc=org' -W uid=prueba,ou=People,dc=olucas,dc=gonzalonazareno,dc=org
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 2</strong></font> Configuración de NFS en el Servidor</p>
<p>El usuario no será capaz de acceder a su cuenta debido a la ausencia de un directorio de inicio. Para crearlo, ejecutaremos el siguiente comando:</p>
<div><pre><code>mkdir /home/nfs
mkdir /home/nfs/prueba
chown 2001:2001 /home/nfs/prueba
</code></pre>
</div><p>Ahora, modificaremos el archivo &quot;/etc/exports&quot; para que el usuario de prueba pueda acceder a su directorio de inicio.</p>
<div><pre><code>nano /etc/exports

/home/nfs       *(rw,fsid=0,subtree_check)
</code></pre>
</div><p>Después de modificar el archivo, reiniciaremos el servicio &quot;nfs-kernel-server&quot;.</p>
<div><pre><code>/etc/init.d/nfs-kernel-server restart
</code></pre>
</div><p><font color="#FFFF00"><strong>Paso 3</strong></font> Instalar Name Service Switch (NSS), Pluggable Authentication Module (PAM) y Name Service Cache Daemon (NSCD) en el servidor.</p>
<p>En el servidor LDAP, instalamos paquetes que permiten que el sistema realice la resolución de nombres de usuarios (UID) y grupos (GID), acceder a información en un directorio LDAP, iniciar sesión y almacenar en caché la resolución de nombres.</p>
<div><pre><code>apt-get install libpam-ldapd nscd libnss-ldap
</code></pre>
</div><p>Lo configuramos en mi caso de la siguiente forma:</p>
<p><img src="./../images/ASO/ldap/12.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/13.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/14.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/15.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/16.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/17.png" alt="image"></p>
<p>Por último, modificaremos el archivo &quot;/etc/nsswitch.conf&quot; para que el sistema haga uso del servicio LDAP para la resolución de nombres.</p>
<div><pre><code>nano /etc/nsswitch.conf
</code></pre>
</div><hr>
<div><pre><code>passwd:         files ldap
group:          files ldap
shadow:         files ldap
gshadow:        files ldap

hosts:          files dns mymachines
networks:       files

protocols:      db files
services:       db files
ethers:         db files
rpc:            db files

netgroup:       nis
</code></pre>
</div><p>Veremos el uuid del usuario prueba:</p>
<div><pre><code>id prueba
</code></pre>
</div><p><img src="./../images/ASO/ldap/18.png" alt="image"></p>
<p>Para terminar, nos loguearemos con el usuario prueba:</p>
<div><pre><code>login prueba
</code></pre>
</div><p><img src="./../images/ASO/ldap/19.png" alt="image"></p>
<p><font color="#FFFF00"><strong>Paso 4</strong></font> Configuración del Cliente Ubuntu</p>
<p>Para configurar el cliente Ubuntu, el primer paso es instalar el paquete de herramientas de LDAP.</p>
<div><pre><code>apt install ldap-utils
</code></pre>
</div><p>Ahora, vamos a crear un fichero de configuración para el cliente:</p>
<div><pre><code>nano /etc/ldap/ldap.conf
</code></pre>
</div><hr>
<div><pre><code>BASE dc=olucas,dc=gonzalonazareno,dc=org
URI ldap://alfa.olucas.gonzalonazareno.org
</code></pre>
</div><p>Una vez que ya tenemos el fichero de configuración, podemos comprobar que funciona correctamente:</p>
<div><pre><code>ldapsearch -x -b &quot;dc=olucas,dc=gonzalonazareno,dc=org&quot;
</code></pre>
</div><p><img src="./../images/ASO/ldap/20.png" alt="image"></p>
<p>Como podemos ver, funciona correctamente.</p>
<p>Comprobación de la autentificación en el cliente Ubuntu usando el usuario prueba y el siguiente comando.</p>
<div><pre><code>ldapwhoami -x -D &quot;uid=prueba,ou=Personas,dc=olucas,dc=gonzalonazareno,dc=org&quot; -W
</code></pre>
</div><p><img src="./../images/ASO/ldap/21.png" alt="image"></p>
<p>Instalamos los paquetes necesarios (libnss-ldap, libpam-ldapd y nscd):</p>
<div><pre><code>apt install -y libnss-ldap libpam-ldapd nscd
</code></pre>
</div><p><img src="./../images/ASO/ldap/22.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/23.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/25.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/26.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/27.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/28.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/29.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/30.png" alt="image"></p>
<p>Ahora configuraremos el cliente Ubuntu para conectarse al servidor LDAP en lugar de usar los datos locales del host (que en este caso es el cliente Ubuntu).</p>
<p>Vamos a cambiar la configuración en el archivo /etc/nsswitch.conf para que el sistema se apoye en el servicio LDAP para resolver nombres.</p>
<div><pre><code>nano /etc/nsswitch.conf
</code></pre>
</div><hr>
<div><pre><code>passwd:         files systemd ldap
group:          files systemd ldap
shadow:         files ldap
gshadow:        files ldap

hosts:          files dns
networks:       files

protocols:      db files
services:       db files
ethers:         db files
rpc:            db files

netgroup:       nis
</code></pre>
</div><p>Después de esto, reiniciaremos el servicio NSCD y será posible iniciar sesión en el servidor LDAP desde el cliente Ubuntu.</p>
<div><pre><code>service nscd restart
</code></pre>
</div><p>Para poder acceder a la carpeta de inicio del usuario prueba, necesitamos montarla usando NFS.</p>
<p>Instalamos el paquete para el cliente NFS:</p>
<div><pre><code>apt install -y nfs-common
</code></pre>
</div><p>Activamos el servicio:</p>
<div><pre><code>systemctl start nfs-client.target &amp; systemctl enable nfs-client.target
</code></pre>
</div><p><img src="./../images/ASO/ldap/31.png" alt="image"></p>
<p>Creamos el directorio de montaje:</p>
<div><pre><code>mkdir /home/nfs
mkdir /home/nfs/prueba
chown 2001:2001 /home/nfs/prueba
</code></pre>
</div><p>Para solucionar el problema de no visualizar los cambios en la carpeta de inicio del usuario prueba, debemos montarla a través de NFS. De esta manera, podremos acceder a los cambios realizados desde cualquier cliente conectado.</p>
<p>Cargamos el módulo:</p>
<div><pre><code>modprobe nfs
</code></pre>
</div><p>Ejecutamos lo siguiente para que se cargue el modulo automáticamente:</p>
<div><pre><code>echo NFS | tee -a /etc/modules
</code></pre>
</div><p>Lo montamos mediante systemd:</p>
<div><pre><code>nano /etc/systemd/system/home-nfs.mount
</code></pre>
</div><p>Añadimos las siguientes líneas:</p>
<div><pre><code>[Unit]
Description=script de montaje NFS
Requires=network-online.target
After=network-online.target
[Mount]
What=192.168.0.1:/home/nfs
Where=/home/nfs
Options=_netdev,auto
Type=nfs
[Install]
WantedBy=multi-user.target
</code></pre>
</div><p>Reiniciamos el servicio:</p>
<div><pre><code>systemctl daemon-reload
systemctl start home-nfs.mount
systemctl enable home-nfs.mount
</code></pre>
</div><p><img src="./../images/ASO/ldap/32.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/33.png" alt="image"></p>
<p><img src="./../images/ASO/ldap/34.png" alt="image"></p>
<p>Vamos a comprobar que funciona correctamente:</p>
<div><pre><code>login prueba
</code></pre>
</div><p><img src="./../images/ASO/ldap/35.png" alt="image"></p>
<p>Por último, verificaremos que las modificaciones realizadas en la carpeta de inicio del usuario prueba se reflejan en el servidor.</p>
<p><img src="./../images/ASO/ldap/36.png" alt="image"></p>
<p><font color="#FFFF00"><strong>Paso 5</strong></font> Configuración del Cliente Rocky</p>
<p>Antes de configurar el cliente Rocky, es necesario instalar el paquete de herramientas de LDAP.</p>
<div><pre><code>dnf install openldap-clients
</code></pre>
</div><p>Modificación del archivo de configuración de PAM (Pluggable Authentication Modules) en el cliente Rocky, agregando la siguiente línea en el archivo /etc/pam.d/common-auth.</p>
<div><pre><code>auth sufficient pam_ldap.so 
</code></pre>
</div><p>Ahora, vamos a crear un fichero de configuración para el cliente:</p>
<div><pre><code>nano /etc/openldap/ldap.conf

BASE dc=olucas,dc=gonzalonazareno,dc=org
URI ldap://alfa.olucas.gonzalonazareno.org
</code></pre>
</div><p>Finalmente, para que el usuario prueba tenga acceso al directorio de inicio, debemos modificar el archivo de configuración de PAM, /etc/pam.d/common-session, para permitir la autenticación de usuarios mediante LDAP, agregando la siguiente línea:</p>
<div><pre><code>session sufficient pam_mkhomedir.so umask=0022 skel=/etc/skel/
</code></pre>
</div><p>Para verificar que la configuración funciona correctamente, podemos ejecutar el siguiente comando:</p>
<div><pre><code>ldapsearch -x -b &quot;dc=olucas,dc=gonzalonazareno,dc=org&quot;
</code></pre>
</div><p><img src="./../images/ASO/ldap/37.png" alt="image"></p>
<p>Como podemos ver, funciona correctamente.</p>
<p>Vamos a verificar si la configuración funciona correctamente en el cliente Rocky. Para hacer esto, usaremos un comando que nos permita conectarnos al servidor LDAP con el usuario de prueba y verificaremos la autenticación.</p>
<div><pre><code>ldapwhoami -x -D &quot;uid=prueba,ou=Personas,dc=olucas,dc=gonzalonazareno,dc=org&quot; -W
</code></pre>
</div><p><img src="./../images/ASO/ldap/38.png" alt="image"></p>
<p>Como podemos ver, funciona correctamente.</p>
<p>Instalamos los paquetes necesarios para realizar el login con LDAP:</p>
<div><pre><code>dnf install -y sssd sssd-ldap
</code></pre>
</div><p>Incluimos las siguientes líneas en el archivo de configuración de SSSD (/etc/sssd/sssd.conf).</p>
<div><pre><code>[domain/default]
id_provider = ldap
autofs_provider = ldap
auth_provider = ldap
chpass_provider = ldap
ldap_uri = ldap://alfa.olucas.gonzalonazareno.org
ldap_search_base = dc=olucas,dc=gonzalonazareno,dc=org
ldap_id_use_start_tls = True
ldap_tls_cacertdir = /etc/openldap/cacerts
cache_credentials = True
ldap_tls_reqcert = allow

[sssd]
services = nss, pam, autofs
domains = default

[nss]
homedir_substring = /home/nfs
</code></pre>
</div><p>Ahora, reiniciamos los servicios y los habilitamos:</p>
<div><pre><code>systemctl restart sssd
systemctl enable sssd
</code></pre>
</div><p>Antes de continuar, creamos una carpeta en la que montaremos el servidor NFS en el cliente. Esto lo hacemos con el siguiente comando:</p>
<div><pre><code>mkdir /home/nfs
mkdir /home/nfs/prueba
chown 2001:2001 /home/nfs/prueba
</code></pre>
</div><p>Montamos el directorio de inicio del usuario prueba:</p>
<div><pre><code>nano /etc/systemd/system/home-nfs.mount
</code></pre>
</div><hr>
<div><pre><code>[Unit]
Description=script de montaje NFS
Requires=NetworkManager.service
After=NetworkManager.service
[Mount]
What=172.16.0.1:/home/nfs
Where=/home/nfs
Options=_netdev,auto
Type=nfs
[Install]
WantedBy=multi-user.target
</code></pre>
</div><p>Reiniamos el servicio:</p>
<div><pre><code>systemctl daemon-reload
systemctl start mnt-nfs.mount
</code></pre>
</div><p>image</p>
<p>image</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Movimiento de datos</title>
    <id>https://github.com/oscarlucas22/practicas/movdatos/</id>
    <link href="https://github.com/oscarlucas22/practicas/movdatos/"/>
    <updated>2023-03-07T17:02:54.459Z</updated>
    <content type="html"><![CDATA[<h1 id="movimiento-de-datos"> Movimiento de datos</h1>
<h3 id="_1-realiza-una-exportacion-del-esquema-de-scott-usando-oracle-data-pump-con-las-siguientes-condiciones"> 1. Realiza una exportación del esquema de SCOTT usando Oracle Data Pump con las siguientes condiciones:</h3>
<ul>
<li><strong>Exporta tanto la estructura de las tablas como los datos de las mismas.</strong></li>
</ul>
<p>Para almacenar el archivo de exportación y el archivo de registro, creamos un directorio donde se van a almacenar todos los archivos de esportación.</p>
<div><pre><code>mkdir /home/oracle/dir
</code></pre>
</div><p>Accedemos a la base de datos para crear un directorio mediante la ejecución del siguiente comando, al que le asignaremos los permisos necesarios:</p>
<div><pre><code>create directory dmp_dir as '/home/oracle/dir';
grant read, write on directory dmp_dir to SCOTT;
</code></pre>
</div><p>Y le daremos tambien permisos para que pueda exportar todo los datos:</p>
<div><pre><code>grant datapump_exp_full_database to SCOTT;
</code></pre>
</div><ul>
<li><strong>Excluye la tabla BONUS y los departamentos con menos de dos empleados.</strong></li>
</ul>
<hr>
<div><pre><code>expdp scott/tiger DIRECTORY=dmp_dir DUMPFILE=scott.dmp LOGFILE=scott.log SCHEMAS=SCOTT EXCLUDE=TABLE:&quot;IN('BONUS')&quot; QUERY=DEPT:'&quot;where deptno in (select deptno from emp group by deptno having count(*) &gt; 2)&quot;'
</code></pre>
</div><p><img src="./../images/ABD/movdatos/2-1.png" alt="image"></p>
<ul>
<li><strong>Realiza una estimación previa del tamaño necesario para el fichero de exportación.</strong></li>
</ul>
<hr>
<div><pre><code>expdp scott/tiger DIRECTORY=dmp_dir CONTENT=ALL LOGFILE=exportado.log SCHEMAS=SCOTT ESTIMATE_ONLY=y
</code></pre>
</div><p><img src="./../images/ABD/movdatos/1-1.png" alt="image"></p>
<ul>
<li>
<p><strong>Programa la operación para dentro de 2 minutos.</strong></p>
</li>
<li>
<p><strong>Genera un archivo de log en el directorio raíz.</strong></p>
</li>
</ul>
<p>Como hemos visto anteriormente la opción de &quot;LOGFILE&quot; hemos expecificado el nombre del fichero de log que se guardara en el directorio que hemos expecificado en la opcion &quot;DIRECTORY&quot;, que sera el directorio raiz.</p>
<p>Contenido del fichero de log de la estimación:</p>
<p><img src="./../images/ABD/movdatos/4-1.png" alt="image"></p>
<p>Contenido del fichero de log de la exportación:</p>
<p><img src="./../images/ABD/movdatos/5-1.png" alt="image"></p>
<h3 id="_2-importa-el-fichero-obtenido-anteriormente-usando-oracle-data-pump-pero-en-un-usuario-distinto-de-la-misma-base-de-datos"> 2. Importa el fichero obtenido anteriormente usando Oracle Data Pump pero en un usuario distinto de la misma base de datos.</h3>
<p>Voy a establecer el perfil del usuario objetivo en la base de datos, asignándole los permisos correspondientes.</p>
<div><pre><code>create user importar identified by passwd;
alter user importar account unlock;
grant connect, resource to importar;
grant unlimited tablespace to importar;
alter user importar default tablespace users;
alter user importar temporary tablespace temp;
grant read, write on directory dmp_dir to importar;
grant imp_full_database to importar;
</code></pre>
</div><p>Utilizaremos el comando <code>impdp</code> para llevar a cabo la importación.</p>
<div><pre><code>impdp importar/passwd DIRECTORY=dmp_dir DUMPFILE=scott.dmp LOGFILE=ScottImportado.log
</code></pre>
</div><p><img src="./../images/ABD/movdatos/2-2.png" alt="image"></p>
<p>Contenido del fichero de log de la importación:</p>
<p><img src="./../images/ABD/movdatos/3-2.png" alt="image"></p>
<p>Vamos a hacer una prueba ejecutando una consulta en el esquema de importación para verificar la correcta importación de los datos.</p>
<div><pre><code>select * from importar.dept;
</code></pre>
</div><p><img src="./../images/ABD/movdatos/4-2.png" alt="image"></p>
<p>Verificamos que los datos de la tabla BONUS no han sido importados.:</p>
<div><pre><code>select * from importar.bonus;
</code></pre>
</div><hr>
<div><pre><code>select * from scott.bonus;
</code></pre>
</div><hr>
<div><pre><code>select * from bonus;
</code></pre>
</div><p><img src="./../images/ABD/movdatos/5-2.png" alt="image"></p>
<h3 id="_3-realiza-una-exportacion-de-la-estructura-de-todas-las-tablas-de-la-base-de-datos-usando-el-comando-expdp-de-oracle-data-pump-probando-al-menos-cinco-de-las-posibles-opciones-que-ofrece-dicho-comando-y-documentandolas-adecuadamente"> 3. Realiza una exportación de la estructura de todas las tablas de la base de datos usando el comando expdp de Oracle Data Pump probando al menos cinco de las posibles opciones que ofrece dicho comando y documentándolas adecuadamente.</h3>
<p>Oracle Data Pump cuenta con el comando <code>expdp</code> que permite exportar objetos y datos en una base de datos Oracle. A continuación, presentaré cinco de las opciones disponibles en expdp que se pueden emplear:</p>
<ul>
<li>
<p><strong>SCHEMAS</strong>: Con esta opción, se especifican los esquemas que se van a exportar.</p>
</li>
<li>
<p><strong>DIRECTORY</strong>: Esta opción especifica el directorio de destino para el archivo de exportación.</p>
</li>
<li>
<p><strong>LOGFILE</strong>: Con esta opción, se especifica el archivo de registro para la exportación.</p>
</li>
<li>
<p><strong>EXCLUDE</strong>: Con esta opción, se especifica qué objetos se deben excluir de la exportación.</p>
</li>
<li>
<p><strong>QUERY</strong>: Esta opción nos permite especificar una consulta SQL para seleccionar los datos que queremos exportar</p>
</li>
</ul>
<hr>
<p>Supongamos que queremos exportar los datos y metadatos del esquema SCOTT y guardar el archivo de exportación en el directorio que cree en el ejer 1 (dmp_dir = /home/oracle/dir). Además, queremos incluir solo los salarios de la tabla EMP que son mayores que &quot;1500&quot;, y excluir la tabla BONUS. También queremos guardar los mensajes de registro en el archivo /home/oracle/dir/logfile.log. Podemos ejecutar el siguiente comando:</p>
<div><pre><code>expdp scott/tiger SCHEMAS=SCOTT DIRECTORY=dmp_dir DUMPFILE=scott_export.dmp LOGFILE=logfile.log EXCLUDE=TABLE:&quot;IN('BONUS')&quot; QUERY=EMP:'&quot;where sal &gt; 1500&quot;'
</code></pre>
</div><p><img src="./../images/ABD/movdatos/1-3.png" alt="image"></p>
<p>Veremos el contenido de &quot;logfile.log&quot;</p>
<p><img src="./../images/ABD/movdatos/2-3.png" alt="image"></p>
<p>Para ver el funcionamiento de este crearé un nuevo usuario al que le importaré la expotación en el que hemos hecho:</p>
<div><pre><code>create user ejer3 identified by root;
alter user ejer3 account unlock;
grant connect, resource to ejer3;
grant unlimited tablespace to ejer3;
alter user ejer3 default tablespace users;
alter user ejer3 temporary tablespace temp;
grant read, write on directory dmp_dir to ejer3;
grant imp_full_database to ejer3;
</code></pre>
</div><hr>
<div><pre><code>impdp ejer3/root DIRECTORY=dmp_dir DUMPFILE=scott_export.dmp LOGFILE=logimport.log SCHEMAS=SCOTT REMAP_SCHEMA=SCOTT:ejer3
</code></pre>
</div><p><img src="./../images/ABD/movdatos/3-3.png" alt="image"></p>
<p>Comprobación:</p>
<p><img src="./../images/ABD/movdatos/4-3.png" alt="image"></p>
<h3 id="_4-intenta-realizar-operaciones-similares-de-importacion-y-exportacion-con-las-herramientas-proporcionadas-con-mysql-desde-linea-de-comandos-documentando-el-proceso"> 4. Intenta realizar operaciones similares de importación y exportación con las herramientas proporcionadas con MySQL desde línea de comandos, documentando el proceso.</h3>
<p>Para exportar completamente una base de datos, se puede emplear el siguiente comando:</p>
<div><pre><code>mysqldump -u scott -p scott &gt; ScottExportado.sql
</code></pre>
</div><p><img src="./../images/ABD/movdatos/1-4.png" alt="image"></p>
<p>A continuación muestro el contenido del archivo <code>ScottExportado.sql</code>:</p>
<p><img src="./../images/ABD/movdatos/2-4.png" alt="image"></p>
<p><img src="./../images/ABD/movdatos/3-4.png" alt="image"></p>
<p><img src="./../images/ABD/movdatos/4-4.png" alt="image"></p>
<p>Para asegurarnos de que la importación ha sido realizada con exito vamos a crear un usuario nuevo y una base de datos en MySQL. El usuario se llamará <code>scottimportado</code> y tendrá los permisos necesarios para importar datos a la base de datos <code>scott</code>.</p>
<div><pre><code>create database scottimportado;
create user scottimportado;
grant all privileges on *.* to 'scottimportado'@'localhost' identified by 'passwd' with grant option;
flush privileges;
</code></pre>
</div><p><img src="./../images/ABD/movdatos/7-4.png" alt="image"></p>
<p>Para realizar la importació podemos ejecutar el comando siguiente:</p>
<div><pre><code>mysql -u scottimportado -p scottimportado &lt; ScottExportado.sql
</code></pre>
</div><p><img src="./../images/ABD/movdatos/8-4.png" alt="image"></p>
<p>Vamos a comprobar que se han importado correctamente los datos:</p>
<div><pre><code>select * from dept;
</code></pre>
</div><p><img src="./../images/ABD/movdatos/9-4.png" alt="image"></p>
<h3 id="_5-intenta-realizar-operaciones-similares-de-importacion-y-exportacion-con-las-herramientas-proporcionadas-con-postgres-desde-linea-de-comandos-documentando-el-proceso"> 5. Intenta realizar operaciones similares de importación y exportación con las herramientas proporcionadas con Postgres desde línea de comandos, documentando el proceso.</h3>
<p>Para llevar a cabo una exportación completa de una base de datos, ejecutaremos el siguiente comando:</p>
<div><pre><code>pg_dump -U postgres -d scott &gt; /var/lib/postgresql/ejer5/ScottExportado.sql
</code></pre>
</div><p><img src="./../images/ABD/movdatos/1-5.png" alt="image"></p>
<p>Este comando creará un fichero llamado <code>ScottExportado.sql</code> que contiene toda la estructura y los datos de la base de datos.</p>
<p>Vamos a ver el contenido del fichero <code>ScottExportado.sql</code>:</p>
<p><img src="./../images/ABD/movdatos/2-5.png" alt="image"></p>
<p><img src="./../images/ABD/movdatos/3-5.png" alt="image"></p>
<p><img src="./../images/ABD/movdatos/4-5.png" alt="image"></p>
<p>Para realizar la importación lo haremos de la siguiente manera:</p>
<p>Crearemos una nueva base de datos llamada <code>scottimportado</code>.</p>
<div><pre><code>create database scottimportado with owner postgres;
grant all privileges on database scottimportado to postgres;
</code></pre>
</div><p><img src="./../images/ABD/movdatos/7-5.png" alt="image"></p>
<p>Importamos la base de datos:</p>
<div><pre><code>psql -U postgres -d scottimportado &lt; /var/lib/postgresql/ejer5/ScottExportado.sql
</code></pre>
</div><p><img src="./../images/ABD/movdatos/8-5.png" alt="image"></p>
<p>Para verificar que la importación de datos se ha realizado correctamente, vamos a realizar una consulta:</p>
<div><pre><code>select * from dept;
</code></pre>
</div><hr>
<div><pre><code>select * from emp;
</code></pre>
</div><hr>
<div><pre><code>select * from salgrade;
</code></pre>
</div><p><img src="./../images/ABD/movdatos/9-5.png" alt="image"></p>
<h3 id="_6-exporta-los-documentos-de-una-coleccion-de-mongodb-que-cumplan-una-determinada-condicion-e-importalos-en-otra-base-de-datos"> 6. Exporta los documentos de una colección de MongoDB que cumplan una determinada condición e impórtalos en otra base de datos.</h3>
<p>Vamos a exportar los datos de una colección llamada <code>prueba1</code> en la base de datos <code>Prueba</code>, y solo vamos a exportar todos aquellos documentos que presenten un valor de salario superior a 3000. Para llevar a cabo esta tarea, podemos emplear el siguiente comando:</p>
<p>Esta base de datos es la que he usado:</p>
<div><pre><code>mongosh -u olucas -p root --authenticationDatabase admin
use Prueba
</code></pre>
</div><hr>
<div><pre><code>db.createCollection(&quot;prueba1&quot;)
</code></pre>
</div><hr>
<div><pre><code>db.prueba1.insertMany( [
{ nombre: &quot;Angel&quot;, sal: 2000 },
{ nombre: &quot;Paco&quot;, sal: 3000 },
{ nombre: &quot;Oscar&quot;, sal: 4000 },
{ nombre: &quot;Alfonso&quot;, sal: 4000 },
{ nombre: &quot;Juan&quot;, sal: 5000 },
{ nombre: &quot;Camilo&quot;, sal: 3000 },
{ nombre: &quot;Lunay&quot;, sal: 4000 },
{ nombre: &quot;Salomon&quot;, sal: 2000 },
{ nombre: &quot;Roberto&quot;, sal: 2000 },
{ nombre: &quot;Candela&quot;, sal: 2000 },
{ nombre: &quot;Miriam&quot;, sal: 2000 },
{ nombre: &quot;Carla&quot;, sal: 2000 },
{ nombre: &quot;Viginia&quot;, sal: 4000 },
{ nombre: &quot;Antonio&quot;, sal: 5000 },
{ nombre: &quot;Ivan&quot;, sal: 2000 },
{ nombre: &quot;Alberto&quot;, sal: 3000 },
{ nombre: &quot;Alba&quot;, sal: 3000 },
{ nombre: &quot;Marta&quot;, sal: 2000 },
{ nombre: &quot;Lucia&quot;, sal: 3000 },
{ nombre: &quot;Maria&quot;, sal: 2000 }
] )
</code></pre>
</div><p>Comando <code>mongoexport</code>:</p>
<div><pre><code>mongoexport -u olucas -p root --db Prueba --collection prueba1 --query '{ &quot;sal&quot;: { &quot;$gt&quot;: 3000 } }' --out exportacion.json --authenticationDatabase admin
</code></pre>
</div><p><img src="./../images/ABD/movdatos/1-6.png" alt="image"></p>
<p>Ahora mostraré el contenido del archivo <code>exportacion.json</code>:</p>
<p><img src="./../images/ABD/movdatos/2-6.png" alt="image"></p>
<p>Para importar los datos previamente exportados en otra base de datos, puedes recurrir al uso del comando <code>mongoimport</code>. Importaremos los datos en la base de datos denominada <code>Prueba2</code>, puedes ejecutar el siguiente comando:</p>
<p>Crearé la base de datos <code>Prueba2</code>:</p>
<div><pre><code>mongosh -u olucas -p root --authenticationDatabase admin
use Prueba2
</code></pre>
</div><hr>
<div><pre><code>mongoimport -u olucas -p root --db Prueba2 --collection prueba2 --type json --file exportacion.json --authenticationDatabase admin
</code></pre>
</div><p><img src="./../images/ABD/movdatos/3-6.png" alt="image"></p>
<p>Mostraré el contenido de la colección <code>prueba2</code>:</p>
<div><pre><code>mongosh -u olucas -p root --authenticationDatabase admin
use Prueba2
db.prueba2.find()
</code></pre>
</div><p><img src="./../images/ABD/movdatos/4-6.png" alt="image"></p>
<h3 id="_7-sqlloader-es-una-herramienta-que-sirve-para-cargar-grandes-volumenes-de-datos-en-una-instancia-de-oracle-exportad-los-datos-de-una-base-de-datos-completa-desde-postgres-a-texto-plano-con-delimitadores-y-emplead-sqlloader-para-realizar-el-proceso-de-carga-de-dichos-datos-a-una-instancia-oracle-debeis-documentar-todo-el-proceso-explicando-los-distintos-ficheros-de-configuracion-y-de-log-que-tiene-sql-loader"> 7. SQL<em>Loader es una herramienta que sirve para cargar grandes volúmenes de datos en una instancia de ORACLE. Exportad los datos de una base de datos completa desde Postgres a texto plano con delimitadores y emplead SQL</em>Loader para realizar el proceso de carga de dichos datos a una instancia ORACLE. Debéis documentar todo el proceso, explicando los distintos ficheros de configuración y de log que tiene SQL*Loader.</h3>
<p>Si se necesita exportar los datos de una base de datos completa de Postgres en un archivo de texto plano con delimitadores, es posible utilizar el siguiente comando (en este ejemplo he elegido las tablas <code>dept</code> y <code>salgrade</code> del esquema <code>scott</code>):</p>
<div><pre><code>COPY dept TO '/var/lib/postgresql/scott/dept.csv' DELIMITERS',';
COPY salgrade TO '/var/lib/postgresql/scott/salgrade.csv' DELIMITERS',';
</code></pre>
</div><p><img src="./../images/ABD/movdatos/1-7.png" alt="image"></p>
<p>Una vez obtenido el archivo de texto plano que contiene los datos, es posible emplear <code>SQL*Loader</code> para cargarlos en una instancia de Oracle.</p>
<p><img src="./../images/ABD/movdatos/2-7.png" alt="image"></p>
<p><strong>Nota</strong>: Es crucial asegurarse de que los nombres de las columnas sean idénticos y que los tipos de datos sean compatibles.</p>
<div><pre><code>create table dept (
        deptno number(2) constraint pk_dept PRIMARY KEY,
        dname varchar2(14),
        loc varchar2(13)
);

create table salgrade (
        grade number,
        losal number,
        hisal number
);
</code></pre>
</div><p>Se deberá crear un archivo de control específico para cada tabla que se desee cargar mediante SQL*Loader y guardarlos en la carpeta <code>/home/oracle/control</code>.</p>
<div><pre><code>nano dept.ctl
</code></pre>
</div><hr>
<div><pre><code>LOAD DATA
INFILE '/home/oracle/scott/dept.csv'
INTO TABLE dept
FIELDS TERMINATED BY ','
TRAILING NULLCOLS
(deptno, dname, loc)
</code></pre>
</div><hr>
<div><pre><code>nano salgrade.ctl
</code></pre>
</div><hr>
<div><pre><code>LOAD DATA
INFILE '/home/oracle/scott/salgrade.csv'
INTO TABLE salgrade
FIELDS TERMINATED BY ','
TRAILING NULLCOLS
(grade, losal, hisal)
</code></pre>
</div><hr>
<p><img src="./../images/ABD/movdatos/3-7.png" alt="image"></p>
<p>Me pasaré los ficheros por <code>scp</code> creados en Postgres a Oracle y los meteré en la ruta que he puesto en los ficheros de control.</p>
<p>La ejecución de SQL*Loader se realizará mediante la línea de comandos, en la cual se indicarán los archivos de control y parámetros correspondientes.</p>
<div><pre><code>sqlldr scott2/tiger control=/home/oracle/control/dept.ctl log=/home/oracle/log/dept.log
sqlldr scott2/tiger control=/home/oracle/control/salgrade.ctl log=/home/oracle/log/salgrade.log
</code></pre>
</div><p><em>Prueba de la tabla &quot;dept&quot;.</em></p>
<p><img src="./../images/ABD/movdatos/4-7.png" alt="image"></p>
<p><img src="./../images/ABD/movdatos/5-7.png" alt="image"></p>
<p><em>Prueba de la tabla &quot;salgrade&quot;.</em></p>
<p><img src="./../images/ABD/movdatos/6-7.png" alt="image"></p>
<p><img src="./../images/ABD/movdatos/7-7.png" alt="image"></p>
<p>Acto seguido accederé a la base de datos y comprobaré que se han cargado los datos correctamente.</p>
<p><img src="./../images/ABD/movdatos/8-7.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Implantación de aplicaciones web PHP en docker</title>
    <id>https://github.com/oscarlucas22/practicas/phpdocker/</id>
    <link href="https://github.com/oscarlucas22/practicas/phpdocker/"/>
    <updated>2023-03-07T17:02:54.460Z</updated>
    <content type="html"><![CDATA[<h1 id="implantacion-de-aplicaciones-web-php-en-docker"> Implantación de aplicaciones web PHP en docker</h1>
<p><strong>Imaginemos que el equipo de desarrollo de nuestra empresa ha desarrollado una aplicación PHP que se llama <a href="https://github.com/evilnapsis/bookmedik" target="_blank" rel="noopener noreferrer">BookMedik<i>Content not supported</i></a>.</strong></p>
<p><strong>Queremos crear una imagen Docker para implantar dicha aplicación.</strong></p>
<p><strong>Tenemos que tener en cuenta los siguientes aspectos:</strong></p>
<p><em><strong>Contenedor mariadb</strong></em></p>
<ul>
<li>
<p><strong>Es necesario que nuestra aplicación guarde su información en un contenedor docker mariadb.</strong></p>
</li>
<li>
<p><strong>El script para generar la base de datos y los registros lo encuentras en el repositorio y se llama schema.sql. Debes crear un usuario con su contraseña en la base de datos. La base de datos se llama bookmedik y se crea al ejecutar el script.</strong></p>
</li>
<li>
<p><strong>Ejecuta el contenedor mariadb y carga los datos del script schema.sql. Para más información.</strong></p>
</li>
<li>
<p><strong>El contenedor mariadb debe tener un volumen para guardar la base de datos.</strong></p>
</li>
</ul>
<p><em><strong>Contenedor bookmedik</strong></em></p>
<ul>
<li>
<p><strong>Vamos a crear tres versiones de la imagen que nos permite implantar la aplicación PHP.</strong></p>
</li>
<li>
<p><strong>La imagen debe crear las variables de entorno necesarias con datos de conexión por defecto.</strong></p>
</li>
<li>
<p><strong>Al crear un contenedor a partir de estas imágenes se ejecutará un script bash que realizará las siguientes tareas:</strong></p>
<ul>
<li>
<p><strong>Modifique el fichero core\controller\Database.php para que lea las variables de entorno. Para obtener las variables de entorno en PHP usar la función getenv. Para más información.</strong></p>
</li>
<li>
<p><strong>Inicialice la base de datos con el fichero schema.sql.</strong></p>
</li>
<li>
<p><strong>Ejecute el servidor web.</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>El contenedor que creas debe tener un volumen para guardar los logs del servidor web.</strong></p>
</li>
<li>
<p><strong>La imagen la tienes que crear en tu entorno de desarrollo con el comando docker build.</strong></p>
</li>
</ul>
<hr>
<p>Clonamos el repositorio de la aplicación web:</p>
<p>[Cloname](git clone https://github.com/evilnapsis/bookmedik.git)</p>
<h2 id="tarea-1-creacion-de-una-imagen-docker-con-una-aplicacion-web-desde-una-imagen-base"> Tarea 1: Creación de una imagen docker con una aplicación web desde una imagen base</h2>
<ul>
<li>
<p><strong>Vamos a crear una imagen que se llame usuario/bookmedik:v1.</strong></p>
</li>
<li>
<p><strong>Crea una imagen docker con la aplicación desde una imagen base de debian o ubuntu.</strong></p>
</li>
</ul>
<p>En primer lugar hemos hecho un fork del repositorio de bookmedik y lo hemos clonado en nuestro entorno de desarrollo. Una vez hecho esto, vamos a modificar el fichero schema.sql para que podamos ejecutarlo en un contenedor que ya tendrá una base de datos creada. Así pues, eliminamos las siguientes líneas de ese fichero:</p>
<div><pre><code>create database bookmedik;
use bookmedik;
</code></pre>
</div><p>A continuación modificamos el fichero <code>core/controller/Database.php</code> para que se configure a través de las variables de entorno que introduzcamos al crear el contenedor:</p>
<div><pre><code>&lt;?php
class Database {
        public static $db;
        public static $con;
        function Database(){
                $this-&gt;user=getenv('USER_BOOKMEDIK');$this-&gt;pass=getenv('PASSWD_BOOKMEDIK');$this-&gt;host=getenv('DB_HOST');$this-&gt;ddbb=getenv('NOMBRE_DB');
        }

        function connect(){
                $con = new mysqli($this-&gt;host,$this-&gt;user,$this-&gt;pass,$this-&gt;ddbb);
                $con-&gt;query(&quot;set sql_mode=''&quot;);
                return $con;
        }

        public static function getCon(){
                if(self::$con==null &amp;&amp; self::$db==null){
                        self::$db = new Database();
                        self::$con = self::$db-&gt;connect();
                }
                return self::$con;
        }
}
?&gt;
</code></pre>
</div><p>Con esto ya podemos crear el Dockerfile que usaremos para crear la imagen:</p>
<div><pre><code>nano Dockerfile
</code></pre>
</div><hr>
<div><pre><code>FROM debian:bullseye
MAINTAINER oscarlucas &quot;oscarlucasleo124@gmail.com&quot;
RUN apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get install apache2 libapache2-mod-php php php-mysql mariadb-client -y &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*
ADD bookmedik /var/www/html/
ADD script.sh /opt/
RUN chmod +x /opt/script.sh &amp;&amp; rm /var/www/html/index.html
ENTRYPOINT [&quot;/opt/script.sh&quot;]
</code></pre>
</div><p>Como vemos, al final le indicamos que ejecute un script. Dicho script lo hemos creado nosotros, y en él hacemos que introduzca la información del fichero schema.sql en la base de datos y hacemos que ejecute apache en modo demonio. El contenido del script es el siguiente:</p>
<div><pre><code>nano script.sh
</code></pre>
</div><hr>
<div><pre><code>#! /bin/sh

while ! mysql -u ${USER_BOOKMEDIK} -p${PASSWD_BOOKMEDIK} -h ${DB_HOST}  -e &quot;;&quot; ; do
sleep 1
done
mysql -u $USER_BOOKMEDIK --password=$PASSWD_BOOKMEDIK -h $DB_HOST $NOMBRE_DB &lt; /var/www/html/schema.sql
/usr/sbin/apache2ctl -D FOREGROUND
</code></pre>
</div><p>Este script lo hemos introducido en el directorio bookmedik (el que hemos obtenido de la clonación de github) para que se añada al contenedor junto con el contenido de dicho directorio. Con esto ya podemos crear la imagen con el siguiente comando:</p>
<div><pre><code>docker build -t oscarlucas/bookmedik:v1 .
</code></pre>
</div><p>Una vez creada, ya la podemos ver en nuestro registro local:</p>
<p>![image]</p>
<h2 id="tarea-2-despliegue-en-el-entorno-de-desarrollo"> Tarea 2: Despliegue en el entorno de desarrollo</h2>
<ul>
<li>
<p><strong>Crea un script con docker-compose que levante el escenario con los dos contenedores.</strong></p>
</li>
<li>
<p><strong>Recuerda que para acceder a la aplicación: Usuario: admin, contraseña: admin.</strong></p>
</li>
</ul>
<p>Así pues, crearemos un fichero docker-compose.yaml con la configuración necesaria para levantar los dos contenedores:</p>
<div><pre><code>nano docker-compose.yaml
</code></pre>
</div><hr>
<div><pre><code>version: '3.1'
services:
  bookmedik:
    container_name: cont-bookmedikv1
    image: oscarlucas/bookmedik:v1
    restart: always
    environment:
      USER_BOOKMEDIK: admin
      PASSWD_BOOKMEDIK: admin
      DB_HOST: db-mariadbv1
      NOMBRE_DB: bookmedik
    ports:
      - 8081:80
    depends_on:
      - db
  db:
    container_name: db-mariadbv1
    image: mariadb
    restart: always
    environment:
      MARIADB_ROOT_PASSWORD: root
      MARIADB_DATABASE: bookmedik
      MARIADB_USER: admin
      MARIADB_PASSWORD: admin
    volumes:
      - mariadb_data:/var/lib/mysql
volumes:
    mariadb_data:
</code></pre>
</div><p>Ahora levantamos los contenedores:</p>
<div><pre><code>docker-compose up -d
</code></pre>
</div><p>Podemos verlos funcionando con el siguiente comando:</p>
<p>![image]</p>
<p>Y si entramos desde el navegador web, debería funcionar correctamente:</p>
<p>![image]</p>
<h2 id="tarea-3-creacion-de-una-imagen-docker-con-una-aplicacion-web-desde-una-imagen-php"> Tarea 3: Creación de una imagen docker con una aplicación web desde una imagen PHP</h2>
<ul>
<li>
<p><strong>Vamos a crear una imagen que se llame usuario/bookmedik:v2.</strong></p>
</li>
<li>
<p><strong>Realiza la imagen docker de la aplicación a partir de la imagen oficial PHP que encuentras en docker hub. Lee la documentación de la imagen para configurar una imagen con apache2 y php, además seguramente tengas que instalar alguna extensión de php.</strong></p>
</li>
<li>
<p><strong>Modifica el fichero docker-compose.yml` para probar esta imagen.</strong></p>
</li>
</ul>
<p>Ahora le toca el turno a la imagen de PHP. Para ello, crearemos un fichero llamado Dockerfile en la raíz del proyecto y añadiremos el siguiente contenido:</p>
<div><pre><code>FROM php:7.4-apache-bullseye
MAINTAINER oscarlucas &quot;oscarlucasleo124@gmail.com&quot;
RUN apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; docker-php-ext-install mysqli pdo pdo_mysql &amp;&amp; apt-get install mariadb-client -y &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*
ADD bookmedik /var/www/html/
ADD script.sh /opt/
RUN chmod +x /opt/script.sh
ENTRYPOINT [&quot;/opt/script.sh&quot;]
</code></pre>
</div><p>Y creamos una nueva imagen:</p>
<div><pre><code>docker build -t oscarlucas/bookmedik:v2 .
</code></pre>
</div><p>EL fichero docker-compose.yaml quedaría de la siguiente forma:</p>
<div><pre><code>version: '3.1'
services:
  bookmedik:
    container_name: cont-bookmedikv2
    image: oscarlucas/bookmedik:v2
    restart: always
    environment:
      USER_BOOKMEDIK: bookmedik
      PASSWD_BOOKMEDIK: bookmedik
      DB_HOST: db-mariadbv2
      NOMBRE_DB: bookmedik
    ports:
      - 8082:80
    depends_on:
      - db
  db:
    container_name: db-mariadbv2
    image: mariadb
    restart: always
    environment:
      MARIADB_ROOT_PASSWORD: root
      MARIADB_DATABASE: bookmedik
      MARIADB_USER: bookmedik
      MARIADB_PASSWORD: bookmedik
    volumes:
      - mariadb_data:/var/lib/mysql
volumes:
    mariadb_data:
</code></pre>
</div><p>Realizamos el despliegue con docker-compose up -d y como vemos en la imagen anterior, ambos contenedores se están ejecutando y en la siguiente, comprobamos que la imagen se ha creado correctamente:</p>
<p>![image]</p>
<p>Si accedemos a la aplicación, podremos ver que funciona correctamente:</p>
<p>![image]</p>
<h2 id="tarea-4-ejecucion-de-una-aplicacion-php-en-docker-con-nginx-optativa"> Tarea 4: Ejecución de una aplicación PHP en docker con nginx (OPTATIVA)</h2>
<ul>
<li>
<p><strong>Vamos a crear una imagen que se llame usuario/bookmedik:v3.</strong></p>
</li>
<li>
<p><strong>En este caso queremos usar un contenedor que utilice nginx para servir la aplicación PHP. Puedes crear la imagen desde una imagen base debian o ubuntu o desde la imagen oficial de nginx.</strong></p>
</li>
<li>
<p><strong>Vamos a crear otro contenedor que sirva php-fpm.</strong></p>
</li>
<li>
<p><strong>Para que funcione de forma adecuada el php-fpm tiene que tener acceso al directorio donde se encuentra la aplicación.</strong></p>
</li>
<li>
<p><strong>Y finalmente nuestro contenedor con la aplicación.</strong></p>
</li>
<li>
<p><strong>Crea un script con docker compose que levante el escenario con los tres contenedores.</strong></p>
</li>
</ul>
<p><strong>A lo mejor te puede ayudar el siguiente enlace: Dockerise your PHP application with Nginx and PHP7-FPM</strong></p>
<p>En esta tarea, vamos a tener que crear dos imágenes:</p>
<ul>
<li>
<p>Una que contrendrá la aplicación PHP y será nginx la encargada de servirla.</p>
</li>
<li>
<p>Otra que tendrá los modulos de PHP necesarios para que la aplicación funcione.</p>
</li>
</ul>
<p>Creamos el Dockerfile con php-fpm y sus correspondientes modulos:</p>
<div><pre><code>FROM php:7.4-fpm
MAINTAINER oscarlucas &quot;oscarlucasleo124@gmail.com&quot;
RUN docker-php-ext-install mysqli
</code></pre>
</div><p>Creamos la imagen:</p>
<div><pre><code>docker build -t oscarlucas/php-fpm-mysql:v1 .
</code></pre>
</div><p>![image]</p>
<p>Para crear el dockerfile con la aplicación y nginx como servidor web, añadimos el siguiente contenido:</p>
<div><pre><code>FROM nginx
MAINTAINER oscarlucas &quot;oscarlucasleo124@gmail.com&quot;
RUN apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get install mariadb-client -y &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*
ADD default.conf /etc/nginx/conf.d/
ADD bookmedik /usr/share/nginx/html
ADD script.sh /opt/
RUN chmod +x /opt/script.sh &amp;&amp; rm /usr/share/nginx/html/index.html
ENTRYPOINT [&quot;/opt/script.sh&quot;]
</code></pre>
</div><p>En el docker file anterior, hemos establecido el fichero default.conf como el fichero de configuración de nginx. Este fichero contendrá la siguiente información:</p>
<div><pre><code>nano default.conf
</code></pre>
</div><hr>
<div><pre><code>server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;
    error_log  /var/log/nginx/error-nignx.log;
    access_log /var/log/nginx/access-nginx.log;
    root   /usr/share/nginx/html;
    index  index.php index.html;

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass book_php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
}
</code></pre>
</div><p>Y también deberemos modificar script.sh para adaptarlo a nginx:</p>
<div><pre><code>#! /bin/sh

while ! mysql -u ${USER_BOOKMEDIK} -p${PASSWD_BOOKMEDIK} -h ${DB_HOST}  -e &quot;;&quot; ; do
sleep 1
done
mysql -u $USER_BOOKMEDIK --password=$PASSWD_BOOKMEDIK -h $DB_HOST $NOMBRE_DB &lt; /var/www/html/schema.sql
/usr/sbin/apache2ctl -D FOREGROUND

nginx -g &quot;daemon off;&quot;
</code></pre>
</div><p>Creamos la imagen:</p>
<div><pre><code>docker build -t oscarlucas/bookmedik:v3 .
</code></pre>
</div><p>![image]</p>
<p>Antes de modificar el docker-compose.yaml debemos tener en cuenta que:</p>
<ul>
<li>
<p>Los contenedores que tienen php-fpm y nginx, deben estar en la misma ruta.</p>
</li>
<li>
<p>Las variables de entorno que se pasan al contenedor de nginx, deben también estar en el contenedor de php-fpm.</p>
</li>
</ul>
<p>Por lo que el fichero docker-compose.yaml quedaría de la siguiente forma:</p>
<div><pre><code>version: '3.1'
services:
  bookmedik:
    container_name: cont-bookmedikv3
    image: oscarlucas/bookmedik:v3
    restart: always
    environment:
      USER_BOOKMEDIK: bookmedik
      PASSWD_BOOKMEDIK: bookmedik
      DB_HOST: db-mariadbv3
      NOMBRE_DB: bookmedik
    ports:
      - 8083:80
    depends_on:
      - db
      - php
    volumes:
      - phpdocs:/usr/share/nginx/html/
db:
  container_name: db-mariadbv3
  image: mariadb
  restart: always
  environment:
    MARIADB_ROOT_PASSWORD: root
    MARIADB_DATABASE: bookmedik
    MARIADB_USER: bookmedik
    MARIADB_PASSWORD: bookmedik
  volumes:
    - mariadb_data:/var/lib/mysql
php:
  container_name: cont-php
  image: oscarlucas/php-fpm-mysql:v1
  restart: always
  environment:
    USER_BOOKMEDIK: bookmedik
    PASSWD_BOOKMEDIK: bookmedik
    DB_HOST: db-mariadbv3
    NOMBRE_DB: bookmedik
  volumes:
    - phpdocs:/usr/share/nginx/html/

volumes:
    mariadb_data:
    phpdocs:
</code></pre>
</div><p>Tras todos los pasos anteriores, podemos cerciorarnos en la imagen anterior, que las imágenes que hemos confeccionado se han creado correctamente.</p>
<p>Ahora, ejecutamos el docker compose.yaml:</p>
<div><pre><code>docker-compose up -d
</code></pre>
</div><p>![image]</p>
<h2 id="tarea-5-puesta-en-produccion-de-nuestra-aplicacion"> Tarea 5: Puesta en producción de nuestra aplicación</h2>
<ul>
<li>
<p><strong>Elige una de las tres imágenes y súbela a Docker Hub.</strong></p>
</li>
<li>
<p><strong>En tu VPS instala Docker y utilizando el docker-compose.yml correspondiente, crea un contenedor en ella de la aplicación.</strong></p>
</li>
<li>
<p><strong>Configura el nginx de tu VPS para que haga de proxy inverso y nos permita acceder a la aplicación con https://bookmedik.tudominio.xxx</strong></p>
</li>
</ul>
<p>Vamos a poner en producción la aplicación a través de nuestro VPS, por lo que lo primero que deberemo de hacer es crear un registro CNAME en nuestro DNS para que apunte a la IP de nuestro VPS.</p>
<p>bookmedik.olucass.com CNAME olucass.com</p>
<p>Y le generamos un certificado de Let's Encrypt:</p>
<div><pre><code>certbot certonly --standalone -d bookmedik.olucass.com
</code></pre>
</div><p>Instalamos docker y docker-compose en nuestro VPS:</p>
<div><pre><code>sudo apt update &amp;&amp; sudo apt upgrade -y &amp;&amp; sudo apt install docker.io docker-compose-plugin -y
</code></pre>
</div><p>Al tener las imágenes creadas subidas a Docker Hub, podemos descargarlas en nuestro VPS:</p>
<div><pre><code>docker pull oscarlucas/bookmedik:v2
</code></pre>
</div><p>En mi caso he elegido la versión 2, ya que es la que tiene el fichero docker-compose.yaml adaptado para el VPS.</p>
<p>Creamos el virtualhost en nginx para que actúe de proxy inverso:</p>
<div><pre><code>nano /etc/nginx/sites-available/bookmedik.olucass.com
</code></pre>
</div><hr>
<div><pre><code>server {
        listen 80;
        listen [::]:80;

        server_name bookmedik.olucass.com;

        return 301 https://$host$request_uri;
}

server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;

        ssl    on;
        ssl_certificate /etc/letsencrypt/live/bookmedik.olucass.com/fullchain.pem;
        ssl_certificate_key     /etc/letsencrypt/live/bookmedik.olucass.com/privkey.pem;

        index index.html index.php index.htm index.nginx-debian.html;

        server_name bookmedik.olucass.com;

        location / {
                proxy_pass http://localhost:8084;
                include proxy_params;
        }

}
</code></pre>
</div><p>Creamos el enlace simbólico y reiniciamos nginx:</p>
<div><pre><code>ln -s /etc/nginx/sites-available/bookmedik.olucass.com /etc/nginx/sites-enabled/
systemctl restart nginx
</code></pre>
</div><p>En mi caso, he subido los ficheros a github, por lo que he clonado el repositorio y el repositorio de Bookmedik en mi VPS.</p>
<p>Realizamos la ejecución del comando docker-compose up -d y comprobamos que todo funciona correctamente:</p>
<p>![image]</p>
<p>Y como podemos comprobar en la siguiente imagen, la aplicación funciona correctamente.</p>
<p>![image]</p>
<p>NOTA: A la hora de hacer el despliegue, debemos cerciorarnos de cambiar el puerto de escucha, dado que puede caber la posibilidad (o que sea muy probable) de que el puerto 8080 esté ocupado. En mi caso, he puesto el puerto de escucha en el 8083 debido a que ya tengo aplicaciones desplegadas en mi VPS.</p>
<p>![image]</p>
<h2 id="tarea-6-modificacion-de-la-aplicacion"> Tarea 6: Modificación de la aplicación</h2>
<ul>
<li>
<p><strong>En el entorno de desarrollo vamos a hacer una modificación de la aplicación. Por ejemplo modifica el fichero core/app/view/login-view.php y pon tu nombre en la línea</strong></p>
</li>
<li>
<p><strong>Vamos a trabajar con la primera imagen que construimos. Vuelve a crear la imagen con la etiqueta v1_2.</strong></p>
</li>
<li>
<p><strong>Cambia el docker-compose para probar el cambio.</strong></p>
</li>
<li>
<p><strong>Modifica la aplicación en producción.</strong></p>
</li>
</ul>
<p>Vamos a modificar la aplicación para que nos muestre nuestro nombre en la línea &quot;h4&quot;.</p>
<p>Para ello, vamos a utilizar la imagen de legnakra/bookmedik:v1 que ya tiene el fichero docker-compose.yaml para generar la nueva imagen.</p>
<p>![image]</p>
<p>Creamos la nueva imagen</p>
<div><pre><code>docker build -t oscarlucas/bookmedik:v1_2 .
</code></pre>
</div><p>La resubimos a DockerHub:</p>
<div><pre><code>docker push oscarlucas/bookmedik:v1_2
</code></pre>
</div><p>Eliminamos los contenedores que están en ejecución, modificamos el fichero docker-compose.yaml para que descargue la nueva imagen y ejecutamos el docker-compose.yaml:</p>
<div><pre><code>docker-compose down
</code></pre>
</div><hr>
<div><pre><code>nano docker-compose.yaml
</code></pre>
</div><hr>
<div><pre><code>version: '3.1'
services:
  bookmedik:
    container_name: cont-bookmedik
    image: oscarlucas/bookmedik:v1_2
    restart: always
    environment:
      USER_BOOKMEDIK: admin
      PASSWD_BOOKMEDIK: admin
      DB_HOST: db-mariadb
      NOMBRE_DB: bookmedik
    ports:
      - 8082:80
    depends_on:
      - db
  db:
    container_name: db-mariadb
    image: mariadb
    restart: always
    environment:
      MARIADB_ROOT_PASSWORD: root
      MARIADB_DATABASE: bookmedik
      MARIADB_USER: admin
      MARIADB_PASSWORD: admin
    volumes:
      - mariadb_data:/var/lib/mysql
volumes:
    mariadb_data:
</code></pre>
</div><hr>
<div><pre><code>docker-compose up -d
</code></pre>
</div><p>![image]</p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">Práctica: Implantación de aplicaciones web Python en docker</title>
    <id>https://github.com/oscarlucas22/practicas/python-docker/</id>
    <link href="https://github.com/oscarlucas22/practicas/python-docker/"/>
    <updated>2023-03-07T17:02:54.461Z</updated>
    <content type="html"><![CDATA[<h1 id="practica-implantacion-de-aplicaciones-web-python-en-docker"> Práctica: Implantación de aplicaciones web Python en docker</h1>
<p><strong>Queremos desplegar en docker la aplicación escrita en python django: tutorial de django, que desplegamos en la tarea Despliegue de aplicaciones python.</strong></p>
<p><strong>Tienes que tener en cuenta los siguientes aspectos:</strong></p>
<ul>
<li>
<p><strong>La aplicación debe guardar los datos en una base de datos mariadb.</strong></p>
</li>
<li>
<p><strong>La aplicación se podrá configurar para indicar los parámetros de conexión a la base de datos: usuario, contraseña, host y base de datos.</strong></p>
</li>
<li>
<p><strong>La aplicación deberá tener creado un usuario administrador para el acceso.</strong></p>
</li>
</ul>
<hr>
<h2 id="entorno-de-desarrollo"> Entorno de desarrollo</h2>
<p>Procederemos a establecer un ambiente de desarrollo que nos permitirá llevar a cabo todas las pruebas requeridas antes de desplegar nuestra aplicación en producción. De esta manera, podremos asegurarnos de que se encuentre en óptimas condiciones antes de su lanzamiento oficial.</p>
<p>Además, generaremos dos contenedores que se conectarán en la misma red. Una vez que hayamos verificado el correcto funcionamiento de la aplicación, avanzaremos en la creación del archivo docker-compose para implementarla en producción.</p>
<h3 id="creacion-de-la-red"> Creación de la red</h3>
<p>Para crear la red, ejecutamos el siguiente comando:</p>
<div><pre><code>docker network create django-network
</code></pre>
</div><h3 id="creacion-del-contenedor-de-la-base-de-datos"> Creación del contenedor de la base de datos</h3>
<p>Creamos el contenedor de mariadb con las siguientes variables</p>
<div><pre><code>docker run -d --name mariadb -v vol-polls:/var/lib/mysql --network django-network -e MARIADB_ROOT_PASSWORD=admin -e MARIADB_USER=django -e MARIADB_PASSWORD=admin -e MARIADB_DATABASE=django mariadb
</code></pre>
</div><p>Realizamos una modificación al archivo <code>settings.py</code> para que pueda leer las variables de entorno. Para ello, agregamos o actualizamos la siguiente información:</p>
<div><pre><code>import os
</code></pre>
</div><hr>
<div><pre><code>ALLOWED_HOSTS = [os.environ.get(&quot;ALLOWED_HOSTS&quot;)]
</code></pre>
</div><hr>
<div><pre><code>DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': os.environ.get(&quot;DB&quot;),
        'USER': os.environ.get('USER'),
        'PASSWORD': os.environ.get(&quot;PASSWD&quot;),
        'HOST': os.environ.get('HOST'),
        'PORT': '3306',
    }
}
</code></pre>
</div><hr>
<div><pre><code>STATIC_ROOT = os.path.join(BASE_DIR, 'static')
STATIC_URL = '/static/'

CSRF_TRUSTED_ORIGINS = ['http://*.olucass.com','http://*.127.0.0.1','https://*.olucass.com','https://*.127.0.0.1']
</code></pre>
</div><p>Creamos el Dockerfile a partir de la imagen de python:</p>
<div><pre><code>nano Dockerfile
</code></pre>
</div><hr>
<div><pre><code>FROM python:3
WORKDIR /usr/src/app
MAINTAINER oscarlucas 'oscarlucasleo124@gmail.com'
RUN apt-get install git &amp;&amp; pip install --root-user-action=ignore --upgrade pip &amp;&amp; pip install --root-user-action=ignore django mysqlclient
RUN git clone https://github.com/oscarlucas22/django_tutorial_docker /usr/src/app &amp;&amp; mkdir static
ADD ./script.sh /usr/src/app/
RUN chmod +x /usr/src/app/script.sh
ENV ALLOWED_HOSTS=*
ENV HOST=mariadb
ENV USER=django
ENV PASSWD=django
ENV DB=django
ENV DJANGO_SUPERUSER_PASSWORD=admin
ENV DJANGO_SUPERUSER_USERNAME=admin
ENV DJANGO_SUPERUSER_EMAIL=admin@example.org
ENTRYPOINT [&quot;/usr/src/app/script.sh&quot;]
</code></pre>
</div><p>Al final del Dockerfile hacemos referencia a un script. Dicho script es el siguiente:</p>
<div><pre><code>nano script.sh
</code></pre>
</div><hr>
<div><pre><code>#! /bin/sh

python3 manage.py makemigrations
python3 manage.py migrate
python3 manage.py createsuperuser --noinput
python3 manage.py collectstatic --noinput
python3 manage.py runserver 0.0.0.0:8006
</code></pre>
</div><p>Creamos la imagen de Docker:</p>
<div><pre><code>docker build -t oscarlucas/django:v1 .
</code></pre>
</div><p>Antes de crear el archivo docker-compose para implementar la imagen, realizamos una prueba de ésta mediante la creación de un contenedor adicional en la misma red que el contenedor de mariadb:</p>
<div><pre><code>docker run -d --name polls --network django-network -p 8080:8006 oscarlucas/django:v1
</code></pre>
</div><p>Después de comprobar que todo funciona correctamente en la imagen anterior, procedemos a crear el archivo docker-compose que iniciará los dos contenedores previamente generados.</p>
<div><pre><code>nano docker-compose.yml
</code></pre>
</div><hr>
<div><pre><code>version: '3.1'
services:
  django-tutorial:
    container_name: django-tutorial
    image: oscarlucas/django:v1
    restart: always
    environment:
      ALLOWED_HOSTS: &quot;*&quot;
      HOST: bd_mariadb_django
      USER: django
      PASSWD: django
      DB: django
      DJANGO_SUPERUSER_PASSWORD: admin
      DJANGO_SUPERUSER_USERNAME: admin
      DJANGO_SUPERUSER_EMAIL: admin@admin.org
    ports:
      - 8084:8006
    depends_on:
      - db_django
  db_django:
    container_name: bd_mariadb_django
    image: mariadb
    restart: always
    environment:
      MARIADB_ROOT_PASSWORD: root
      MARIADB_DATABASE: django
      MARIADB_USER: django
      MARIADB_PASSWORD: django
    volumes:
      - mariadb_data_django:/var/lib/mysql
volumes:
    mariadb_data_django:
</code></pre>
</div><p>Intentemos ejecutar el entorno de desarrollo mediante el uso del archivo docker-compose:</p>
<div><pre><code>docker-compose up -d
</code></pre>
</div><p><img src="./../images/IAW/php-docker/1.png" alt="image"></p>
<p>Tratamos de acceder al panel de administración utilizando las credenciales que establecimos en el archivo docker-compose:</p>
<p><img src="./../images/IAW/php-docker/2.png" alt="image"></p>
<h2 id="entorno-de-produccion"> Entorno de producción</h2>
<p>Como podemos observar, todo parece estar funcionando correctamente. Ahora nos dirigimos al entorno de producción para ejecutar el archivo docker-compose correspondiente:</p>
<div><pre><code>docker-compose up -d
</code></pre>
</div><p>Vemos que se han creado ambos contenedores:</p>
<p><img src="./../images/IAW/php-docker/3.png" alt="image"></p>
<p>Ahora debemos crear un nuevo registro CNAME en nuestro servidor DNS:</p>
<p><img src="./../images/IAW/php-docker/4.png" alt="image"></p>
<p>Una vez completado este paso, estaremos listos para solicitar los certificados de &quot;Let's Encrypt&quot; correspondientes al nuevo dominio:</p>
<div><pre><code>certbot certonly --standalone -d django.olucass.com
</code></pre>
</div><p>Una vez generados, solo tenemos que crear el proxy en nginx para que nos permita acceder al contenedor:</p>
<div><pre><code>nano /etc/nginx/sites-available/django.olucass.com
</code></pre>
</div><hr>
<div><pre><code>server {
        listen 80;
        listen [::]:80;

        server_name django.olucass.com;

        return 301 https://$host$request_uri;
}

server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;

        ssl    on;
        ssl_certificate /etc/letsencrypt/live/django.olucass.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/django.olucass.com/privkey.pem;

        index index.html index.php index.htm index.nginx-debian.html;

        server_name django.olucass.com;

        location / {
                proxy_pass http://localhost:8084;
                include proxy_params;
        }
}
</code></pre>
</div><p>Generamos un enlace simbólico para que nginx pueda cargar la configuración y procedemos a reiniciar el servicio correspondiente:</p>
<div><pre><code>ln -s /etc/nginx/sites-available/django.olucass.com /etc/nginx/sites-enabled/
</code></pre>
</div><hr>
<div><pre><code>systemctl restart nginx
</code></pre>
</div><p>Si accedemos desde nuestro navegador a la dirección <a href="https://django.olucass.com" target="_blank" rel="noopener noreferrer">django.olucass.com<i>Content not supported</i></a> podemos ver que accedemos a la aplicación.</p>
<p><img src="./../images/IAW/php-docker/5.png" alt="image"></p>
<p>Y que podemos acceder a la zona de administración.</p>
<p><img src="./../images/IAW/php-docker/6.png" alt="image"></p>
<p><img src="./../images/IAW/php-docker/7.png" alt="image"></p>
<p><img src="./../images/IAW/php-docker/8.png" alt="image"></p>
<p><img src="./../images/IAW/php-docker/9.png" alt="image"></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
  <entry>
    <title type="html">VPN</title>
    <id>https://github.com/oscarlucas22/practicas/vpn/</id>
    <link href="https://github.com/oscarlucas22/practicas/vpn/"/>
    <updated>2023-03-07T17:02:54.467Z</updated>
    <content type="html"><![CDATA[<h1 id="vpn"> VPN</h1>
<h2 id="a-vpn-de-acceso-remoto-con-openvpn-y-certificados-x509-5-puntos"> A) VPN de acceso remoto con OpenVPN y certificados x509 (5 puntos)</h2>
<p><strong>Configura una conexión VPN de acceso remoto entre dos equipos del cloud:</strong></p>
<ul>
<li>
<p><strong>Uno de los dos equipos (el que actuará como servidor) estará conectado a dos redes</strong></p>
</li>
<li>
<p><strong>Para la autenticación de los extremos se usarán obligatoriamente certificados digitales, que se generarán utilizando openssl y se almacenarán en el directorio /etc/openvpn, junto con  los parámetros Diffie-Helman y el certificado de la propia Autoridad de Certificación.</strong></p>
</li>
<li>
<p><strong>Se utilizarán direcciones de la red 10.99.99.0/24 para las direcciones virtuales de la VPN. La dirección 10.99.99.1 se asignará al servidor VPN.</strong></p>
</li>
<li>
<p><strong>Los ficheros de configuración del servidor y del cliente se crearán en el directorio /etc/openvpn de cada máquina, y se llamarán servidor.conf y cliente.conf respectivamente.</strong></p>
</li>
<li>
<p><strong>Tras el establecimiento de la VPN, la máquina cliente debe ser capaz de acceder a una máquina que esté en la otra red a la que está conectado el servidor.</strong></p>
</li>
</ul>
<p><strong>Documenta el proceso detalladamente.</strong></p>
<hr>
<p>Vamos a utilizar Vagrant para crear un escenario. He utilizado el siguiente Vagrantfile para lograrlo:</p>
<p><a href="https://pastebin.com/8SUMxXwY" target="_blank" rel="noopener noreferrer">Vagrantfile<i>Content not supported</i></a></p>
<p>En la máquina que está actuando como servidor, es necesario instalar OpenVPN y habilitar la característica de reenvío (forwarding).</p>
<div><pre><code>sudo apt install openvpn
</code></pre>
</div><hr>
<div><pre><code>sudo nano /etc/sysctl.conf

net.ipv4.ip_forward=1
</code></pre>
</div><p>A continuación, vamos a copiar la configuración de <code>/usr/share/easy-rsa</code> a <code>/etc/openvpn</code> para evitar que las actualizaciones del paquete sobreescriban los cambiOS que realicemos.</p>
<div><pre><code>sudo cp -r /usr/share/easy-rsa /etc/openvpn
cd /etc/openvpn/easy-rsa/
</code></pre>
</div><p>Inicializamos el directorio PKI:</p>
<div><pre><code>sudo ./easyrsa init-pki
</code></pre>
</div><p><img src="./../images/SAD/vpn/1-A.png" alt="image"></p>
<p>A continuación, vamos a crear el certificado de la Autoridad de Certificación (CA) y la clave para firmar los certificados de los clientes y del servidor.</p>
<div><pre><code>sudo ./easyrsa build-ca
</code></pre>
</div><p><img src="./../images/SAD/vpn/2-A.png" alt="image"></p>
<p>He usado &quot;usuarioroot&quot; como frase de contraseña. Según lo indicado en la salida del comando, el certificado se ha generado en <code>/etc/openvpn/easy-rsa/pki/ca.crt</code>, mientras que la clave privada se encuentra en <code>/etc/openvpn/easy-rsa/pki/private/ca.key</code>.</p>
<p>Ahora, debemos generar los parámetros Diffie-Hellman, los cuales se utilizarán para el intercambio de claves durante el proceso de apretón de manos TLS entre el servidor OpenVPN y los clientes que se conecten.</p>
<div><pre><code>sudo ./easyrsa gen-dh
</code></pre>
</div><p><img src="./../images/SAD/vpn/3-A.png" alt="image"></p>
<p>Como podemos ver, se ha generado en <code>/etc/openvpn/easy-rsa/pki/dh.pem</code>.</p>
<p>A continuación, crearemos el certificado y la clave privada del servidor OpenVPN.</p>
<div><pre><code>sudo ./easyrsa build-server-full server nopass
</code></pre>
</div><p><img src="./../images/SAD/vpn/4-A.png" alt="image"></p>
<ul>
<li>“nopass” deshabilita el uso de la frase de paso.</li>
</ul>
<p>El certificado se ha almacenado en <code>/etc/openvpn/easy-rsa/pki/issued/server.crt</code> y la clave privada se ha generado en <code>/etc/openvpn/easy-rsa/pki/private/server.key</code>.</p>
<p>Así como hicimos con el servidor, generaremos el certificado y la clave privada para el cliente de la VPN (que yo llamé Clientevpn1).</p>
<div><pre><code>sudo ./easyrsa build-client-full Clientevpn1 nopass
</code></pre>
</div><p><img src="./../images/SAD/vpn/5-A.png" alt="image"></p>
<p>El certificado se ha generado en <code>/etc/openvpn/easy-rsa/pki/issued/Clientevpn1.crt</code> y la clave privada se ha generado en <code>/etc/openvpn/easy-rsa/pki/private/Clientevpn1.key</code>. Todos estos archivos se encuentran en el lado del servidor, pero para que la conexión sea efectiva, debemos transferir los archivos necesarios al cliente. Para ello, primero los agruparemos en una carpeta para tenerlos más organizados.</p>
<div><pre><code>mkdir /home/vagrant/Clientevpn1
sudo cp -rp /etc/openvpn/easy-rsa/pki/{ca.crt,issued/Clientevpn1.crt,private/Clientevpn1.key} /home/vagrant/Clientevpn1
sudo chown -R vagrant: /home/vagrant/Clientevpn1/
</code></pre>
</div><p>Generamos una clave pública u privada para pasarnos la carpeta:</p>
<div><pre><code>ssh-keygen -t rsa
</code></pre>
</div><p>Y nos pasamos la carpeta a la maquina cliente por scp:</p>
<div><pre><code>scp -i /home/vagrant/.ssh/id_rsa -r /home/vagrant/Clientevpn1/ vagrant@192.168.10.11:/home/vagrant
</code></pre>
</div><p><img src="./../images/SAD/vpn/6-A.png" alt="image"></p>
<p>Ahora, en el lado del servidor, crearemos el archivo de configuración del túnel utilizando el archivo de ejemplo existente.</p>
<div><pre><code>sudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/server/servidor.conf
</code></pre>
</div><hr>
<div><pre><code>sudo nano /etc/openvpn/server/servidor.conf

port 1194
proto udp
dev tun

ca /etc/openvpn/easy-rsa/pki/ca.crt
cert /etc/openvpn/easy-rsa/pki/issued/server.crt
key /etc/openvpn/easy-rsa/pki/private/server.key
dh /etc/openvpn/easy-rsa/pki/dh.pem

topology subnet

server 10.99.99.0 255.255.255.0
ifconfig-pool-persist /var/log/openvpn/ipp.txt

push &quot;route 192.168.11.0 255.255.255.0&quot;

keepalive 10 120
cipher AES-256-CBC
persist-key
persist-tun
status /var/log/openvpn/openvpn-status.log
verb 3
explicit-exit-notify 1
</code></pre>
</div><p>Una vez creado este fichero en el servidor, podemos activar y habilitar el servicio:</p>
<div><pre><code>sudo systemctl enable --now openvpn-server@servidor
</code></pre>
</div><p>Vemos el servicio activo:</p>
<div><pre><code>sudo systemctl status openvpn-server@servidor
</code></pre>
</div><p><img src="./../images/SAD/vpn/7-A.png" alt="image"></p>
<p>En el cliente que queremos que use la vpn (Clientevpn1), tenemos que instalar el paquete openvpn:</p>
<div><pre><code>sudo apt install openvpn
</code></pre>
</div><p>Movemos al lugar adecuado los ficheros que pasamos antes por scp:</p>
<div><pre><code>sudo mv Clientevpn1/* /etc/openvpn/client/
</code></pre>
</div><p>Y les cambiamos el propietario a root:</p>
<div><pre><code>sudo chown root: /etc/openvpn/client/*
</code></pre>
</div><p>Asimismo, procedimos de manera similar con el cliente, tomando la plantilla de configuración existente y alterándola para adaptarla a nuestras necesidades específicas.</p>
<div><pre><code>sudo cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/client/cliente.conf
</code></pre>
</div><hr>
<div><pre><code>sudo nano /etc/openvpn/client/cliente.conf

client
dev tun
proto udp

remote 192.168.10.10 1194
resolv-retry infinite
nobind
persist-key
persist-tun

ca /etc/openvpn/client/ca.crt
cert /etc/openvpn/client/Clientevpn1.crt
key /etc/openvpn/client/Clientevpn1.key

remote-cert-tls server
cipher AES-256-CBC
verb 3
</code></pre>
</div><p>Habilitamos y empezamos el servicio:</p>
<div><pre><code>sudo systemctl enable --now openvpn-client@cliente
</code></pre>
</div><p>Y verificamos si el servicio está funcionando correctamente:</p>
<div><pre><code>sudo systemctl status openvpn-client@cliente
</code></pre>
</div><p><img src="./../images/SAD/vpn/8-A.png" alt="image"></p>
<p>Notamos que se han generado dos interfaces denominadas &quot;tun0&quot; en ambos, el servidor y el cliente, con la dirección IP especificada en el servidor.</p>
<p><em>Servidorvpn</em></p>
<p><img src="./../images/SAD/vpn/9-A.png" alt="image"></p>
<p><em>Clientevpn1</em></p>
<p><img src="./../images/SAD/vpn/10-A.png" alt="image"></p>
<p>En el caso del cliente interno (denominado Clientevpn2 por mi parte), solo es necesario modificar la ruta predeterminada para que apunte hacia el servidor.</p>
<div><pre><code>ip route del default
ip route add default via 192.168.11.10
</code></pre>
</div><p>Pruebas de funcionamiento (todas hechas desde Clientevpn1):</p>
<ul>
<li>Ping a Clientevpn2:</li>
</ul>
<p><img src="./../images/SAD/vpn/11-A.png" alt="image"></p>
<ul>
<li>Traceroute a Clientevpn2:</li>
</ul>
<p><img src="./../images/SAD/vpn/12-A.png" alt="image"></p>
<p>Tal como observamos, el cliente denominado Clientevpn1 (Clientevpn) es capaz de realizar un ping sin problemas hacia una máquina en la red remota, y al revisar el resultado del comando traceroute, podemos ver que transita a través del túnel para alcanzar su destino final.</p>
<h2 id="b-vpn-sitio-a-sitio-con-openvpn-y-certificados-x509-10-puntos"> B) VPN sitio a sitio con OpenVPN y certificados x509 (10 puntos)</h2>
<p><strong>Configura una conexión VPN sitio a sitio entre dos equipos del cloud:</strong></p>
<ul>
<li>
<p><strong>Cada equipo estará conectado a dos redes, una de ellas en común</strong></p>
</li>
<li>
<p><strong>Para la autenticación de los extremos se usarán obligatoriamente certificados digitales, que se generarán utilizando openssl y se almacenarán en el directorio /etc/openvpn, junto con con los parámetros Diffie-Helman y el certificado de la propia Autoridad de Certificación.</strong></p>
</li>
<li>
<p><strong>Se utilizarán direcciones de la red 10.99.99.0/24 para las direcciones virtuales de la VPN.</strong></p>
</li>
<li>
<p><strong>Tras el establecimiento de la VPN, una máquina de cada red detrás de cada servidor VPN debe ser capaz de acceder a una máquina del otro extremo.</strong></p>
</li>
</ul>
<p><strong>Documenta el proceso detalladamente.</strong></p>
<hr>
<p>Para ello vamos a crear un escenario usuando vagrant. Para ello he utilizado el siguiente Vagrantfile:</p>
<p><a href="https://pastebin.com/xrPNkVJt" target="_blank" rel="noopener noreferrer">Vagrantfile<i>Content not supported</i></a></p>
<p>Tendremos el siguiente escenario:</p>
<ul>
<li>
<p>En el escenario 1, hay una subred con direcciones IP en el rango 30.0.0.0/24. Dentro de esta subred habrá dos computadoras conectadas entre sí a través de una red privada. La computadora &quot;Servidor1&quot; tendrá acceso a Internet y será accesible desde &quot;Servidor2&quot;, mientras que la computadora &quot;Cliente1&quot; solo podrá acceder a &quot;Servidor1&quot;.</p>
</li>
<li>
<p>En el escenario 2, que utiliza la red 20.0.0.0/24, se encontrarán dos dispositivos: &quot;Servidor2&quot; que podrá ser accedido desde &quot;Servidor&quot; y &quot;Cliente2&quot; que solo estará conectado a &quot;Servidor2&quot;.</p>
</li>
</ul>
<p><em><strong>Configuración en el escenario 1 (servidor)</strong></em></p>
<p>Para comenzar, deberemos crear un archivo denominado &quot;vars&quot; que obtendrá su contenido a partir de una plantilla existente en el mismo directorio. Este archivo almacenará la información necesaria para nuestra Autoridad Certificadora.</p>
<div><pre><code>sudo apt install openvpn
</code></pre>
</div><hr>
<div><pre><code>cd /usr/share/easy-rsa/
sudo cp vars.example vars
</code></pre>
</div><hr>
<div><pre><code>sudo nano vars

set_var EASYRSA_REQ_COUNTRY     &quot;ES&quot;
set_var EASYRSA_REQ_PROVINCE    &quot;Sevilla&quot;
set_var EASYRSA_REQ_CITY        &quot;Dos Hermanas&quot;
set_var EASYRSA_REQ_ORG         &quot;OLucas Corp&quot;
set_var EASYRSA_REQ_EMAIL       &quot;oscarlucasleo124@gmail.com&quot;
set_var EASYRSA_REQ_OU          &quot;Apartado B VPN&quot;
</code></pre>
</div><p>En este paso, crearemos una carpeta donde se guardarán todos los documentos relacionados con la Autoridad Certificadora, como los certificados, las claves y la base de datos.</p>
<div><pre><code>sudo ./easyrsa init-pki
</code></pre>
</div><p><img src="./../images/SAD/vpn/1-B.png" alt="image"></p>
<p>Finalmente, antes de crear la Autoridad Certificadora, deberemos generar una clave &quot;Diffie-Hellman&quot;:</p>
<div><pre><code>sudo ./easyrsa gen-dh
</code></pre>
</div><p><img src="./../images/SAD/vpn/2-B.png" alt="image"></p>
<p>Ahora podemos proceder a crear la Autoridad Certificadora en sí:</p>
<div><pre><code>sudo ./easyrsa build-ca
</code></pre>
</div><p><img src="./../images/SAD/vpn/3-B.png" alt="image"></p>
<p>Nota: He usado como frase de paso “usuario”.</p>
<p>Ahora que nuestra Autoridad Certificadora está lista, deberemos proceder a crear y firmar el certificado que utilizará nuestro dispositivo &quot;Servidor1&quot;:</p>
<div><pre><code>sudo ./easyrsa gen-req server
</code></pre>
</div><p><img src="./../images/SAD/vpn/4-B.png" alt="image"></p>
<div><pre><code>sudo ./easyrsa sign-req server server
</code></pre>
</div><p><img src="./../images/SAD/vpn/5-B.png" alt="image"></p>
<p>Ahora que hemos terminado de crear y firmar el certificado del servidor, procederemos a generar y firmar el certificado que utilizará el dispositivo &quot;Servidor2&quot; del escenario 2 para acceder a la VPN.</p>
<div><pre><code>sudo ./easyrsa gen-req vpn2
</code></pre>
</div><p><img src="./../images/SAD/vpn/6-B.png" alt="image"></p>
<div><pre><code>sudo ./easyrsa sign-req client vpn2
</code></pre>
</div><p><img src="./../images/SAD/vpn/7-B.png" alt="image"></p>
<p>Vamos a necesitar copiar algunos archivos para que el servidor VPN funcione correctamente en la ruta <code>/etc/openvpn/server</code>.</p>
<div><pre><code>sudo cp pki/ca.crt /etc/openvpn/server/
sudo cp pki/dh.pem /etc/openvpn/server/
sudo cp pki/issued/server.crt /etc/openvpn/server/
sudo cp pki/private/server.key /etc/openvpn/server/
</code></pre>
</div><p>Necesitamos transferir los archivos necesarios para que la máquina &quot;Servidor2&quot; pueda conectarse a mi servidor VPN. Una forma de hacerlo es utilizando SCP, pero hay varias otras opciones disponibles.</p>
<p>Generamos una clave pública u privada para pasarnos la carpeta:</p>
<div><pre><code>ssh-keygen -t rsa
</code></pre>
</div><p>Y nos pasamos la carpeta a la maquina cliente por scp:</p>
<div><pre><code>sudo scp -i /home/vagrant/.ssh/id_rsa /etc/openvpn/server/ca.crt vagrant@192.168.121.182:/home/vagrant
sudo scp -i /home/vagrant/.ssh/id_rsa /usr/share/easy-rsa/pki/issued/vpn2.crt vagrant@192.168.121.182:/home/vagrant
sudo scp -i /home/vagrant/.ssh/id_rsa /usr/share/easy-rsa/pki/private/vpn2.key vagrant@192.168.121.182:/home/vagrant
</code></pre>
</div><p>Actualmente, debemos generar el archivo de configuración para el servidor VPN, y para ello podemos utilizar una plantilla proporcionada por el paquete de OpenVPN.</p>
<div><pre><code>sudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/server/servidor.conf
</code></pre>
</div><hr>
<div><pre><code>sudo nano /etc/openvpn/server/servidor.conf

dev tun

ifconfig 10.99.99.1 10.99.99.2
route 20.0.0.0 255.255.255.0
tls-server 

ca ca.crt
cert server.crt  
key server.key 

dh dh.pem  
comp-lzo  
keepalive 10 120  
log /var/log/openvpn/server.log  
verb 3   
askpass passwd.txt 
</code></pre>
</div><p>Ahora podemos iniciar el servicio en el lado del servidor:</p>
<div><pre><code>sudo systemctl start openvpn-server@servidor
</code></pre>
</div><p>Vemos el servicio activo:</p>
<div><pre><code>sudo systemctl status openvpn-server@servidor
</code></pre>
</div><p><img src="./../images/SAD/vpn/8-B.png" alt="image"></p>
<p>No debemos olvidar el bit de forwarding en el servidor:</p>
<div><pre><code>echo 1 &gt; sudo /proc/sys/net/ipv4/ip_forward
</code></pre>
</div><p>También en el cliente del escenario 1 debemos cambiar la ruta por defecto:</p>
<div><pre><code>sudo ip r del default
sudo ip r add default via 30.0.0.10
</code></pre>
</div><p>Con esto hemos terminado en el lado del escenario 1.</p>
<p><em><strong>Configuración en el escenario 2 (cliente)</strong></em></p>
<p>Instalamos openvpn</p>
<div><pre><code>sudo apt install openvpn
</code></pre>
</div><p>En esta situación, debemos preparar la máquina &quot;Servidor2&quot; para que funcione como la otra punta del túnel VPN. El primer paso es trasladar los archivos que se enviaron desde el escenario 1 a la carpeta correspondiente.</p>
<div><pre><code>sudo mv ca.crt /etc/openvpn/client/
sudo mv vpn2.crt /etc/openvpn/client/
sudo mv vpn2.key /etc/openvpn/client/
</code></pre>
</div><p>En este momento, vamos a crear un archivo de configuración para esta máquina. Para hacerlo, disponemos de un modelo como guía, al igual que ocurrió en el paso anterior.</p>
<div><pre><code>sudo cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/client/cliente.conf
</code></pre>
</div><hr>
<div><pre><code>sudo nano /etc/openvpn/client/cliente.conf

dev tun  

remote 192.168.121.102
ifconfig 10.99.99.2 10.99.99.1 
route 30.0.0.0 255.255.255.0
tls-client 

ca ca.crt
cert vpn2.crt
key vpn2.key 

comp-lzo  
keepalive 10 60 
verb 3 
askpass passwd2.txt 
</code></pre>
</div><p>Ahora iniciamos el servicio:</p>
<div><pre><code>sudo systemctl start openvpn-client@cliente
</code></pre>
</div><p>Vemos el servicio activo:</p>
<div><pre><code>sudo systemctl status openvpn-client@cliente
</code></pre>
</div><p><img src="./../images/SAD/vpn/9-B.png" alt="image"></p>
<p>También debemos activar el ip de forwarding en esta máquina:</p>
<div><pre><code>echo 1 &gt; sudo /proc/sys/net/ipv4/ip_forward
</code></pre>
</div><p>Al igual que antes, también debemos cambiar la ruta del cliente en este escenario:</p>
<div><pre><code>sudo ip r del default
sudo ip r add default via 20.0.0.10
</code></pre>
</div><p>Ya hemos terminado de configurar este escenario y podemos pasar a hacer las pruebas:</p>
<ul>
<li>Las rutas del servidor del escenario 1:</li>
</ul>
<p><img src="./../images/SAD/vpn/10-B.png" alt="image"></p>
<ul>
<li>Las rutas del servidor del escenario 2:</li>
</ul>
<p><img src="./../images/SAD/vpn/11-B.png" alt="image"></p>
<ul>
<li>Desde el cliente del escenario 1:</li>
</ul>
<p><img src="./../images/SAD/vpn/12-B.png" alt="image"></p>
<ul>
<li>Desde el cliente del escenario 2:</li>
</ul>
<p><img src="./../images/SAD/vpn/13-B.png" alt="image"></p>
<p>Ambas computadoras clientes están conectadas entre sí y al utilizar el comando &quot;traceroute&quot; se puede ver que el tráfico entre ellas pasa a través de un túnel.</p>
<h2 id="c-vpn-de-acceso-remoto-con-wireguard-5-puntos"> C) VPN de acceso remoto con WireGuard (5 puntos)</h2>
<p><strong>Monta una VPN de acceso remoto usando Wireguard. Intenta probarla con clientes Windows, Linux y Android o iOS. Documenta el proceso adecuadamente y compáralo con el del apartado A.</strong></p>
<hr>
<p>Voy a establecer una conexión VPN de acceso remoto utilizando WireGuard, la cual será utilizada por tres dispositivos: una computadora con sistema operativo Debian 11, una computadora con Windows 10, y un dispositivo móvil con sistema operativo Android o iOS. El dispositivo que actuará como servidor será una maquina virtual, exceptuando la prueba del cliente de android o ios que será mi computadora principal, mientras que los dispositivos clientes serán máquinas virtuales, excepto el dispositivo móvil.</p>
<p>A conticuación el Vagrantfile de este escenario:</p>
<p><a href="https://pastebin.com/DSu5CTa0" target="_blank" rel="noopener noreferrer">Vagrantfile<i>Content not supported</i></a></p>
<p>En el cliente interno solo cambiaremos la ruta por defecto:</p>
<div><pre><code>sudo ip r del default
sudo ip r add default via 192.168.10.10
</code></pre>
</div><p><em><strong>Servidor</strong></em></p>
<p>Para empezar, vamos a configurar el servidor. Lo primero que haremos es instalar el paquete necesario.</p>
<div><pre><code>apt install wireguard
</code></pre>
</div><p>Antes de continuar, debemos asegurarnos de haber habilitado el reenvío de paquetes en el servidor.</p>
<div><pre><code>nano /etc/sysctl.conf

net.ipv4.ip_forward = 1
</code></pre>
</div><p>Y guardamos los cambios</p>
<div><pre><code>sysctl -p
</code></pre>
</div><p>A continuación, crearemos los archivos de configuración necesarios en la carpeta principal de WireGuard.</p>
<div><pre><code>cd /etc/wireguard/
</code></pre>
</div><p>A continuación, generaremos el par de claves necesarias utilizando el comando recomendado por la página oficial de Wireguard.</p>
<div><pre><code>wg genkey | tee serverprivatekey | wg pubkey &gt; serverpublickey
</code></pre>
</div><hr>
<div><pre><code>cat serverprivatekey 

EN5dqPbfGb8YLzrFbbpr0JgqOJ1lx1oY/05MoomU+m0=
</code></pre>
</div><hr>
<div><pre><code>cat serverpublickey 

V6tMkGlJqkfZVG6zchnzmH1kHaCH0OMW3eMuNDZspSg=
</code></pre>
</div><p>A continuación, crearemos el archivo de configuración que tendrá el mismo nombre de la interfaz a crear (wg0).</p>
<div><pre><code>nano wg0.conf

# Server config
[Interface]
Address = 10.99.99.1
PrivateKey = EN5dqPbfGb8YLzrFbbpr0JgqOJ1lx1oY/05MoomU+m0=
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
</code></pre>
</div><p>En el archivo de configuración anterior, encontrará una sección llamada &quot;Interface&quot;(Interfaz) que incluye lo siguiente:</p>
<ul>
<li>
<p><em>Address</em>: La dirección IP asignada al servidor (la dirección de la VPN).</p>
</li>
<li>
<p><em>PrivateKey</em>: La clave privada generada en el servidor.</p>
</li>
<li>
<p><em>ListenPort</em>: El puerto en el que WireGuard escuchará. No es obligatorio, pero es recomendable especialmente en el caso de trabajar con firewalls.</p>
</li>
<li>
<p><em>PostUp / PostDown</em>: Reglas de iptables que se activarán y desactivarán al levantar la interfaz que hemos definido.</p>
</li>
</ul>
<p>En este momento ya podemos activar la interfaz que hemos creado</p>
<div><pre><code>wg-quick up wg0
</code></pre>
</div><p><img src="./../images/SAD/vpn/1-C.png" alt="image"></p>
<p>Podemos ver que el servidor se encuentra activo:</p>
<div><pre><code>wg
</code></pre>
</div><p><img src="./../images/SAD/vpn/2-C.png" alt="image"></p>
<p>También podemos ver que se ha creado la interfaz que hemos definido:</p>
<p><img src="./../images/SAD/vpn/3-C.png" alt="image"></p>
<p>Hemos terminado con la configuración básica del servidor. A continuación configuraremos los clientes.</p>
<h4 id="cliente-linux-debian-11"> Cliente Linux (Debian 11)</h4>
<p>Igual que hicimos con el servidor, necesitamos instalar WireGuard y generar el par de claves para los dispositivos clientes:</p>
<div><pre><code>sudo apt install wireguard
</code></pre>
</div><hr>
<div><pre><code>cd /etc/wireguard/
</code></pre>
</div><hr>
<div><pre><code>wg genkey | tee clientprivatekey | wg pubkey &gt; clientpublickey
</code></pre>
</div><hr>
<div><pre><code>cat clientprivatekey 

gCRT5AII1VH0lpZGESpNfEvD5xtfQddUp1Qdilxg9Ww=
</code></pre>
</div><hr>
<div><pre><code>cat clientpublickey 

GjTH3fo/Z6KgryKoGxwxhyW98O+pfULTjxSMmlS9GxI=
</code></pre>
</div><p>Igual que en el servidor, también crearemos un archivo de configuración con la siguiente información en los dispositivos clientes.</p>
<div><pre><code>nano wg0.conf

[Interface]
Address = 10.99.99.2
PrivateKey = gCRT5AII1VH0lpZGESpNfEvD5xtfQddUp1Qdilxg9Ww=
ListenPort = 51820
PostUp = ip route add 192.168.10.0/24 dev wg0
PostDown = ip route del 192.168.10.0/24 dev wg0

[Peer]
PublicKey = V6tMkGlJqkfZVG6zchnzmH1kHaCH0OMW3eMuNDZspSg=
AllowedIPs = 0.0.0.0/0
Endpoint = 192.168.121.110:51820
</code></pre>
</div><p>En el bloque &quot;Interface&quot;(Interfaz) en el dispositivo cliente es similar al del servidor, pero se ha agregado un bloque llamado &quot;Peer&quot;(Pares) que se replicará más tarde en el servidor, que contiene la siguiente información:</p>
<ul>
<li>
<p><em>PublicKey</em>: La clave pública del servidor.</p>
</li>
<li>
<p><em>PostUp</em>: Hemos agregado la ruta estática a la red interna a la que nos conectaremos.</p>
</li>
<li>
<p><em>AllowedIPs</em>: Se especifica una lista de direcciones IP de las cuales los paquetes pueden ser recibidos sin ser descartados. Actúa como un firewall dentro de WireGuard.</p>
</li>
<li>
<p><em>Endpoint</em>: La dirección IP del dispositivo que actúa como servidor en la conexión VPN de WireGuard.</p>
</li>
</ul>
<p>Con esto ya podemos activar la interfaz que hemos configurado:</p>
<div><pre><code>wg-quick up wg0
</code></pre>
</div><p><img src="./../images/SAD/vpn/4-C.png" alt="image"></p>
<p>También podemos ver la interfaz que hemos creado:</p>
<p><img src="./../images/SAD/vpn/5-C.png" alt="image"></p>
<p>Con esto hemos terminado de configurar el cliente, pero para que funcione debemos agregar también el bloque &quot;Peer&quot;(Pares) en el lado del servidor (uno por cada cliente que conectemos). Por lo tanto, el archivo de configuración del servidor quedaría de la siguiente manera:</p>
<div><pre><code>nano wg0.conf

# Server config
[Interface]
Address = 10.99.99.1
PrivateKey = EN5dqPbfGb8YLzrFbbpr0JgqOJ1lx1oY/05MoomU+m0=
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# Clients configs

# Cliente Debian 11
[Peer]
Publickey = GjTH3fo/Z6KgryKoGxwxhyW98O+pfULTjxSMmlS9GxI=
AllowedIPs = 10.99.99.2/32
PersistentKeepAlive = 25
</code></pre>
</div><p>En el bloque “Peer”(Pares) hemos incluido lo siguiente:</p>
<ul>
<li>
<p><em>PublicKey</em>: La clave pública del cliente.</p>
</li>
<li>
<p><em>PersistentKeepAlive</em>: Si no hay intercambio de paquetes entre las máquinas después de 25 segundos, se enviará un paquete para comprobar si la conexión sigue activa.</p>
</li>
</ul>
<p>Con este bloque que hemos añadido, ya podemos reiniciar el servicio:</p>
<div><pre><code>wg-quick down wg0
</code></pre>
</div><hr>
<div><pre><code>wg-quick up wg0
</code></pre>
</div><p>Podemos ver el servicio activado con el cliente conectado:</p>
<div><pre><code>wg
</code></pre>
</div><p><img src="./../images/SAD/vpn/6-C.png" alt="image"></p>
<p>Con esto ya hemos terminado completamente con el lado del cliente Linux. Probemos si ha funcionado:</p>
<ul>
<li>Ping y traceroute desde el cliente externo a la red interna:</li>
</ul>
<p><img src="./../images/SAD/vpn/7-C.png" alt="image"></p>
<ul>
<li>Ping y traceroute desde el cliente interno a la interfaz del túnel en el cliente externo:</li>
</ul>
<p><img src="./../images/SAD/vpn/8-C.png" alt="image"></p>
<h4 id="cliente-windows-windows-10"> Cliente Windows (Windows 10)</h4>
<p>Para configurar el sistema en Windows, es necesario descargar una iso y abrirlo una vez instalado. Crearemos un túnel vacío, generando automáticamente las claves necesarias. El siguiente paso será completar el archivo de configuración con la información necesaria.</p>
<p><img src="./../images/SAD/vpn/9-C.png" alt="image"></p>
<p>Una vez hayamos completado la configuración en el lado del cliente Windows, debemos pasar al lado del servidor y agregar un nuevo bloque &quot;Peer&quot; similar al que agregamos en el cliente Linux.</p>
<div><pre><code>nano /etc/wireguard/wg0.conf

# Server config
[Interface]
Address = 10.99.99.1
PrivateKey = EN5dqPbfGb8YLzrFbbpr0JgqOJ1lx1oY/05MoomU+m0=
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# Clients configs

# Cliente Debian 11
[Peer]
Publickey = GjTH3fo/Z6KgryKoGxwxhyW98O+pfULTjxSMmlS9GxI=
AllowedIPs = 10.99.99.2/32
PersistentKeepAlive = 25

# Cliente Windows 10
[Peer]
Publickey = yLC/jJFdkg5wuzHGGZm6TdrTECfkurXDqhCaxXCRTFo=
AllowedIPs = 10.99.99.3/32
PersistentKeepAlive = 25
</code></pre>
</div><p>Ahora que lo hemos hecho, podemos reiniciar el servicio en el servidor:</p>
<div><pre><code>wg-quick down wg0
</code></pre>
</div><hr>
<div><pre><code>wg-quick up wg0
</code></pre>
</div><p>Una vez iniciado en el servidor, activamos el túnel en el cliente windows:</p>
<p><img src="./../images/SAD/vpn/10-C.png" alt="image"></p>
<p>Podemos ver en el lado del servidor que se ha añadido un nuevo “Peer”:</p>
<p><img src="./../images/SAD/vpn/11-C.png" alt="image"></p>
<p>Ahora hagamos las pruebas:</p>
<ul>
<li>Ping y traceroute desde el cliente windows a la red interna:</li>
</ul>
<p><img src="./../images/SAD/vpn/12-C.png" alt="image"></p>
<ul>
<li>Ping y traceroute desde el cliente interno a la interfaz del túnel en el cliente windows:</li>
</ul>
<p><img src="./../images/SAD/vpn/13-C.png" alt="image"></p>
<h4 id="cliente-android-o-ios"> Cliente Android o iOS</h4>
<p>Para utilizar Wireguard en un dispositivo Android o iOS, es necesario descargar la aplicación desde la tienda de aplicaciones de Google Playstore o App Store.</p>
<p><img src="./../images/SAD/vpn/1-C-android.png" alt="image"></p>
<p>Una vez en la aplicación, veremos que nos da tres opciones para crear el túnel:</p>
<p><img src="./../images/SAD/vpn/2-C-android.png" alt="image"></p>
<p>Para usar Wireguard en Android o iOS, primero debes descargar la aplicación desde la Playstore o App Store. Una vez hecho esto, puedes generar el par de claves en el cliente y crear un archivo de configuración. Una forma fácil de importar la configuración en tu dispositivo móvil es utilizar la opción de &quot;Crear desde código QR&quot;, para ello, puedes utilizar un paquete para convertir el archivo de configuración en un código QR que pueda ser escaneado por tu dispositivo móvil.</p>
<div><pre><code>wg genkey | tee clientprivatekey | wg pubkey &gt; clientpublickey
</code></pre>
</div><hr>
<div><pre><code>cat clientprivatekey

SEVl3i3Oj2SKPyVP9V2dULxaNiRhbCFgfYhRA59MtVI=
</code></pre>
</div><hr>
<div><pre><code>cat clientpublickey

SnWqP6EjnlX6ecN6sjrs5ybdVeYK+jlhBJLc7tkJExs=
</code></pre>
</div><p>Nos generamos el fichero de configuración tal y como hicimos con el cliente linux:</p>
<div><pre><code>nano clientelinux.conf
                                    
[Interface]
Address = 10.99.99.4
PrivateKey = SEVl3i3Oj2SKPyVP9V2dULxaNiRhbCFgfYhRA59MtVI=
ListenPort = 51820

[Peer]
Publickey = evAbFv7RnmD0tKU8eBT5AIc1NPc/Le3FWm2tFnKRfTE=
AllowedIPs = 0.0.0.0/0
Endpoint = 192.168.1.78:51820
</code></pre>
</div><p>Ahora nos instalamos el paquete para convertir esta configuración en un código qr:</p>
<div><pre><code>apt install qrencode
</code></pre>
</div><p>Y lo ejecutamos:</p>
<div><pre><code>qrencode -t ansiutf8 &lt; clientelinux.conf 
</code></pre>
</div><p><img src="./../images/SAD/vpn/3-C-android.png" alt="image"></p>
<p>Ahora lo escaneamos con el móvil. Una vez escaneado podemos ver la configuración que ha importado:</p>
<p>image</p>
<p>Ya solo tenemos que añadir el nuevo bloque “Peer” a la configuración del servidor:</p>
<div><pre><code>nano wg0.conf 

# Server config
[Interface]
Address = 10.99.99.1
PrivateKey = 4MdgspEZXa36HRzvG0PvTyshgzdQgX/cZKEm0fipkFY=
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o wlp2s0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o wlp2s0 -j MASQUERADE

# Clients configs

# Cliente Android
[Peer]
Publickey = R4+mPQdkslRgRTGOME1mDkb8Lw/0VWTLYHKJPm+5zDM=
AllowedIPs = 10.99.99.4/32
PersistentKeepAlive = 25
</code></pre>
</div><p>Ahora ya podemos reiniciar el servicio en el servidor:</p>
<div><pre><code>wg-quick down wg0

wg-quick up wg0
</code></pre>
</div><p>En este momento podemos ver que están conectados los 3 peers que hemos añadido (tras iniciar el túnel en el dispositivo android o iOS):</p>
<p>Ahora ya podemos realizar las pruebas de funcionamiento (nos hemos instalado una aplicación llamada iNetTools para ejecutar los comandos adecuados):</p>
<ul>
<li>
<p>Ping y traceroute desde el cliente android a la red interna:</p>
</li>
<li>
<p>Ping y traceroute desde el cliente interno a la interfaz del túnel en el cliente windows:</p>
</li>
</ul>
<p>(Sin terminar)</p>
<h3 id="comparativa-con-openvpn-apartado-a"> Comparativa con OpenVPN (Apartado A)</h3>
<p>Después de configurar el acceso remoto con OpenVPN y Wireguard, he descubierto que Wireguard es superior en varios aspectos. En primer lugar, se ha demostrado que es más rápido que OpenVPN en pruebas realizadas en máquinas virtuales. Esto podría mejorar significativamente la experiencia del usuario en un entorno real. Además, la configuración de Wireguard es más sencilla y se comparte de manera similar en todos los clientes, independientemente del sistema operativo utilizado. Finalmente, Wireguard no requiere la creación de una autoridad certificadora, lo que es una ventaja adicional.</p>
<h2 id="d-vpn-sitio-a-sitio-con-wireguard-10-puntos"> D) VPN sitio a sitio con WireGuard (10 puntos)</h2>
<p><strong>Configura una VPN sitio a sitio usando WireGuard. Documenta el proceso adecuadamente y compáralo con el del apartado B.</strong></p>
<p>De forma similar a como lo hicimos con OpenVPN, vamos a crear un entorno de prueba utilizando el mismo archivo <a href="https://pastebin.com/xrPNkVJt" target="_blank" rel="noopener noreferrer">Vagrantfile<i>Content not supported</i></a> del segundo apartado. Una vez establecido el entorno, debemos configurar adecuadamente las máquinas para usar Wireguard.</p>
<p>Para comenzar, debemos modificar la ruta predeterminada en ambos clientes. Si no se realizó en Vagrant, este paso no sería necesario.</p>
<p>En el cliente del escenario 1:</p>
<div><pre><code>sudo ip r del default
sudo ip r add default via 30.0.0.10
</code></pre>
</div><p>En el cliente del escenario 2:</p>
<div><pre><code>sudo ip r del default
sudo ip r add default via 20.0.0.10
</code></pre>
</div><p>Una vez configuradas las rutas en los clientes, procedemos a configurar las máquinas que actuarán como servidor y cliente de Wireguard.</p>
<p>En la máquina “Servidor1” del escenario 1 instalamos en primer lugar wireguard:</p>
<div><pre><code>sudo apt install wireguard
</code></pre>
</div><p>A continuación activamos el bit de forwarding y hacemos esta configuración permanente:</p>
<div><pre><code>echo 1 &gt; sudo /proc/sys/net/ipv4/ip_forward
</code></pre>
</div><hr>
<div><pre><code>sudo nano /etc/sysctl.conf                                          

net.ipv4.ip_forward=1
</code></pre>
</div><p>Después, al igual que hicimos antes, tenemos que generar el par de claves:</p>
<div><pre><code>cd /etc/wireguard
</code></pre>
</div><hr>
<div><pre><code>wg genkey | tee serverprivatekey | wg pubkey &gt; serverpublickey
</code></pre>
</div><hr>
<div><pre><code>cat serverprivatekey

cC+ti1+R0GaTwEjYF1FYtENEnJcsUWhIuwM1JDxhA0g=
</code></pre>
</div><hr>
<div><pre><code>cat serverpublickey

SsXvBbNfZ+TosuxjIy9bzYQYAPnbr1gmdvnn3RcR53s=
</code></pre>
</div><p>Ahora ya podemos crear el fichero de configuración, que será muy parecido al que creamos en el apartado anterior:</p>
<div><pre><code>nano wg0.conf

# Server config
[Interface]
Address = 10.99.99.1
PrivateKey = cC+ti1+R0GaTwEjYF1FYtENEnJcsUWhIuwM1JDxhA0g=
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
</code></pre>
</div><p>En este momento, ya podemos probar a iniciar el servicio:</p>
<div><pre><code>wg-quick up wg0
</code></pre>
</div><p>Podemos ver que el servicio se ha iniciado correctamente:</p>
<div><pre><code>wg
</code></pre>
</div><p><img src="./../images/SAD/vpn/1-D.png" alt="image"></p>
<p>Una vez que hemos configurado las rutas, debemos proceder a configurar la máquina &quot;Servidor2&quot; como cliente de Wireguard en el escenario 2. Primero, debemos instalar Wireguard en esa máquina.</p>
<div><pre><code>sudo apt install wireguard
</code></pre>
</div><p>Y activamos el bit de forwarding, haciéndolo permanente:</p>
<div><pre><code>echo 1 &gt; sudo /proc/sys/net/ipv4/ip_forward
</code></pre>
</div><hr>
<div><pre><code>sudo nano /etc/sysctl.conf                                          

net.ipv4.ip_forward=1
</code></pre>
</div><p>Generaremos el par de claves que usará esta máquina:</p>
<div><pre><code>cd /etc/wireguard

wg genkey | tee clientprivatekey | wg pubkey &gt; clientpublickey
</code></pre>
</div><hr>
<div><pre><code>cat clientprivatekey

OLjGjIFwJYNa2FKWYjpcmjDlBXjyQDuf5IBxvc0HNV4=
</code></pre>
</div><hr>
<div><pre><code>cat clientpublickey

t6xa/d6mLIRK1vqbjM1zgF/K7iUz2SeoDrAIz6hWtSk=
</code></pre>
</div><p>Ahora debemos configurar la máquina &quot;Servidor2&quot; para que actúe como cliente de Wireguard en el escenario 2. Así que en primer lugar, instalamos Wireguard en esa máquina y luego creamos el archivo de configuración que utilizará, también agregando el bloque &quot;Peer&quot; tal como lo hicimos en el paso anterior.</p>
<div><pre><code>nano wg0.conf

[Interface]
Address = 10.99.99.2
PrivateKey = 2IZ8qGagupYbFsWBQjLVCkmNCuuRrlIp+ScliSIyTnE=
ListenPort = 51820

[Peer]
PublicKey = 4dAlX0YhNeSWdEmVEiB779cOECpryHWLFhx1rEnuPmA=
AllowedIPs = 10.99.99.1/32, 30.0.0.0/24
Endpoint = 192.168.121.183:51820
</code></pre>
</div><p>Para activar el servicio de Wireguard, es necesario añadir un bloque &quot;Peer&quot; en el fichero de configuración del escenario 1 antes de iniciar el servicio.</p>
<div><pre><code>nano wg0.conf

# Server config
[Interface]
Address = 10.99.99.1
PrivateKey = cHi1Gnj0aP82bNUJ9mp+3rMClVzvnCt1128uTaHk+mQ=
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# Cliente Escenario 2
[Peer]
Publickey = h3gPs1hb/csc0+QEAtPohrR/RrsAfKNNsI6HSaki61I=
AllowedIPs = 10.99.99.2/32, 20.0.0.0/24
PersistentKeepAlive = 25
</code></pre>
</div><p>Ahora reiniciamos el servicio en la máquina “Servidor1” del escenario 1:</p>
<div><pre><code>wg-quick down wg0

wg-quick up wg0
</code></pre>
</div><p>Ya podemos iniciar el servicio en el escenario 2:</p>
<div><pre><code>wg-quick up wg0
</code></pre>
</div><p>Y podemos ver que se han establecido la conexión:</p>
<p><img src="./../images/SAD/vpn/2-D.png" alt="image"></p>
<p>Ahora ya podemos realizar las pruebas necesarias:</p>
<ul>
<li>Rutas en la máquina “Servidor1” del escenario 1:</li>
</ul>
<p><img src="./../images/SAD/vpn/3-D.png" alt="image"></p>
<ul>
<li>Ping y traceroute desde el cliente del escenario 1 al cliente del escenario 2:</li>
</ul>
<p><img src="./../images/SAD/vpn/4-D.png" alt="image"></p>
<ul>
<li>Rutas en la máquina “Servidor2” del escenario 2:</li>
</ul>
<p><img src="./../images/SAD/vpn/5-D.png" alt="image"></p>
<ul>
<li>Ping y traceroute desde el cliente del escenario 2 al cliente del escenario 1:</li>
</ul>
<p><img src="./../images/SAD/vpn/6-D.png" alt="image"></p>
<h3 id="comparativa-con-openvpn-apartado-b"> Comparativa con OpenVPN (Apartado B)</h3>
<p>Después de configurar el site to site con OpenVPN y Wireguard, me he dado cuenta de que Wireguard es superior a OpenVPN en varios aspectos, tal como sucedió con el acceso remoto. En primer lugar, la configuración de Wireguard es mucho más sencilla y rápida en comparación con OpenVPN, con una sintaxis más fácil de entender. Aunque no he podido comprobarlo en profundidad en un entorno de máquinas virtuales, he notado una mayor velocidad al realizar pruebas y establecer conexiones con Wireguard. Además, sigue siendo cómodo de configurar ya que no se requiere crear una autoridad certificadora.</p>
<h3 id="extra-1-vpn-de-acceso-remoto-con-ipsec-5-puntos"> Extra 1) VPN de acceso remoto con Ipsec (5 puntos)</h3>
<p><strong>Elige una aplicación por software (por ejemplo, FreeS/Wan) y monta la configuración. Documenta el proceso detalladamente.</strong></p>
<h3 id="extra-2-vpn-sitio-a-sitio-con-ipsec-10-puntos"> Extra 2) VPN sitio a sitio con IPsec (10 puntos)</h3>
<p><strong>Montando el escenario en GNS3 usando routers CISCO o con una aplicación por software (por ejemplo, FreeS/Wan) despliega la configuración solicitada. Documenta el proceso detalladamente.</strong></p>
]]></content>
    <author>
      <name>Óscar Lucas</name>
    </author>
    <category term="practicas" scheme=""/>
    <contributor>
      <name>Óscar Lucas</name>
    </contributor>
    <rights>Copyright by Óscar Lucas</rights>
  </entry>
</feed>